// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "spelcom3.h"

/////////////////////////////////////////////////////////////////////////////
// CSPELCom3

IMPLEMENT_DYNCREATE(CSPELCom3, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CSPELCom3 properties

CString CSPELCom3::GetPassword()
{
	CString result;
	GetProperty(0x1, VT_BSTR, (void*)&result);
	return result;
}

void CSPELCom3::SetPassword(LPCTSTR propVal)
{
	SetProperty(0x1, VT_BSTR, propVal);
}

short CSPELCom3::GetTimeOut()
{
	short result;
	GetProperty(0x2, VT_I2, (void*)&result);
	return result;
}

void CSPELCom3::SetTimeOut(short propVal)
{
	SetProperty(0x2, VT_I2, propVal);
}

BOOL CSPELCom3::GetMotorsOn()
{
	BOOL result;
	GetProperty(0x3, VT_BOOL, (void*)&result);
	return result;
}

void CSPELCom3::SetMotorsOn(BOOL propVal)
{
	SetProperty(0x3, VT_BOOL, propVal);
}

CString CSPELCom3::GetErrorMessage()
{
	CString result;
	GetProperty(0x6, VT_BSTR, (void*)&result);
	return result;
}

long CSPELCom3::GetErrorNumber()
{
	long result;
	GetProperty(0x7, VT_I4, (void*)&result);
	return result;
}

BOOL CSPELCom3::GetDesignMode()
{
	BOOL result;
	GetProperty(0x8, VT_BOOL, (void*)&result);
	return result;
}

void CSPELCom3::SetDesignMode(BOOL propVal)
{
	SetProperty(0x8, VT_BOOL, propVal);
}

BOOL CSPELCom3::GetPowerHigh()
{
	BOOL result;
	GetProperty(0x9, VT_BOOL, (void*)&result);
	return result;
}

void CSPELCom3::SetPowerHigh(BOOL propVal)
{
	SetProperty(0x9, VT_BOOL, propVal);
}

CString CSPELCom3::GetProject()
{
	CString result;
	GetProperty(0xa, VT_BSTR, (void*)&result);
	return result;
}

void CSPELCom3::SetProject(LPCTSTR propVal)
{
	SetProperty(0xa, VT_BSTR, propVal);
}

BOOL CSPELCom3::GetPortOpen()
{
	BOOL result;
	GetProperty(0xb, VT_BOOL, (void*)&result);
	return result;
}

void CSPELCom3::SetPortOpen(BOOL propVal)
{
	SetProperty(0xb, VT_BOOL, propVal);
}

BOOL CSPELCom3::GetQPOn()
{
	BOOL result;
	GetProperty(0xc, VT_BOOL, (void*)&result);
	return result;
}

void CSPELCom3::SetQPOn(BOOL propVal)
{
	SetProperty(0xc, VT_BOOL, propVal);
}

LPDISPATCH CSPELCom3::GetVideoControl()
{
	LPDISPATCH result;
	GetProperty(0xd, VT_DISPATCH, (void*)&result);
	return result;
}

void CSPELCom3::SetVideoControl(LPDISPATCH propVal)
{
	SetProperty(0xd, VT_DISPATCH, propVal);
}

short CSPELCom3::GetRobot()
{
	short result;
	GetProperty(0xe, VT_I2, (void*)&result);
	return result;
}

void CSPELCom3::SetRobot(short propVal)
{
	SetProperty(0xe, VT_I2, propVal);
}

short CSPELCom3::GetForce_Sensor()
{
	short result;
	GetProperty(0xf, VT_I2, (void*)&result);
	return result;
}

void CSPELCom3::SetForce_Sensor(short propVal)
{
	SetProperty(0xf, VT_I2, propVal);
}

BOOL CSPELCom3::GetForce_TCOn()
{
	BOOL result;
	GetProperty(0x10, VT_BOOL, (void*)&result);
	return result;
}

void CSPELCom3::SetForce_TCOn(BOOL propVal)
{
	SetProperty(0x10, VT_BOOL, propVal);
}

/////////////////////////////////////////////////////////////////////////////
// CSPELCom3 operations

void CSPELCom3::Abort()
{
	InvokeHelper(0x11, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CSPELCom3::Accel(short PointToPointAccel, short PointToPointDecel)
{
	static BYTE parms[] =
		VTS_I2 VTS_I2;
	InvokeHelper(0x12, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 PointToPointAccel, PointToPointDecel);
}

void CSPELCom3::AccelS(short CPAccel)
{
	static BYTE parms[] =
		VTS_I2;
	InvokeHelper(0x13, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 CPAccel);
}

void CSPELCom3::Arch(short ArchNumber, float VerticalRise, float VerticalLower)
{
	static BYTE parms[] =
		VTS_I2 VTS_R4 VTS_R4;
	InvokeHelper(0x14, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 ArchNumber, VerticalRise, VerticalLower);
}

void CSPELCom3::ArmSet(short ArmNumber, float Param1, float Param2, float Param3, float Param4, float Param5)
{
	static BYTE parms[] =
		VTS_I2 VTS_R4 VTS_R4 VTS_R4 VTS_R4 VTS_R4;
	InvokeHelper(0x15, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 ArmNumber, Param1, Param2, Param3, Param4, Param5);
}

double CSPELCom3::Atan(double Number)
{
	double result;
	static BYTE parms[] =
		VTS_R8;
	InvokeHelper(0x16, DISPATCH_METHOD, VT_R8, (void*)&result, parms,
		Number);
	return result;
}

double CSPELCom3::Atan2(double Dx, double Dy)
{
	double result;
	static BYTE parms[] =
		VTS_R8 VTS_R8;
	InvokeHelper(0x17, DISPATCH_METHOD, VT_R8, (void*)&result, parms,
		Dx, Dy);
	return result;
}

void CSPELCom3::BuildProject()
{
	InvokeHelper(0x18, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CSPELCom3::Clear()
{
	InvokeHelper(0x19, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CSPELCom3::Cont()
{
	InvokeHelper(0x1a, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

float CSPELCom3::CX(const VARIANT& Point)
{
	float result;
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0x1b, DISPATCH_METHOD, VT_R4, (void*)&result, parms,
		&Point);
	return result;
}

float CSPELCom3::CY(const VARIANT& Point)
{
	float result;
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0x1c, DISPATCH_METHOD, VT_R4, (void*)&result, parms,
		&Point);
	return result;
}

float CSPELCom3::CZ(const VARIANT& Point)
{
	float result;
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0x1d, DISPATCH_METHOD, VT_R4, (void*)&result, parms,
		&Point);
	return result;
}

short CSPELCom3::Ctr(short BitNumber)
{
	short result;
	static BYTE parms[] =
		VTS_I2;
	InvokeHelper(0x1e, DISPATCH_METHOD, VT_I2, (void*)&result, parms,
		BitNumber);
	return result;
}

void CSPELCom3::CtReset(short BitNumber)
{
	static BYTE parms[] =
		VTS_I2;
	InvokeHelper(0x1f, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 BitNumber);
}

float CSPELCom3::CU(const VARIANT& Point)
{
	float result;
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0x20, DISPATCH_METHOD, VT_R4, (void*)&result, parms,
		&Point);
	return result;
}

void CSPELCom3::Delay(long ms)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x21, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 ms);
}

double CSPELCom3::DegToRad(double Degrees)
{
	double result;
	static BYTE parms[] =
		VTS_R8;
	InvokeHelper(0x22, DISPATCH_METHOD, VT_R8, (void*)&result, parms,
		Degrees);
	return result;
}

void CSPELCom3::ExecSPELCmd(LPCTSTR Command)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x23, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 Command);
}

void CSPELCom3::Fine(long Axis1Pulses, long Axis2Pulses, long Axis3Pulses, long Axis4Pulses)
{
	static BYTE parms[] =
		VTS_I4 VTS_I4 VTS_I4 VTS_I4;
	InvokeHelper(0x24, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 Axis1Pulses, Axis2Pulses, Axis3Pulses, Axis4Pulses);
}

BOOL CSPELCom3::GetBitValue(long InputData, short BitNumber)
{
	BOOL result;
	static BYTE parms[] =
		VTS_I4 VTS_I2;
	InvokeHelper(0x25, DISPATCH_METHOD, VT_BOOL, (void*)&result, parms,
		InputData, BitNumber);
	return result;
}

void CSPELCom3::Halt(short TaskNumber)
{
	static BYTE parms[] =
		VTS_I2;
	InvokeHelper(0x26, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 TaskNumber);
}

void CSPELCom3::HomeSet(long Axis1Pulses, long Axis2Pulses, long Axis3Pulses, long Axis4Pulses)
{
	static BYTE parms[] =
		VTS_I4 VTS_I4 VTS_I4 VTS_I4;
	InvokeHelper(0x27, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 Axis1Pulses, Axis2Pulses, Axis3Pulses, Axis4Pulses);
}

void CSPELCom3::Home()
{
	InvokeHelper(0x28, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CSPELCom3::Hordr(short Home1, short Home2, short Home3, short Home4)
{
	static BYTE parms[] =
		VTS_I2 VTS_I2 VTS_I2 VTS_I2;
	InvokeHelper(0x29, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 Home1, Home2, Home3, Home4);
}

void CSPELCom3::Out(short PortNumber, short PortValue)
{
	static BYTE parms[] =
		VTS_I2 VTS_I2;
	InvokeHelper(0x2a, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 PortNumber, PortValue);
}

void CSPELCom3::OpBCD(short PortNumber, short PortValue)
{
	static BYTE parms[] =
		VTS_I2 VTS_I2;
	InvokeHelper(0x2b, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 PortNumber, PortValue);
}

void CSPELCom3::JRange(short AxisNumber, long AxisMinPulses, long AxisMaxPulses)
{
	static BYTE parms[] =
		VTS_I2 VTS_I4 VTS_I4;
	InvokeHelper(0x2c, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 AxisNumber, AxisMinPulses, AxisMaxPulses);
}

void CSPELCom3::MCal()
{
	InvokeHelper(0x2d, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

short CSPELCom3::In(short PortNumber)
{
	short result;
	static BYTE parms[] =
		VTS_I2;
	InvokeHelper(0x2f, DISPATCH_METHOD, VT_I2, (void*)&result, parms,
		PortNumber);
	return result;
}

long CSPELCom3::Hour()
{
	long result;
	InvokeHelper(0x30, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

short CSPELCom3::InBCD(short PortNumber)
{
	short result;
	static BYTE parms[] =
		VTS_I2;
	InvokeHelper(0x31, DISPATCH_METHOD, VT_I2, (void*)&result, parms,
		PortNumber);
	return result;
}

BOOL CSPELCom3::Sw(short BitNumber)
{
	BOOL result;
	static BYTE parms[] =
		VTS_I2;
	InvokeHelper(0x32, DISPATCH_METHOD, VT_BOOL, (void*)&result, parms,
		BitNumber);
	return result;
}

BOOL CSPELCom3::Oport(short BitNumber)
{
	BOOL result;
	static BYTE parms[] =
		VTS_I2;
	InvokeHelper(0x33, DISPATCH_METHOD, VT_BOOL, (void*)&result, parms,
		BitNumber);
	return result;
}

BOOL CSPELCom3::AtHome()
{
	BOOL result;
	InvokeHelper(0x34, DISPATCH_METHOD, VT_BOOL, (void*)&result, NULL);
	return result;
}

BOOL CSPELCom3::AxisLocked(short AxisNumber)
{
	BOOL result;
	static BYTE parms[] =
		VTS_I2;
	InvokeHelper(0x35, DISPATCH_METHOD, VT_BOOL, (void*)&result, parms,
		AxisNumber);
	return result;
}

BOOL CSPELCom3::CommandInCycle()
{
	BOOL result;
	InvokeHelper(0x36, DISPATCH_METHOD, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CSPELCom3::GetPoint(const VARIANT& Point, float* XCoord, float* YCoord, float* ZCoord, float* UCoord, short* LocalNumber, short* Orientation)
{
	static BYTE parms[] =
		VTS_VARIANT VTS_PR4 VTS_PR4 VTS_PR4 VTS_PR4 VTS_PI2 VTS_PI2;
	InvokeHelper(0x37, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 &Point, XCoord, YCoord, ZCoord, UCoord, LocalNumber, Orientation);
}

BOOL CSPELCom3::JS()
{
	BOOL result;
	InvokeHelper(0x38, DISPATCH_METHOD, VT_BOOL, (void*)&result, NULL);
	return result;
}

long CSPELCom3::Stat(short Address)
{
	long result;
	static BYTE parms[] =
		VTS_I2;
	InvokeHelper(0x3a, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		Address);
	return result;
}

BOOL CSPELCom3::EnableOn()
{
	BOOL result;
	InvokeHelper(0x3b, DISPATCH_METHOD, VT_BOOL, (void*)&result, NULL);
	return result;
}

BOOL CSPELCom3::ErrorOn()
{
	BOOL result;
	InvokeHelper(0x3c, DISPATCH_METHOD, VT_BOOL, (void*)&result, NULL);
	return result;
}

BOOL CSPELCom3::EstopOn()
{
	BOOL result;
	InvokeHelper(0x3d, DISPATCH_METHOD, VT_BOOL, (void*)&result, NULL);
	return result;
}

BOOL CSPELCom3::MCalComplete()
{
	BOOL result;
	InvokeHelper(0x3e, DISPATCH_METHOD, VT_BOOL, (void*)&result, NULL);
	return result;
}

double CSPELCom3::RadToDeg(double Radians)
{
	double result;
	static BYTE parms[] =
		VTS_R8;
	InvokeHelper(0x3f, DISPATCH_METHOD, VT_R8, (void*)&result, parms,
		Radians);
	return result;
}

void CSPELCom3::Pause()
{
	InvokeHelper(0x40, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

BOOL CSPELCom3::PauseOn()
{
	BOOL result;
	InvokeHelper(0x41, DISPATCH_METHOD, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CSPELCom3::PDel(short FirstPointNumber, short LastPointNumber)
{
	static BYTE parms[] =
		VTS_I2 VTS_I2;
	InvokeHelper(0x42, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 FirstPointNumber, LastPointNumber);
}

long CSPELCom3::Pls(short AxisNumber)
{
	long result;
	static BYTE parms[] =
		VTS_I2;
	InvokeHelper(0x43, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		AxisNumber);
	return result;
}

void CSPELCom3::PrgRst()
{
	InvokeHelper(0x44, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

BOOL CSPELCom3::ProjectBuildComplete()
{
	BOOL result;
	InvokeHelper(0x45, DISPATCH_METHOD, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CSPELCom3::Pulse(long Axis1Pulses, long Axis2Pulses, long Axis3Pulses, long Axis4Pulses)
{
	static BYTE parms[] =
		VTS_I4 VTS_I4 VTS_I4 VTS_I4;
	InvokeHelper(0x46, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 Axis1Pulses, Axis2Pulses, Axis3Pulses, Axis4Pulses);
}

void CSPELCom3::Quit(short TaskNumber)
{
	static BYTE parms[] =
		VTS_I2;
	InvokeHelper(0x47, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 TaskNumber);
}

void CSPELCom3::Range(long Axis1MinPulses, long Axis1MaxPulses, long Axis2MinPulses, long Axis2MaxPulses, long Axis3MinPulses, long Axis3MaxPulses, long Axis4MinPulses, long Axis4MaxPulses)
{
	static BYTE parms[] =
		VTS_I4 VTS_I4 VTS_I4 VTS_I4 VTS_I4 VTS_I4 VTS_I4 VTS_I4;
	InvokeHelper(0x48, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 Axis1MinPulses, Axis1MaxPulses, Axis2MinPulses, Axis2MaxPulses, Axis3MinPulses, Axis3MaxPulses, Axis4MinPulses, Axis4MaxPulses);
}

CString CSPELCom3::Reply()
{
	CString result;
	InvokeHelper(0x49, DISPATCH_METHOD, VT_BSTR, (void*)&result, NULL);
	return result;
}

void CSPELCom3::Reset()
{
	InvokeHelper(0x4a, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CSPELCom3::Resume(short TaskNumber)
{
	static BYTE parms[] =
		VTS_I2;
	InvokeHelper(0x4b, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 TaskNumber);
}

CString CSPELCom3::RobotModel()
{
	CString result;
	InvokeHelper(0x4c, DISPATCH_METHOD, VT_BSTR, (void*)&result, NULL);
	return result;
}

void CSPELCom3::RunDialog(long DialogID)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x4d, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 DialogID);
}

BOOL CSPELCom3::SafetyOn()
{
	BOOL result;
	InvokeHelper(0x4e, DISPATCH_METHOD, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CSPELCom3::SavePoints(LPCTSTR PointFileName)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x4f, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 PointFileName);
}

void CSPELCom3::SetPoint(const VARIANT& Point, float XCoord, float YCoord, float ZCoord, float UCoord, short LocalNumber, short Orientation)
{
	static BYTE parms[] =
		VTS_VARIANT VTS_R4 VTS_R4 VTS_R4 VTS_R4 VTS_I2 VTS_I2;
	InvokeHelper(0x50, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 &Point, XCoord, YCoord, ZCoord, UCoord, LocalNumber, Orientation);
}

void CSPELCom3::Arm(short ArmNumber)
{
	static BYTE parms[] =
		VTS_I2;
	InvokeHelper(0x51, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 ArmNumber);
}

short CSPELCom3::GetArm()
{
	short result;
	InvokeHelper(0x52, DISPATCH_METHOD, VT_I2, (void*)&result, NULL);
	return result;
}

void CSPELCom3::LimZ(float ZLimit)
{
	static BYTE parms[] =
		VTS_R4;
	InvokeHelper(0x53, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 ZLimit);
}

float CSPELCom3::GetLimZ()
{
	float result;
	InvokeHelper(0x54, DISPATCH_METHOD, VT_R4, (void*)&result, NULL);
	return result;
}

void CSPELCom3::Tool(short ToolNumber)
{
	static BYTE parms[] =
		VTS_I2;
	InvokeHelper(0x55, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 ToolNumber);
}

short CSPELCom3::GetTool()
{
	short result;
	InvokeHelper(0x56, DISPATCH_METHOD, VT_I2, (void*)&result, NULL);
	return result;
}

void CSPELCom3::TGo(const VARIANT& Destination)
{
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0x57, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 &Destination);
}

void CSPELCom3::TLSet(short ToolNumber, float XCoord, float YCoord, float ZCoord, float UCoord)
{
	static BYTE parms[] =
		VTS_I2 VTS_R4 VTS_R4 VTS_R4 VTS_R4;
	InvokeHelper(0x58, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 ToolNumber, XCoord, YCoord, ZCoord, UCoord);
}

void CSPELCom3::TMove(const VARIANT& Destination)
{
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0x59, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 &Destination);
}

BOOL CSPELCom3::TrapStop()
{
	BOOL result;
	InvokeHelper(0x5a, DISPATCH_METHOD, VT_BOOL, (void*)&result, NULL);
	return result;
}

BOOL CSPELCom3::TW()
{
	BOOL result;
	InvokeHelper(0x5b, DISPATCH_METHOD, VT_BOOL, (void*)&result, NULL);
	return result;
}

BOOL CSPELCom3::VCal(LPCTSTR CalibName)
{
	BOOL result;
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x5c, DISPATCH_METHOD, VT_BOOL, (void*)&result, parms,
		CalibName);
	return result;
}

BOOL CSPELCom3::VCalPoints(LPCTSTR CalibName)
{
	BOOL result;
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x5d, DISPATCH_METHOD, VT_BOOL, (void*)&result, parms,
		CalibName);
	return result;
}

void CSPELCom3::On(short BitNumber, const VARIANT& Seconds, const VARIANT& Parallel)
{
	static BYTE parms[] =
		VTS_I2 VTS_VARIANT VTS_VARIANT;
	InvokeHelper(0x5e, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 BitNumber, &Seconds, &Parallel);
}

void CSPELCom3::Off(short BitNumber, const VARIANT& Seconds, const VARIANT& Parallel)
{
	static BYTE parms[] =
		VTS_I2 VTS_VARIANT VTS_VARIANT;
	InvokeHelper(0x5f, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 BitNumber, &Seconds, &Parallel);
}

void CSPELCom3::Speed(short PointToPointSpeed)
{
	static BYTE parms[] =
		VTS_I2;
	InvokeHelper(0x60, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 PointToPointSpeed);
}

void CSPELCom3::SpeedS(short CPSpeed)
{
	static BYTE parms[] =
		VTS_I2;
	InvokeHelper(0x61, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 CPSpeed);
}

BOOL CSPELCom3::TaskStatus(short TaskNumber)
{
	BOOL result;
	static BYTE parms[] =
		VTS_I2;
	InvokeHelper(0x62, DISPATCH_METHOD, VT_BOOL, (void*)&result, parms,
		TaskNumber);
	return result;
}

BOOL CSPELCom3::TasksExecuting()
{
	BOOL result;
	InvokeHelper(0x63, DISPATCH_METHOD, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CSPELCom3::SFree(const VARIANT& AxisNumber1, const VARIANT& AxisNumber2, const VARIANT& AxisNumber3, const VARIANT& AxisNumber4)
{
	static BYTE parms[] =
		VTS_VARIANT VTS_VARIANT VTS_VARIANT VTS_VARIANT;
	InvokeHelper(0x64, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 &AxisNumber1, &AxisNumber2, &AxisNumber3, &AxisNumber4);
}

void CSPELCom3::SLock(const VARIANT& AxisNumber1, const VARIANT& AxisNumber2, const VARIANT& AxisNumber3, const VARIANT& AxisNumber4)
{
	static BYTE parms[] =
		VTS_VARIANT VTS_VARIANT VTS_VARIANT VTS_VARIANT;
	InvokeHelper(0x65, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 &AxisNumber1, &AxisNumber2, &AxisNumber3, &AxisNumber4);
}

short CSPELCom3::MemIn(short PortNumber)
{
	short result;
	static BYTE parms[] =
		VTS_I2;
	InvokeHelper(0x66, DISPATCH_METHOD, VT_I2, (void*)&result, parms,
		PortNumber);
	return result;
}

void CSPELCom3::MemOut(short PortNumber, short PortValue)
{
	static BYTE parms[] =
		VTS_I2 VTS_I2;
	InvokeHelper(0x67, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 PortNumber, PortValue);
}

void CSPELCom3::MemOn(short BitNumber)
{
	static BYTE parms[] =
		VTS_I2;
	InvokeHelper(0x68, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 BitNumber);
}

void CSPELCom3::MemOff(short BitNumber)
{
	static BYTE parms[] =
		VTS_I2;
	InvokeHelper(0x69, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 BitNumber);
}

void CSPELCom3::WaitSw(short BitNumber, BOOL Condition, float TimeInterval)
{
	static BYTE parms[] =
		VTS_I2 VTS_BOOL VTS_R4;
	InvokeHelper(0x6a, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 BitNumber, Condition, TimeInterval);
}

void CSPELCom3::WaitMem(short BitNumber, BOOL Condition, float TimeInterval)
{
	static BYTE parms[] =
		VTS_I2 VTS_BOOL VTS_R4;
	InvokeHelper(0x6b, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 BitNumber, Condition, TimeInterval);
}

void CSPELCom3::SpeedEx(short PointToPointSpeed, short JumpUpSpeed, short JumpDownSpeed)
{
	static BYTE parms[] =
		VTS_I2 VTS_I2 VTS_I2;
	InvokeHelper(0x6c, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 PointToPointSpeed, JumpUpSpeed, JumpDownSpeed);
}

void CSPELCom3::AccelEx(short PointToPointAccel, short PointToPointDecel, short JumpUpAccel, short JumpUpDecel, short JumpDownAccel, short JumpDownDecel)
{
	static BYTE parms[] =
		VTS_I2 VTS_I2 VTS_I2 VTS_I2 VTS_I2 VTS_I2;
	InvokeHelper(0x6d, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 PointToPointAccel, PointToPointDecel, JumpUpAccel, JumpUpDecel, JumpDownAccel, JumpDownDecel);
}

void CSPELCom3::Local(short LocalNumber, short LocalPoint1, short GlobalPoint1, short LocalPoint2, short GlobalPoint2)
{
	static BYTE parms[] =
		VTS_I2 VTS_I2 VTS_I2 VTS_I2 VTS_I2;
	InvokeHelper(0x6e, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 LocalNumber, LocalPoint1, GlobalPoint1, LocalPoint2, GlobalPoint2);
}

void CSPELCom3::LLocal(short LocalNumber, short LocalPoint1, short GlobalPoint1, short LocalPoint2, short GlobalPoint2)
{
	static BYTE parms[] =
		VTS_I2 VTS_I2 VTS_I2 VTS_I2 VTS_I2;
	InvokeHelper(0x6f, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 LocalNumber, LocalPoint1, GlobalPoint1, LocalPoint2, GlobalPoint2);
}

void CSPELCom3::RLocal(short LocalNumber, short LocalPoint1, short GlobalPoint1, short LocalPoint2, short GlobalPoint2)
{
	static BYTE parms[] =
		VTS_I2 VTS_I2 VTS_I2 VTS_I2 VTS_I2;
	InvokeHelper(0x70, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 LocalNumber, LocalPoint1, GlobalPoint1, LocalPoint2, GlobalPoint2);
}

void CSPELCom3::MCordr(short MCal1, short MCal2, short MCal3, short MCal4)
{
	static BYTE parms[] =
		VTS_I2 VTS_I2 VTS_I2 VTS_I2;
	InvokeHelper(0x71, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 MCal1, MCal2, MCal3, MCal4);
}

void CSPELCom3::Weight(float PayloadWeight, float ArmLength)
{
	static BYTE parms[] =
		VTS_R4 VTS_R4;
	InvokeHelper(0x72, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 PayloadWeight, ArmLength);
}

void CSPELCom3::XYLim(float XLowerLimit, float XUpperLimit, float YLowerLimit, float YUpperLimit)
{
	static BYTE parms[] =
		VTS_R4 VTS_R4 VTS_R4 VTS_R4;
	InvokeHelper(0x73, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 XLowerLimit, XUpperLimit, YLowerLimit, YUpperLimit);
}

float CSPELCom3::Agl(short JointNumber)
{
	float result;
	static BYTE parms[] =
		VTS_I2;
	InvokeHelper(0x74, DISPATCH_METHOD, VT_R4, (void*)&result, parms,
		JointNumber);
	return result;
}

long CSPELCom3::Call(LPCTSTR FunctionName)
{
	long result;
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x75, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		FunctionName);
	return result;
}

short CSPELCom3::ParseString(LPCTSTR InputString, const VARIANT& Tokens, LPCTSTR Delimiter)
{
	short result;
	static BYTE parms[] =
		VTS_BSTR VTS_VARIANT VTS_BSTR;
	InvokeHelper(0x76, DISPATCH_METHOD, VT_I2, (void*)&result, parms,
		InputString, &Tokens, Delimiter);
	return result;
}

BOOL CSPELCom3::MemSw(short BitNumber)
{
	BOOL result;
	static BYTE parms[] =
		VTS_I2;
	InvokeHelper(0x77, DISPATCH_METHOD, VT_BOOL, (void*)&result, parms,
		BitNumber);
	return result;
}

void CSPELCom3::VerInit()
{
	InvokeHelper(0x78, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

CString CSPELCom3::GetVersion()
{
	CString result;
	InvokeHelper(0x79, DISPATCH_METHOD, VT_BSTR, (void*)&result, NULL);
	return result;
}

void CSPELCom3::ResetAbort()
{
	InvokeHelper(0x7a, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CSPELCom3::VRun(LPCTSTR Sequence)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x7b, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 Sequence);
}

void CSPELCom3::VLoadModel(LPCTSTR Sequence, LPCTSTR Object, LPCTSTR FileName)
{
	static BYTE parms[] =
		VTS_BSTR VTS_BSTR VTS_BSTR;
	InvokeHelper(0x7c, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 Sequence, Object, FileName);
}

void CSPELCom3::VSaveModel(LPCTSTR Sequence, LPCTSTR Object, LPCTSTR FileName)
{
	static BYTE parms[] =
		VTS_BSTR VTS_BSTR VTS_BSTR;
	InvokeHelper(0x7d, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 Sequence, Object, FileName);
}

void CSPELCom3::VStatsShow(LPCTSTR Sequence)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x7e, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 Sequence);
}

void CSPELCom3::VStatsSave()
{
	InvokeHelper(0x7f, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CSPELCom3::VStatsResetAll()
{
	InvokeHelper(0x80, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CSPELCom3::VStatsReset(LPCTSTR Sequence)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x81, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 Sequence);
}

void CSPELCom3::SetSPELVar(LPCTSTR VarName, const VARIANT& Value)
{
	static BYTE parms[] =
		VTS_BSTR VTS_VARIANT;
	InvokeHelper(0x82, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 VarName, &Value);
}

VARIANT CSPELCom3::GetSPELVar(LPCTSTR VarName)
{
	VARIANT result;
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x83, DISPATCH_METHOD, VT_VARIANT, (void*)&result, parms,
		VarName);
	return result;
}

void CSPELCom3::SetSPELArray(LPCTSTR ArrayName, short Index, const VARIANT& Value)
{
	static BYTE parms[] =
		VTS_BSTR VTS_I2 VTS_VARIANT;
	InvokeHelper(0x84, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 ArrayName, Index, &Value);
}

VARIANT CSPELCom3::GetSPELArray(LPCTSTR ArrayName, short Index)
{
	VARIANT result;
	static BYTE parms[] =
		VTS_BSTR VTS_I2;
	InvokeHelper(0x85, DISPATCH_METHOD, VT_VARIANT, (void*)&result, parms,
		ArrayName, Index);
	return result;
}

void CSPELCom3::VGetCameraXYU(LPCTSTR Sequence, LPCTSTR Object, short ResultNumber, BOOL* Found, float* X, float* Y, float* U)
{
	static BYTE parms[] =
		VTS_BSTR VTS_BSTR VTS_I2 VTS_PBOOL VTS_PR4 VTS_PR4 VTS_PR4;
	InvokeHelper(0x86, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 Sequence, Object, ResultNumber, Found, X, Y, U);
}

void CSPELCom3::VGetExtrema(LPCTSTR Sequence, LPCTSTR Object, short ResultNumber, BOOL* Found, float* MinX, float* MaxX, float* MinY, float* MaxY)
{
	static BYTE parms[] =
		VTS_BSTR VTS_BSTR VTS_I2 VTS_PBOOL VTS_PR4 VTS_PR4 VTS_PR4 VTS_PR4;
	InvokeHelper(0x87, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 Sequence, Object, ResultNumber, Found, MinX, MaxX, MinY, MaxY);
}

void CSPELCom3::VGetModelWin(LPCTSTR Sequence, LPCTSTR Object, short* Left, short* Top, short* Width, short* Height)
{
	static BYTE parms[] =
		VTS_BSTR VTS_BSTR VTS_PI2 VTS_PI2 VTS_PI2 VTS_PI2;
	InvokeHelper(0x88, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 Sequence, Object, Left, Top, Width, Height);
}

void CSPELCom3::VGetRobotXYU(LPCTSTR Sequence, LPCTSTR Object, short ResultNumber, BOOL* Found, float* X, float* Y, float* U)
{
	static BYTE parms[] =
		VTS_BSTR VTS_BSTR VTS_I2 VTS_PBOOL VTS_PR4 VTS_PR4 VTS_PR4;
	InvokeHelper(0x89, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 Sequence, Object, ResultNumber, Found, X, Y, U);
}

void CSPELCom3::VGetSearchWin(LPCTSTR Sequence, LPCTSTR Object, short* Left, short* Top, short* Width, short* Height)
{
	static BYTE parms[] =
		VTS_BSTR VTS_BSTR VTS_PI2 VTS_PI2 VTS_PI2 VTS_PI2;
	InvokeHelper(0x8a, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 Sequence, Object, Left, Top, Width, Height);
}

void CSPELCom3::VSetModelWin(LPCTSTR Sequence, LPCTSTR Object, short Left, short Top, short Width, short Height)
{
	static BYTE parms[] =
		VTS_BSTR VTS_BSTR VTS_I2 VTS_I2 VTS_I2 VTS_I2;
	InvokeHelper(0x8b, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 Sequence, Object, Left, Top, Width, Height);
}

void CSPELCom3::VSetSearchWin(LPCTSTR Sequence, LPCTSTR Object, short Left, short Top, short Width, short Height)
{
	static BYTE parms[] =
		VTS_BSTR VTS_BSTR VTS_I2 VTS_I2 VTS_I2 VTS_I2;
	InvokeHelper(0x8c, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 Sequence, Object, Left, Top, Width, Height);
}

void CSPELCom3::VGetPixelXYU(LPCTSTR Sequence, LPCTSTR Object, short ResultNumber, BOOL* Found, float* X, float* Y, float* U)
{
	static BYTE parms[] =
		VTS_BSTR VTS_BSTR VTS_I2 VTS_PBOOL VTS_PR4 VTS_PR4 VTS_PR4;
	InvokeHelper(0x8d, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 Sequence, Object, ResultNumber, Found, X, Y, U);
}

void CSPELCom3::LoadSPELGroup(LPCTSTR GroupName)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x8e, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 GroupName);
}

void CSPELCom3::VGet(LPCTSTR Sequence, LPCTSTR Object, LPCTSTR Property_, VARIANT* Value)
{
	static BYTE parms[] =
		VTS_BSTR VTS_BSTR VTS_BSTR VTS_PVARIANT;
	InvokeHelper(0x8f, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 Sequence, Object, Property_, Value);
}

void CSPELCom3::VCls()
{
	InvokeHelper(0x90, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CSPELCom3::VGetPixelLine(LPCTSTR Sequence, LPCTSTR Object, float* X1, float* Y1, float* X2, float* Y2)
{
	static BYTE parms[] =
		VTS_BSTR VTS_BSTR VTS_PR4 VTS_PR4 VTS_PR4 VTS_PR4;
	InvokeHelper(0x91, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 Sequence, Object, X1, Y1, X2, Y2);
}

void CSPELCom3::VTeach(LPCTSTR Sequence, LPCTSTR Object)
{
	static BYTE parms[] =
		VTS_BSTR VTS_BSTR;
	InvokeHelper(0x92, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 Sequence, Object);
}

void CSPELCom3::VSet(LPCTSTR Sequence, LPCTSTR Object, LPCTSTR Property_, const VARIANT& Value)
{
	static BYTE parms[] =
		VTS_BSTR VTS_BSTR VTS_BSTR VTS_VARIANT;
	InvokeHelper(0x93, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 Sequence, Object, Property_, &Value);
}

void CSPELCom3::VSaveImage(LPCTSTR Sequence, LPCTSTR FileName)
{
	static BYTE parms[] =
		VTS_BSTR VTS_BSTR;
	InvokeHelper(0x94, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 Sequence, FileName);
}

void CSPELCom3::Here(const VARIANT& Point)
{
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0x95, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 &Point);
}

void CSPELCom3::JTran(short JointNumber, float Distance)
{
	static BYTE parms[] =
		VTS_I2 VTS_R4;
	InvokeHelper(0x96, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 JointNumber, Distance);
}

void CSPELCom3::PTran(short JointNumber, long Pulses)
{
	static BYTE parms[] =
		VTS_I2 VTS_I4;
	InvokeHelper(0x97, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 JointNumber, Pulses);
}

float CSPELCom3::PAgl(const VARIANT& Point, short JointNumber)
{
	float result;
	static BYTE parms[] =
		VTS_VARIANT VTS_I2;
	InvokeHelper(0x98, DISPATCH_METHOD, VT_R4, (void*)&result, parms,
		&Point, JointNumber);
	return result;
}

void CSPELCom3::VSaveProps()
{
	InvokeHelper(0x99, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CSPELCom3::EnableEvent(long EventNumber, BOOL Enabled)
{
	static BYTE parms[] =
		VTS_I4 VTS_BOOL;
	InvokeHelper(0x9a, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 EventNumber, Enabled);
}

void CSPELCom3::AssignPoint(short Destination, const VARIANT& Source)
{
	static BYTE parms[] =
		VTS_I2 VTS_VARIANT;
	InvokeHelper(0x9b, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 Destination, &Source);
}

void CSPELCom3::Go(const VARIANT& Destination)
{
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0x9c, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 &Destination);
}

void CSPELCom3::Jump(const VARIANT& Destination)
{
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0x9d, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 &Destination);
}

void CSPELCom3::Move(const VARIANT& Destination)
{
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0x9e, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 &Destination);
}

void CSPELCom3::Pallet(short PalletNumber, const VARIANT& Point1, const VARIANT& Point2, const VARIANT& Point3, const VARIANT& Point4, short Columns, short Rows)
{
	static BYTE parms[] =
		VTS_I2 VTS_VARIANT VTS_VARIANT VTS_VARIANT VTS_VARIANT VTS_I2 VTS_I2;
	InvokeHelper(0x9f, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 PalletNumber, &Point1, &Point2, &Point3, &Point4, Columns, Rows);
}

void CSPELCom3::Xqt(short TaskNumber, LPCTSTR Function, const VARIANT& NoPause)
{
	static BYTE parms[] =
		VTS_I2 VTS_BSTR VTS_VARIANT;
	InvokeHelper(0xa0, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 TaskNumber, Function, &NoPause);
}

short CSPELCom3::RobotType()
{
	short result;
	InvokeHelper(0xa1, DISPATCH_METHOD, VT_I2, (void*)&result, NULL);
	return result;
}

void CSPELCom3::GetIODef(long IOType, short BitNumber, BSTR* IOName, BSTR* Description)
{
	static BYTE parms[] =
		VTS_I4 VTS_I2 VTS_PBSTR VTS_PBSTR;
	InvokeHelper(0xa2, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 IOType, BitNumber, IOName, Description);
}

void CSPELCom3::SetIODef(long IOType, short BitNumber, LPCTSTR IOName, LPCTSTR Description)
{
	static BYTE parms[] =
		VTS_I4 VTS_I2 VTS_BSTR VTS_BSTR;
	InvokeHelper(0xa3, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 IOType, BitNumber, IOName, Description);
}

void CSPELCom3::LoadPoints(LPCTSTR PointFileName, const VARIANT& Merge)
{
	static BYTE parms[] =
		VTS_BSTR VTS_VARIANT;
	InvokeHelper(0xa4, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 PointFileName, &Merge);
}

void CSPELCom3::Arc(const VARIANT& MidPoint, const VARIANT& EndPoint)
{
	static BYTE parms[] =
		VTS_VARIANT VTS_VARIANT;
	InvokeHelper(0xa5, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 &MidPoint, &EndPoint);
}

void CSPELCom3::VCreateSequence(LPCTSTR SequenceName)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0xa6, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 SequenceName);
}

void CSPELCom3::VCreateObject(LPCTSTR Sequence, LPCTSTR ObjectName, long ObjectType)
{
	static BYTE parms[] =
		VTS_BSTR VTS_BSTR VTS_I4;
	InvokeHelper(0xa7, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 Sequence, ObjectName, ObjectType);
}

void CSPELCom3::VDeleteSequence(LPCTSTR Sequence)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0xa8, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 Sequence);
}

void CSPELCom3::VDeleteObject(LPCTSTR Sequence, LPCTSTR Object)
{
	static BYTE parms[] =
		VTS_BSTR VTS_BSTR;
	InvokeHelper(0xa9, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 Sequence, Object);
}

void CSPELCom3::Base(float XOrigin, float YOrigin, float ZOrigin, float Angle)
{
	static BYTE parms[] =
		VTS_R4 VTS_R4 VTS_R4 VTS_R4;
	InvokeHelper(0xaa, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 XOrigin, YOrigin, ZOrigin, Angle);
}

float CSPELCom3::ENetIO_AnaIn(long Channel)
{
	float result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xab, DISPATCH_METHOD, VT_R4, (void*)&result, parms,
		Channel);
	return result;
}

void CSPELCom3::ENetIO_AnaOut(long Channel, float Value)
{
	static BYTE parms[] =
		VTS_I4 VTS_R4;
	InvokeHelper(0xac, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 Channel, Value);
}

BOOL CSPELCom3::ENetIO_Sw(long BitNumber)
{
	BOOL result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xad, DISPATCH_METHOD, VT_BOOL, (void*)&result, parms,
		BitNumber);
	return result;
}

short CSPELCom3::ENetIO_In(long PortNumber)
{
	short result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xae, DISPATCH_METHOD, VT_I2, (void*)&result, parms,
		PortNumber);
	return result;
}

void CSPELCom3::ENetIO_Out(long PortNumber, long Value)
{
	static BYTE parms[] =
		VTS_I4 VTS_I4;
	InvokeHelper(0xaf, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 PortNumber, Value);
}

void CSPELCom3::ENetIO_AnaGetConfig(long Channel, float* Gain, float* Offset, float* LoScale, float* HiScale)
{
	static BYTE parms[] =
		VTS_I4 VTS_PR4 VTS_PR4 VTS_PR4 VTS_PR4;
	InvokeHelper(0xb0, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 Channel, Gain, Offset, LoScale, HiScale);
}

void CSPELCom3::ENetIO_AnaSetConfig(long Channel, float Gain, float Offset, float LoScale, float HiScale)
{
	static BYTE parms[] =
		VTS_I4 VTS_R4 VTS_R4 VTS_R4 VTS_R4;
	InvokeHelper(0xb1, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 Channel, Gain, Offset, LoScale, HiScale);
}

void CSPELCom3::ENetIO_ClearLatches(long BitNumber)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xb2, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 BitNumber);
}

BOOL CSPELCom3::ENetIO_SwLatch(long BitNumber, long LatchType)
{
	BOOL result;
	static BYTE parms[] =
		VTS_I4 VTS_I4;
	InvokeHelper(0xb3, DISPATCH_METHOD, VT_BOOL, (void*)&result, parms,
		BitNumber, LatchType);
	return result;
}

void CSPELCom3::Force_Calibrate()
{
	InvokeHelper(0xb4, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CSPELCom3::Force_ClearTrigger()
{
	InvokeHelper(0xb5, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

float CSPELCom3::Force_GetForce(long Axis)
{
	float result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xb6, DISPATCH_METHOD, VT_R4, (void*)&result, parms,
		Axis);
	return result;
}

void CSPELCom3::ENetIO_On(long BitNumber, const VARIANT& Seconds)
{
	static BYTE parms[] =
		VTS_I4 VTS_VARIANT;
	InvokeHelper(0xb7, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 BitNumber, &Seconds);
}

void CSPELCom3::ENetIO_Off(long BitNumber, const VARIANT& Seconds)
{
	static BYTE parms[] =
		VTS_I4 VTS_VARIANT;
	InvokeHelper(0xb8, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 BitNumber, &Seconds);
}

void CSPELCom3::Force_GetForces(const VARIANT& Axes)
{
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0xb9, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 &Axes);
}

void CSPELCom3::Force_SetTrigger(long Axis, float Threshold, long CompareType)
{
	static BYTE parms[] =
		VTS_I4 VTS_R4 VTS_I4;
	InvokeHelper(0xba, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 Axis, Threshold, CompareType);
}

void CSPELCom3::Force_TCLim(short J1TorqueLimit, short J2TorqueLimit, short J3TorqueLimit, short J4TorqueLimit)
{
	static BYTE parms[] =
		VTS_I2 VTS_I2 VTS_I2 VTS_I2;
	InvokeHelper(0xbb, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 J1TorqueLimit, J2TorqueLimit, J3TorqueLimit, J4TorqueLimit);
}

void CSPELCom3::Force_TCSpeed(short Speed)
{
	static BYTE parms[] =
		VTS_I2;
	InvokeHelper(0xbc, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 Speed);
}

BOOL CSPELCom3::ENetIO_Oport(long BitNumber)
{
	BOOL result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xbd, DISPATCH_METHOD, VT_BOOL, (void*)&result, parms,
		BitNumber);
	return result;
}

void CSPELCom3::LogIn(LPCTSTR LogID, LPCTSTR Password)
{
	static BYTE parms[] =
		VTS_BSTR VTS_BSTR;
	InvokeHelper(0xbe, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 LogID, Password);
}

CString CSPELCom3::GetCurrentUser()
{
	CString result;
	InvokeHelper(0xbf, DISPATCH_METHOD, VT_BSTR, (void*)&result, NULL);
	return result;
}

void CSPELCom3::VShowSequence(LPCTSTR Sequence)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0xc0, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 Sequence);
}

void CSPELCom3::VShowModel(LPCTSTR Sequence, LPCTSTR Object)
{
	static BYTE parms[] =
		VTS_BSTR VTS_BSTR;
	InvokeHelper(0xc1, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 Sequence, Object);
}

BOOL CSPELCom3::VTrain(LPCTSTR Sequence, LPCTSTR Object, const VARIANT& Flags)
{
	BOOL result;
	static BYTE parms[] =
		VTS_BSTR VTS_BSTR VTS_VARIANT;
	InvokeHelper(0xc2, DISPATCH_METHOD, VT_BOOL, (void*)&result, parms,
		Sequence, Object, &Flags);
	return result;
}

void CSPELCom3::RestartSPEL()
{
	InvokeHelper(0xc4, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CSPELCom3::Shutdown(long Mode)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xc5, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 Mode);
}

void CSPELCom3::RebuildProject()
{
	InvokeHelper(0xc6, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CSPELCom3::Curve(LPCTSTR FileName, BOOL Closure, long Mode, long NumOfAxes, LPCTSTR PointList)
{
	static BYTE parms[] =
		VTS_BSTR VTS_BOOL VTS_I4 VTS_I4 VTS_BSTR;
	InvokeHelper(0xc7, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 FileName, Closure, Mode, NumOfAxes, PointList);
}

void CSPELCom3::CVMove(LPCTSTR FileName, const VARIANT& OptionList)
{
	static BYTE parms[] =
		VTS_BSTR VTS_VARIANT;
	InvokeHelper(0xc8, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 FileName, &OptionList);
}

BOOL CSPELCom3::TillOn()
{
	BOOL result;
	InvokeHelper(0xc9, DISPATCH_METHOD, VT_BOOL, (void*)&result, NULL);
	return result;
}
