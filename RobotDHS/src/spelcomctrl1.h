#pragma once

// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// CSpelcomctrl1 wrapper class

class CSpelcomctrl1 : public CWnd
{
protected:
	DECLARE_DYNCREATE(CSpelcomctrl1)
public:
	CLSID const& GetClsid()
	{
		static CLSID const clsid
			= { 0x45CAC9AC, 0x2FAA, 0x4FA2, { 0x9F, 0xA3, 0x35, 0xFE, 0xA2, 0xA4, 0x70, 0xDF } };
		return clsid;
	}
	virtual BOOL Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle,
						const RECT& rect, CWnd* pParentWnd, UINT nID, 
						CCreateContext* pContext = NULL)
	{ 
		return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); 
	}

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, 
				UINT nID, CFile* pPersist = NULL, BOOL bStorage = FALSE,
				BSTR bstrLicKey = NULL)
	{ 
		return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
		pPersist, bStorage, bstrLicKey); 
	}

// Attributes
public:
enum
{
    scomIOTypeInput = 1,
    scomIOTypeOutput = 2,
    scomIOTypeMemory = 3,
    scomIOTypeEnetIO = 4,
    scomIOTypeFbusIO = 5
}SPELComIOTypes;
enum
{
    scomFSForceX = 1,
    scomFSForceY = 2,
    scomFSForceZ = 3,
    scomFSTorqueX = 4,
    scomFSTorqueY = 5,
    scomFSTorqueZ = 6
}SPELComForceAxes;
enum
{
    scomFSLessOrEqual = 0,
    scomFSGreaterOrEqual = 1
}SPELComForceCompare;
enum
{
    scomCorrelation = 1,
    scomBlob = 2,
    scomEdge = 3,
    scomPolar = 4,
    scomLine = 5,
    scomPoint = 6,
    scomFrame = 7,
    scomImageOp = 8,
    scomOcr = 9,
    scomCodeReader = 10,
    scomGeometric = 11
}SPELComVisionObjectTypes;
enum
{
    scomDlgJog = 100,
    scomDlgMonitor = 101,
    scomDlgIOMonitor = 102,
    scomDlgMemIOMonitor = 103,
    scomDlgRobotControlPanel = 104,
    scomDlgMaintenance = 105,
    scomDlgRobotParms = 106,
    scomDlgRobotConfig = 107,
    scomDlgTaskManager = 109,
    scomDlgVisionGuide = 110
}SPELComDialogs;
enum
{
    scomEventPause = 1,
    scomEventSafeGuardOpen = 2,
    scomEventSafeGuardClose = 3,
    scomEventBuildStatus = 4,
    scomEventError = 5,
    scomEventPrint = 6,
    scomEventEStopOn = 7,
    scomEventEStopOff = 8,
    scomEventCont = 9,
    scomEventMotorOn = 10,
    scomEventMotorOff = 11,
    scomEventPowerHigh = 12,
    scomEventPowerLow = 13,
    scomEventTeachMode = 14,
    scomEventAutoMode = 15,
    scomEventTaskStatus = 16,
    scomEventShutdown = 17
}SPELComEvents;
enum
{
    scomErrTimeout = 28000,
    scomErrPortNotOpen = 28001,
    scomErrServerNotAvail = 28002,
    scomErrNoCommand = 28003,
    scomErrCmdInCycle = 28004,
    scomErrBuildIncomplete = 28005,
    scomErrVarNoExist = 28006,
    scomErrInvalidPointLabel = 28007,
    scomErrVisionNotAvailable = 28008,
    scomErrNoProject = 28009,
    scomErrCantOpenPort = 28010,
    scomErrUserAbort = 28011,
    scomErrInvalidArg = 28012,
    scomErrTasksRunning = 28013,
    scomErrInvalidAction = 28014,
    scomErrGroupNotLoaded = 28015,
    scomErrProjectBuild = 28016,
    scomErrProjectNotExist = 28017,
    scomErrEventInCycle = 28018,
    scomErrInvalidCmdInAuto = 28020,
    scomErrDialogAlreadyOpen = 28021,
    scomErrInvalidTaskNumber = 28022,
    scomErrFuncNotFound = 28023,
    scomErrEPSONRCNotFound = 28024,
    scomErrBadVideoScale = 28025,
    scomErrNotSupportedInEPSONRC = 28026,
    scomErrOptionNotEnabled = 28027,
    scomErrCannotStartTask = 28028,
    scomErrGroupsNotEnabled = 28029,
    scomErrAbortInCycle = 28030,
    scomErrRobotNotSpecified = 28031
}SPELComErrors;
enum
{
    scomActionExecWait = 1,
    scomActionExecNoWait = 2,
    scomActionPause = 3,
    scomActionCont = 4,
    scomActionAbort = 5,
    scomActionJog = 100,
    scomActionMonitor = 101,
    scomActionIOMon = 102,
    scomActionMemIOMon = 103,
    scomActionControlPanel = 104,
    scomActionMaintenance = 105,
    scomActionRobotParms = 106,
    scomActionRobotConfig = 107,
    scomActionVStatsShow = 108,
    scomActionVStatsReset = 109,
    scomActionVStatsResetAll = 110,
    scomActionVStatsSave = 111
}SPELComActions;


// Operations
public:

// _DSPELCom4

// Functions
//

void Abort()
{
	InvokeHelper(0x11, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
void Accel(short PointToPointAccel, short PointToPointDecel)
{
	static BYTE parms[] = VTS_I2 VTS_I2 ;
	InvokeHelper(0x12, DISPATCH_METHOD, VT_EMPTY, NULL, parms, PointToPointAccel, PointToPointDecel);
}
void AccelS(short Accel, VARIANT Decel)
{
	static BYTE parms[] = VTS_I2 VTS_VARIANT ;
	InvokeHelper(0x13, DISPATCH_METHOD, VT_EMPTY, NULL, parms, Accel, &Decel);
}
void Arch(short ArchNumber, float VerticalRise, float VerticalLower)
{
	static BYTE parms[] = VTS_I2 VTS_R4 VTS_R4 ;
	InvokeHelper(0x14, DISPATCH_METHOD, VT_EMPTY, NULL, parms, ArchNumber, VerticalRise, VerticalLower);
}
void ArmSet(short ArmNumber, float Param1, float Param2, float Param3, float Param4, float Param5)
{
	static BYTE parms[] = VTS_I2 VTS_R4 VTS_R4 VTS_R4 VTS_R4 VTS_R4 ;
	InvokeHelper(0x15, DISPATCH_METHOD, VT_EMPTY, NULL, parms, ArmNumber, Param1, Param2, Param3, Param4, Param5);
}
double Atan(double Number)
{
	double result;
	static BYTE parms[] = VTS_R8 ;
	InvokeHelper(0x16, DISPATCH_METHOD, VT_R8, (void*)&result, parms, Number);
	return result;
}
double Atan2(double Dx, double Dy)
{
	double result;
	static BYTE parms[] = VTS_R8 VTS_R8 ;
	InvokeHelper(0x17, DISPATCH_METHOD, VT_R8, (void*)&result, parms, Dx, Dy);
	return result;
}
void BuildProject()
{
	InvokeHelper(0x18, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
void Clear()
{
	InvokeHelper(0x19, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
void Cont()
{
	InvokeHelper(0x1a, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
float CX(VARIANT Point)
{
	float result;
	static BYTE parms[] = VTS_VARIANT ;
	InvokeHelper(0x1b, DISPATCH_METHOD, VT_R4, (void*)&result, parms, &Point);
	return result;
}
float CY(VARIANT Point)
{
	float result;
	static BYTE parms[] = VTS_VARIANT ;
	InvokeHelper(0x1c, DISPATCH_METHOD, VT_R4, (void*)&result, parms, &Point);
	return result;
}
float CZ(VARIANT Point)
{
	float result;
	static BYTE parms[] = VTS_VARIANT ;
	InvokeHelper(0x1d, DISPATCH_METHOD, VT_R4, (void*)&result, parms, &Point);
	return result;
}
short Ctr(short BitNumber)
{
	short result;
	static BYTE parms[] = VTS_I2 ;
	InvokeHelper(0x1e, DISPATCH_METHOD, VT_I2, (void*)&result, parms, BitNumber);
	return result;
}
void CtReset(short BitNumber)
{
	static BYTE parms[] = VTS_I2 ;
	InvokeHelper(0x1f, DISPATCH_METHOD, VT_EMPTY, NULL, parms, BitNumber);
}
float CU(VARIANT Point)
{
	float result;
	static BYTE parms[] = VTS_VARIANT ;
	InvokeHelper(0x20, DISPATCH_METHOD, VT_R4, (void*)&result, parms, &Point);
	return result;
}
void Delay(long ms)
{
	static BYTE parms[] = VTS_I4 ;
	InvokeHelper(0x21, DISPATCH_METHOD, VT_EMPTY, NULL, parms, ms);
}
double DegToRad(double Degrees)
{
	double result;
	static BYTE parms[] = VTS_R8 ;
	InvokeHelper(0x22, DISPATCH_METHOD, VT_R8, (void*)&result, parms, Degrees);
	return result;
}
void ExecSPELCmd(LPCTSTR Command)
{
	static BYTE parms[] = VTS_BSTR ;
	InvokeHelper(0x23, DISPATCH_METHOD, VT_EMPTY, NULL, parms, Command);
}
void Fine(long J1Pulses, long J2Pulses, long J3Pulses, long J4Pulses, VARIANT J5Pulses, VARIANT J6Pulses)
{
	static BYTE parms[] = VTS_I4 VTS_I4 VTS_I4 VTS_I4 VTS_VARIANT VTS_VARIANT ;
	InvokeHelper(0x24, DISPATCH_METHOD, VT_EMPTY, NULL, parms, J1Pulses, J2Pulses, J3Pulses, J4Pulses, &J5Pulses, &J6Pulses);
}
BOOL GetBitValue(long InputData, short BitNumber)
{
	BOOL result;
	static BYTE parms[] = VTS_I4 VTS_I2 ;
	InvokeHelper(0x25, DISPATCH_METHOD, VT_BOOL, (void*)&result, parms, InputData, BitNumber);
	return result;
}
void Halt(short TaskNumber)
{
	static BYTE parms[] = VTS_I2 ;
	InvokeHelper(0x26, DISPATCH_METHOD, VT_EMPTY, NULL, parms, TaskNumber);
}
void HomeSet(long J1Pulses, long J2Pulses, long J3Pulses, long J4Pulses, VARIANT J5Pulses, VARIANT J6Pulses)
{
	static BYTE parms[] = VTS_I4 VTS_I4 VTS_I4 VTS_I4 VTS_VARIANT VTS_VARIANT ;
	InvokeHelper(0x27, DISPATCH_METHOD, VT_EMPTY, NULL, parms, J1Pulses, J2Pulses, J3Pulses, J4Pulses, &J5Pulses, &J6Pulses);
}
void Home()
{
	InvokeHelper(0x28, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
void Hordr(short Home1, short Home2, short Home3, short Home4, VARIANT Home5, VARIANT Home6)
{
	static BYTE parms[] = VTS_I2 VTS_I2 VTS_I2 VTS_I2 VTS_VARIANT VTS_VARIANT ;
	InvokeHelper(0x29, DISPATCH_METHOD, VT_EMPTY, NULL, parms, Home1, Home2, Home3, Home4, &Home5, &Home6);
}
void Out(short PortNumber, short PortValue)
{
	static BYTE parms[] = VTS_I2 VTS_I2 ;
	InvokeHelper(0x2a, DISPATCH_METHOD, VT_EMPTY, NULL, parms, PortNumber, PortValue);
}
void OpBCD(short PortNumber, short PortValue)
{
	static BYTE parms[] = VTS_I2 VTS_I2 ;
	InvokeHelper(0x2b, DISPATCH_METHOD, VT_EMPTY, NULL, parms, PortNumber, PortValue);
}
void JRange(short JointNumber, long MinPulses, long MaxPulses)
{
	static BYTE parms[] = VTS_I2 VTS_I4 VTS_I4 ;
	InvokeHelper(0x2c, DISPATCH_METHOD, VT_EMPTY, NULL, parms, JointNumber, MinPulses, MaxPulses);
}
void MCal()
{
	InvokeHelper(0x2d, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
void Palet(short PaletNumber, VARIANT Point1, VARIANT Point2, VARIANT Point3, VARIANT Point4, short Columns, short Rows)
{
	static BYTE parms[] = VTS_I2 VTS_VARIANT VTS_VARIANT VTS_VARIANT VTS_VARIANT VTS_I2 VTS_I2 ;
	InvokeHelper(0x2e, DISPATCH_METHOD, VT_EMPTY, NULL, parms, PaletNumber, &Point1, &Point2, &Point3, &Point4, Columns, Rows);
}
short In(short PortNumber)
{
	short result;
	static BYTE parms[] = VTS_I2 ;
	InvokeHelper(0x2f, DISPATCH_METHOD, VT_I2, (void*)&result, parms, PortNumber);
	return result;
}
long Hour()
{
	long result;
	InvokeHelper(0x30, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}
short InBCD(short PortNumber)
{
	short result;
	static BYTE parms[] = VTS_I2 ;
	InvokeHelper(0x31, DISPATCH_METHOD, VT_I2, (void*)&result, parms, PortNumber);
	return result;
}
BOOL Sw(short BitNumber)
{
	BOOL result;
	static BYTE parms[] = VTS_I2 ;
	InvokeHelper(0x32, DISPATCH_METHOD, VT_BOOL, (void*)&result, parms, BitNumber);
	return result;
}
BOOL Oport(short BitNumber)
{
	BOOL result;
	static BYTE parms[] = VTS_I2 ;
	InvokeHelper(0x33, DISPATCH_METHOD, VT_BOOL, (void*)&result, parms, BitNumber);
	return result;
}
BOOL AtHome()
{
	BOOL result;
	InvokeHelper(0x34, DISPATCH_METHOD, VT_BOOL, (void*)&result, NULL);
	return result;
}
BOOL AxisLocked(short AxisNumber)
{
	BOOL result;
	static BYTE parms[] = VTS_I2 ;
	InvokeHelper(0x35, DISPATCH_METHOD, VT_BOOL, (void*)&result, parms, AxisNumber);
	return result;
}
BOOL CommandInCycle()
{
	BOOL result;
	InvokeHelper(0x36, DISPATCH_METHOD, VT_BOOL, (void*)&result, NULL);
	return result;
}
void GetPoint(VARIANT Point, float * X, float * Y, float * Z, float * U, short * Local, short * Hand)
{
	static BYTE parms[] = VTS_VARIANT VTS_PR4 VTS_PR4 VTS_PR4 VTS_PR4 VTS_PI2 VTS_PI2 ;
	InvokeHelper(0x37, DISPATCH_METHOD, VT_EMPTY, NULL, parms, &Point, X, Y, Z, U, Local, Hand);
}
BOOL JS()
{
	BOOL result;
	InvokeHelper(0x38, DISPATCH_METHOD, VT_BOOL, (void*)&result, NULL);
	return result;
}
BOOL MoveTill()
{
	BOOL result;
	InvokeHelper(0x39, DISPATCH_METHOD, VT_BOOL, (void*)&result, NULL);
	return result;
}
long Stat(short Address)
{
	long result;
	static BYTE parms[] = VTS_I2 ;
	InvokeHelper(0x3a, DISPATCH_METHOD, VT_I4, (void*)&result, parms, Address);
	return result;
}
BOOL EnableOn()
{
	BOOL result;
	InvokeHelper(0x3b, DISPATCH_METHOD, VT_BOOL, (void*)&result, NULL);
	return result;
}
BOOL ErrorOn()
{
	BOOL result;
	InvokeHelper(0x3c, DISPATCH_METHOD, VT_BOOL, (void*)&result, NULL);
	return result;
}
BOOL EstopOn()
{
	BOOL result;
	InvokeHelper(0x3d, DISPATCH_METHOD, VT_BOOL, (void*)&result, NULL);
	return result;
}
BOOL MCalComplete()
{
	BOOL result;
	InvokeHelper(0x3e, DISPATCH_METHOD, VT_BOOL, (void*)&result, NULL);
	return result;
}
double RadToDeg(double Radians)
{
	double result;
	static BYTE parms[] = VTS_R8 ;
	InvokeHelper(0x3f, DISPATCH_METHOD, VT_R8, (void*)&result, parms, Radians);
	return result;
}
void Pause()
{
	InvokeHelper(0x40, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
BOOL PauseOn()
{
	BOOL result;
	InvokeHelper(0x41, DISPATCH_METHOD, VT_BOOL, (void*)&result, NULL);
	return result;
}
void PDel(short FirstPointNumber, short LastPointNumber)
{
	static BYTE parms[] = VTS_I2 VTS_I2 ;
	InvokeHelper(0x42, DISPATCH_METHOD, VT_EMPTY, NULL, parms, FirstPointNumber, LastPointNumber);
}
long Pls(short AxisNumber)
{
	long result;
	static BYTE parms[] = VTS_I2 ;
	InvokeHelper(0x43, DISPATCH_METHOD, VT_I4, (void*)&result, parms, AxisNumber);
	return result;
}
void PrgRst()
{
	InvokeHelper(0x44, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
BOOL ProjectBuildComplete()
{
	BOOL result;
	InvokeHelper(0x45, DISPATCH_METHOD, VT_BOOL, (void*)&result, NULL);
	return result;
}
void Pulse(long J1Pulses, long J2Pulses, long J3Pulses, long J4Pulses, VARIANT J5Pulses, VARIANT J6Pulses)
{
	static BYTE parms[] = VTS_I4 VTS_I4 VTS_I4 VTS_I4 VTS_VARIANT VTS_VARIANT ;
	InvokeHelper(0x46, DISPATCH_METHOD, VT_EMPTY, NULL, parms, J1Pulses, J2Pulses, J3Pulses, J4Pulses, &J5Pulses, &J6Pulses);
}
void Quit(short TaskNumber)
{
	static BYTE parms[] = VTS_I2 ;
	InvokeHelper(0x47, DISPATCH_METHOD, VT_EMPTY, NULL, parms, TaskNumber);
}
void Range(long J1MinPulses, long J1MaxPulses, long J2MinPulses, long J2MaxPulses, long J3MinPulses, long J3MaxPulses, long J4MinPulses, long J4MaxPulses, VARIANT J5MinPulses, VARIANT J5MaxPulses, VARIANT J6MinPulses, VARIANT J6MaxPulses)
{
	static BYTE parms[] = VTS_I4 VTS_I4 VTS_I4 VTS_I4 VTS_I4 VTS_I4 VTS_I4 VTS_I4 VTS_VARIANT VTS_VARIANT VTS_VARIANT VTS_VARIANT ;
	InvokeHelper(0x48, DISPATCH_METHOD, VT_EMPTY, NULL, parms, J1MinPulses, J1MaxPulses, J2MinPulses, J2MaxPulses, J3MinPulses, J3MaxPulses, J4MinPulses, J4MaxPulses, &J5MinPulses, &J5MaxPulses, &J6MinPulses, &J6MaxPulses);
}
CString Reply()
{
	CString result;
	InvokeHelper(0x49, DISPATCH_METHOD, VT_BSTR, (void*)&result, NULL);
	return result;
}
void Reset()
{
	InvokeHelper(0x4a, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
void Resume(short TaskNumber)
{
	static BYTE parms[] = VTS_I2 ;
	InvokeHelper(0x4b, DISPATCH_METHOD, VT_EMPTY, NULL, parms, TaskNumber);
}
CString RobotModel()
{
	CString result;
	InvokeHelper(0x4c, DISPATCH_METHOD, VT_BSTR, (void*)&result, NULL);
	return result;
}
void RunDialog(long DialogID)
{
	static BYTE parms[] = VTS_I4 ;
	InvokeHelper(0x4d, DISPATCH_METHOD, VT_EMPTY, NULL, parms, DialogID);
}
BOOL SafetyOn()
{
	BOOL result;
	InvokeHelper(0x4e, DISPATCH_METHOD, VT_BOOL, (void*)&result, NULL);
	return result;
}
void SavePoints(LPCTSTR PointFileName)
{
	static BYTE parms[] = VTS_BSTR ;
	InvokeHelper(0x4f, DISPATCH_METHOD, VT_EMPTY, NULL, parms, PointFileName);
}
void SetPoint(VARIANT Point, float X, float Y, float Z, float U, short Local, short Hand)
{
	static BYTE parms[] = VTS_VARIANT VTS_R4 VTS_R4 VTS_R4 VTS_R4 VTS_I2 VTS_I2 ;
	InvokeHelper(0x50, DISPATCH_METHOD, VT_EMPTY, NULL, parms, &Point, X, Y, Z, U, Local, Hand);
}
void Arm(short ArmNumber)
{
	static BYTE parms[] = VTS_I2 ;
	InvokeHelper(0x51, DISPATCH_METHOD, VT_EMPTY, NULL, parms, ArmNumber);
}
short GetArm()
{
	short result;
	InvokeHelper(0x52, DISPATCH_METHOD, VT_I2, (void*)&result, NULL);
	return result;
}
void LimZ(float ZLimit)
{
	static BYTE parms[] = VTS_R4 ;
	InvokeHelper(0x53, DISPATCH_METHOD, VT_EMPTY, NULL, parms, ZLimit);
}
float GetLimZ()
{
	float result;
	InvokeHelper(0x54, DISPATCH_METHOD, VT_R4, (void*)&result, NULL);
	return result;
}
void Tool(short ToolNumber)
{
	static BYTE parms[] = VTS_I2 ;
	InvokeHelper(0x55, DISPATCH_METHOD, VT_EMPTY, NULL, parms, ToolNumber);
}
short GetTool()
{
	short result;
	InvokeHelper(0x56, DISPATCH_METHOD, VT_I2, (void*)&result, NULL);
	return result;
}
void TGo(VARIANT Destination)
{
	static BYTE parms[] = VTS_VARIANT ;
	InvokeHelper(0x57, DISPATCH_METHOD, VT_EMPTY, NULL, parms, &Destination);
}
void TLSet(short ToolNumber, float XCoord, float YCoord, float ZCoord, float UCoord, VARIANT VCoord, VARIANT WCoord)
{
	static BYTE parms[] = VTS_I2 VTS_R4 VTS_R4 VTS_R4 VTS_R4 VTS_VARIANT VTS_VARIANT ;
	InvokeHelper(0x58, DISPATCH_METHOD, VT_EMPTY, NULL, parms, ToolNumber, XCoord, YCoord, ZCoord, UCoord, &VCoord, &WCoord);
}
void TMove(VARIANT Destination)
{
	static BYTE parms[] = VTS_VARIANT ;
	InvokeHelper(0x59, DISPATCH_METHOD, VT_EMPTY, NULL, parms, &Destination);
}
BOOL TrapStop()
{
	BOOL result;
	InvokeHelper(0x5a, DISPATCH_METHOD, VT_BOOL, (void*)&result, NULL);
	return result;
}
BOOL TW()
{
	BOOL result;
	InvokeHelper(0x5b, DISPATCH_METHOD, VT_BOOL, (void*)&result, NULL);
	return result;
}
BOOL VCal(LPCTSTR CalibName)
{
	BOOL result;
	static BYTE parms[] = VTS_BSTR ;
	InvokeHelper(0x5c, DISPATCH_METHOD, VT_BOOL, (void*)&result, parms, CalibName);
	return result;
}
BOOL VCalPoints(LPCTSTR CalibName)
{
	BOOL result;
	static BYTE parms[] = VTS_BSTR ;
	InvokeHelper(0x5d, DISPATCH_METHOD, VT_BOOL, (void*)&result, parms, CalibName);
	return result;
}
void On(short BitNumber, VARIANT Seconds, VARIANT Parallel)
{
	static BYTE parms[] = VTS_I2 VTS_VARIANT VTS_VARIANT ;
	InvokeHelper(0x5e, DISPATCH_METHOD, VT_EMPTY, NULL, parms, BitNumber, &Seconds, &Parallel);
}
void Off(short BitNumber, VARIANT Seconds, VARIANT Parallel)
{
	static BYTE parms[] = VTS_I2 VTS_VARIANT VTS_VARIANT ;
	InvokeHelper(0x5f, DISPATCH_METHOD, VT_EMPTY, NULL, parms, BitNumber, &Seconds, &Parallel);
}
void Speed(short PointToPointSpeed)
{
	static BYTE parms[] = VTS_I2 ;
	InvokeHelper(0x60, DISPATCH_METHOD, VT_EMPTY, NULL, parms, PointToPointSpeed);
}
void SpeedS(float Speed, VARIANT DepartSpeed, VARIANT ApproSpeed)
{
	static BYTE parms[] = VTS_R4 VTS_VARIANT VTS_VARIANT ;
	InvokeHelper(0x61, DISPATCH_METHOD, VT_EMPTY, NULL, parms, Speed, &DepartSpeed, &ApproSpeed);
}
BOOL TaskStatus(short TaskNumber)
{
	BOOL result;
	static BYTE parms[] = VTS_I2 ;
	InvokeHelper(0x62, DISPATCH_METHOD, VT_BOOL, (void*)&result, parms, TaskNumber);
	return result;
}
BOOL TasksExecuting()
{
	BOOL result;
	InvokeHelper(0x63, DISPATCH_METHOD, VT_BOOL, (void*)&result, NULL);
	return result;
}
void SFree(VARIANT AxisNumber1, VARIANT AxisNumber2, VARIANT AxisNumber3, VARIANT AxisNumber4, VARIANT AxisNumber5, VARIANT AxisNumber6)
{
	static BYTE parms[] = VTS_VARIANT VTS_VARIANT VTS_VARIANT VTS_VARIANT VTS_VARIANT VTS_VARIANT ;
	InvokeHelper(0x64, DISPATCH_METHOD, VT_EMPTY, NULL, parms, &AxisNumber1, &AxisNumber2, &AxisNumber3, &AxisNumber4, &AxisNumber5, &AxisNumber6);
}
void SLock(VARIANT AxisNumber1, VARIANT AxisNumber2, VARIANT AxisNumber3, VARIANT AxisNumber4, VARIANT AxisNumber5, VARIANT AxisNumber6)
{
	static BYTE parms[] = VTS_VARIANT VTS_VARIANT VTS_VARIANT VTS_VARIANT VTS_VARIANT VTS_VARIANT ;
	InvokeHelper(0x65, DISPATCH_METHOD, VT_EMPTY, NULL, parms, &AxisNumber1, &AxisNumber2, &AxisNumber3, &AxisNumber4, &AxisNumber5, &AxisNumber6);
}
short MemIn(short PortNumber)
{
	short result;
	static BYTE parms[] = VTS_I2 ;
	InvokeHelper(0x66, DISPATCH_METHOD, VT_I2, (void*)&result, parms, PortNumber);
	return result;
}
void MemOut(short PortNumber, short PortValue)
{
	static BYTE parms[] = VTS_I2 VTS_I2 ;
	InvokeHelper(0x67, DISPATCH_METHOD, VT_EMPTY, NULL, parms, PortNumber, PortValue);
}
void MemOn(short BitNumber)
{
	static BYTE parms[] = VTS_I2 ;
	InvokeHelper(0x68, DISPATCH_METHOD, VT_EMPTY, NULL, parms, BitNumber);
}
void MemOff(short BitNumber)
{
	static BYTE parms[] = VTS_I2 ;
	InvokeHelper(0x69, DISPATCH_METHOD, VT_EMPTY, NULL, parms, BitNumber);
}
void WaitSw(short BitNumber, long Condition, float TimeInterval)
{
	static BYTE parms[] = VTS_I2 VTS_I4 VTS_R4 ;
	InvokeHelper(0x6a, DISPATCH_METHOD, VT_EMPTY, NULL, parms, BitNumber, Condition, TimeInterval);
}
void WaitMem(short BitNumber, long Condition, float TimeInterval)
{
	static BYTE parms[] = VTS_I2 VTS_I4 VTS_R4 ;
	InvokeHelper(0x6b, DISPATCH_METHOD, VT_EMPTY, NULL, parms, BitNumber, Condition, TimeInterval);
}
void SpeedEx(short PointToPointSpeed, short JumpUpSpeed, short JumpDownSpeed)
{
	static BYTE parms[] = VTS_I2 VTS_I2 VTS_I2 ;
	InvokeHelper(0x6c, DISPATCH_METHOD, VT_EMPTY, NULL, parms, PointToPointSpeed, JumpUpSpeed, JumpDownSpeed);
}
void AccelEx(short PointToPointAccel, short PointToPointDecel, short JumpDepartAccel, short JumpDepartDecel, short JumpApproAccel, short JumpApproDecel)
{
	static BYTE parms[] = VTS_I2 VTS_I2 VTS_I2 VTS_I2 VTS_I2 VTS_I2 ;
	InvokeHelper(0x6d, DISPATCH_METHOD, VT_EMPTY, NULL, parms, PointToPointAccel, PointToPointDecel, JumpDepartAccel, JumpDepartDecel, JumpApproAccel, JumpApproDecel);
}
void Local(short LocalNumber, short LocalPoint1, short GlobalPoint1, short LocalPoint2, short GlobalPoint2)
{
	static BYTE parms[] = VTS_I2 VTS_I2 VTS_I2 VTS_I2 VTS_I2 ;
	InvokeHelper(0x6e, DISPATCH_METHOD, VT_EMPTY, NULL, parms, LocalNumber, LocalPoint1, GlobalPoint1, LocalPoint2, GlobalPoint2);
}
void LLocal(short LocalNumber, short LocalPoint1, short GlobalPoint1, short LocalPoint2, short GlobalPoint2)
{
	static BYTE parms[] = VTS_I2 VTS_I2 VTS_I2 VTS_I2 VTS_I2 ;
	InvokeHelper(0x6f, DISPATCH_METHOD, VT_EMPTY, NULL, parms, LocalNumber, LocalPoint1, GlobalPoint1, LocalPoint2, GlobalPoint2);
}
void RLocal(short LocalNumber, short LocalPoint1, short GlobalPoint1, short LocalPoint2, short GlobalPoint2)
{
	static BYTE parms[] = VTS_I2 VTS_I2 VTS_I2 VTS_I2 VTS_I2 ;
	InvokeHelper(0x70, DISPATCH_METHOD, VT_EMPTY, NULL, parms, LocalNumber, LocalPoint1, GlobalPoint1, LocalPoint2, GlobalPoint2);
}
void MCordr(short MCal1, short MCal2, short MCal3, short MCal4)
{
	static BYTE parms[] = VTS_I2 VTS_I2 VTS_I2 VTS_I2 ;
	InvokeHelper(0x71, DISPATCH_METHOD, VT_EMPTY, NULL, parms, MCal1, MCal2, MCal3, MCal4);
}
void Weight(float PayloadWeight, float ArmLength)
{
	static BYTE parms[] = VTS_R4 VTS_R4 ;
	InvokeHelper(0x72, DISPATCH_METHOD, VT_EMPTY, NULL, parms, PayloadWeight, ArmLength);
}
void XYLim(float XLowerLimit, float XUpperLimit, float YLowerLimit, float YUpperLimit, VARIANT ZLowerLimit, VARIANT ZUpperLimit)
{
	static BYTE parms[] = VTS_R4 VTS_R4 VTS_R4 VTS_R4 VTS_VARIANT VTS_VARIANT ;
	InvokeHelper(0x73, DISPATCH_METHOD, VT_EMPTY, NULL, parms, XLowerLimit, XUpperLimit, YLowerLimit, YUpperLimit, &ZLowerLimit, &ZUpperLimit);
}
float Agl(short JointNumber)
{
	float result;
	static BYTE parms[] = VTS_I2 ;
	InvokeHelper(0x74, DISPATCH_METHOD, VT_R4, (void*)&result, parms, JointNumber);
	return result;
}
long Call(LPCTSTR FunctionName)
{
	long result;
	static BYTE parms[] = VTS_BSTR ;
	InvokeHelper(0x75, DISPATCH_METHOD, VT_I4, (void*)&result, parms, FunctionName);
	return result;
}
short ParseString(LPCTSTR InputString, VARIANT Tokens, LPCTSTR Delimiter)
{
	short result;
	static BYTE parms[] = VTS_BSTR VTS_VARIANT VTS_BSTR ;
	InvokeHelper(0x76, DISPATCH_METHOD, VT_I2, (void*)&result, parms, InputString, &Tokens, Delimiter);
	return result;
}
BOOL MemSw(short BitNumber)
{
	BOOL result;
	static BYTE parms[] = VTS_I2 ;
	InvokeHelper(0x77, DISPATCH_METHOD, VT_BOOL, (void*)&result, parms, BitNumber);
	return result;
}
void VerInit()
{
	InvokeHelper(0x78, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
CString GetVersion()
{
	CString result;
	InvokeHelper(0x79, DISPATCH_METHOD, VT_BSTR, (void*)&result, NULL);
	return result;
}
void ResetAbort()
{
	InvokeHelper(0x7a, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
void VRun(LPCTSTR Sequence)
{
	static BYTE parms[] = VTS_BSTR ;
	InvokeHelper(0x7b, DISPATCH_METHOD, VT_EMPTY, NULL, parms, Sequence);
}
void VLoadModel(LPCTSTR Sequence, LPCTSTR Object, LPCTSTR FileName)
{
	static BYTE parms[] = VTS_BSTR VTS_BSTR VTS_BSTR ;
	InvokeHelper(0x7c, DISPATCH_METHOD, VT_EMPTY, NULL, parms, Sequence, Object, FileName);
}
void VSaveModel(LPCTSTR Sequence, LPCTSTR Object, LPCTSTR FileName)
{
	static BYTE parms[] = VTS_BSTR VTS_BSTR VTS_BSTR ;
	InvokeHelper(0x7d, DISPATCH_METHOD, VT_EMPTY, NULL, parms, Sequence, Object, FileName);
}
void VStatsShow(LPCTSTR Sequence)
{
	static BYTE parms[] = VTS_BSTR ;
	InvokeHelper(0x7e, DISPATCH_METHOD, VT_EMPTY, NULL, parms, Sequence);
}
void VStatsSave()
{
	InvokeHelper(0x7f, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
void VStatsResetAll()
{
	InvokeHelper(0x80, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
void VStatsReset(LPCTSTR Sequence)
{
	static BYTE parms[] = VTS_BSTR ;
	InvokeHelper(0x81, DISPATCH_METHOD, VT_EMPTY, NULL, parms, Sequence);
}
void SetSPELVar(LPCTSTR VarName, VARIANT Value)
{
	static BYTE parms[] = VTS_BSTR VTS_VARIANT ;
	InvokeHelper(0x82, DISPATCH_METHOD, VT_EMPTY, NULL, parms, VarName, &Value);
}
VARIANT GetSPELVar(LPCTSTR VarName)
{
	VARIANT result;
	static BYTE parms[] = VTS_BSTR ;
	InvokeHelper(0x83, DISPATCH_METHOD, VT_VARIANT, (void*)&result, parms, VarName);
	return result;
}
void SetSPELArray(LPCTSTR ArrayName, short Index, VARIANT Value)
{
	static BYTE parms[] = VTS_BSTR VTS_I2 VTS_VARIANT ;
	InvokeHelper(0x84, DISPATCH_METHOD, VT_EMPTY, NULL, parms, ArrayName, Index, &Value);
}
VARIANT GetSPELArray(LPCTSTR ArrayName, short Index)
{
	VARIANT result;
	static BYTE parms[] = VTS_BSTR VTS_I2 ;
	InvokeHelper(0x85, DISPATCH_METHOD, VT_VARIANT, (void*)&result, parms, ArrayName, Index);
	return result;
}
void VGetCameraXYU(LPCTSTR Sequence, LPCTSTR Object, short ResultNumber, long * Found, float * X, float * Y, float * U)
{
	static BYTE parms[] = VTS_BSTR VTS_BSTR VTS_I2 VTS_PI4 VTS_PR4 VTS_PR4 VTS_PR4 ;
	InvokeHelper(0x86, DISPATCH_METHOD, VT_EMPTY, NULL, parms, Sequence, Object, ResultNumber, Found, X, Y, U);
}
void VGetExtrema(LPCTSTR Sequence, LPCTSTR Object, short ResultNumber, long * Found, float * MinX, float * MaxX, float * MinY, float * MaxY)
{
	static BYTE parms[] = VTS_BSTR VTS_BSTR VTS_I2 VTS_PI4 VTS_PR4 VTS_PR4 VTS_PR4 VTS_PR4 ;
	InvokeHelper(0x87, DISPATCH_METHOD, VT_EMPTY, NULL, parms, Sequence, Object, ResultNumber, Found, MinX, MaxX, MinY, MaxY);
}
void VGetModelWin(LPCTSTR Sequence, LPCTSTR Object, short * Left, short * Top, short * Width, short * Height)
{
	static BYTE parms[] = VTS_BSTR VTS_BSTR VTS_PI2 VTS_PI2 VTS_PI2 VTS_PI2 ;
	InvokeHelper(0x88, DISPATCH_METHOD, VT_EMPTY, NULL, parms, Sequence, Object, Left, Top, Width, Height);
}
void VGetRobotXYU(LPCTSTR Sequence, LPCTSTR Object, short ResultNumber, long * Found, float * X, float * Y, float * U)
{
	static BYTE parms[] = VTS_BSTR VTS_BSTR VTS_I2 VTS_PI4 VTS_PR4 VTS_PR4 VTS_PR4 ;
	InvokeHelper(0x89, DISPATCH_METHOD, VT_EMPTY, NULL, parms, Sequence, Object, ResultNumber, Found, X, Y, U);
}
void VGetSearchWin(LPCTSTR Sequence, LPCTSTR Object, short * Left, short * Top, short * Width, short * Height)
{
	static BYTE parms[] = VTS_BSTR VTS_BSTR VTS_PI2 VTS_PI2 VTS_PI2 VTS_PI2 ;
	InvokeHelper(0x8a, DISPATCH_METHOD, VT_EMPTY, NULL, parms, Sequence, Object, Left, Top, Width, Height);
}
void VSetModelWin(LPCTSTR Sequence, LPCTSTR Object, short Left, short Top, short Width, short Height)
{
	static BYTE parms[] = VTS_BSTR VTS_BSTR VTS_I2 VTS_I2 VTS_I2 VTS_I2 ;
	InvokeHelper(0x8b, DISPATCH_METHOD, VT_EMPTY, NULL, parms, Sequence, Object, Left, Top, Width, Height);
}
void VSetSearchWin(LPCTSTR Sequence, LPCTSTR Object, short Left, short Top, short Width, short Height)
{
	static BYTE parms[] = VTS_BSTR VTS_BSTR VTS_I2 VTS_I2 VTS_I2 VTS_I2 ;
	InvokeHelper(0x8c, DISPATCH_METHOD, VT_EMPTY, NULL, parms, Sequence, Object, Left, Top, Width, Height);
}
void VGetPixelXYU(LPCTSTR Sequence, LPCTSTR Object, short ResultNumber, long * Found, float * X, float * Y, float * U)
{
	static BYTE parms[] = VTS_BSTR VTS_BSTR VTS_I2 VTS_PI4 VTS_PR4 VTS_PR4 VTS_PR4 ;
	InvokeHelper(0x8d, DISPATCH_METHOD, VT_EMPTY, NULL, parms, Sequence, Object, ResultNumber, Found, X, Y, U);
}
void LoadSPELGroup(LPCTSTR GroupName)
{
	static BYTE parms[] = VTS_BSTR ;
	InvokeHelper(0x8e, DISPATCH_METHOD, VT_EMPTY, NULL, parms, GroupName);
}
void VGet(LPCTSTR Sequence, LPCTSTR Object, LPCTSTR Property, VARIANT * Value)
{
	static BYTE parms[] = VTS_BSTR VTS_BSTR VTS_BSTR VTS_PVARIANT ;
	InvokeHelper(0x8f, DISPATCH_METHOD, VT_EMPTY, NULL, parms, Sequence, Object, Property, Value);
}
void VCls()
{
	InvokeHelper(0x90, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
void VGetPixelLine(LPCTSTR Sequence, LPCTSTR Object, float * X1, float * Y1, float * X2, float * Y2)
{
	static BYTE parms[] = VTS_BSTR VTS_BSTR VTS_PR4 VTS_PR4 VTS_PR4 VTS_PR4 ;
	InvokeHelper(0x91, DISPATCH_METHOD, VT_EMPTY, NULL, parms, Sequence, Object, X1, Y1, X2, Y2);
}
void VTeach(LPCTSTR Sequence, LPCTSTR Object)
{
	static BYTE parms[] = VTS_BSTR VTS_BSTR ;
	InvokeHelper(0x92, DISPATCH_METHOD, VT_EMPTY, NULL, parms, Sequence, Object);
}
void VSet(LPCTSTR Sequence, LPCTSTR Object, LPCTSTR Property, VARIANT Value)
{
	static BYTE parms[] = VTS_BSTR VTS_BSTR VTS_BSTR VTS_VARIANT ;
	InvokeHelper(0x93, DISPATCH_METHOD, VT_EMPTY, NULL, parms, Sequence, Object, Property, &Value);
}
void VSaveImage(LPCTSTR Sequence, LPCTSTR FileName)
{
	static BYTE parms[] = VTS_BSTR VTS_BSTR ;
	InvokeHelper(0x94, DISPATCH_METHOD, VT_EMPTY, NULL, parms, Sequence, FileName);
}
void Here(VARIANT Point)
{
	static BYTE parms[] = VTS_VARIANT ;
	InvokeHelper(0x95, DISPATCH_METHOD, VT_EMPTY, NULL, parms, &Point);
}
void JTran(short JointNumber, float Distance)
{
	static BYTE parms[] = VTS_I2 VTS_R4 ;
	InvokeHelper(0x96, DISPATCH_METHOD, VT_EMPTY, NULL, parms, JointNumber, Distance);
}
void PTran(short JointNumber, long Pulses)
{
	static BYTE parms[] = VTS_I2 VTS_I4 ;
	InvokeHelper(0x97, DISPATCH_METHOD, VT_EMPTY, NULL, parms, JointNumber, Pulses);
}
float PAgl(VARIANT Point, short JointNumber)
{
	float result;
	static BYTE parms[] = VTS_VARIANT VTS_I2 ;
	InvokeHelper(0x98, DISPATCH_METHOD, VT_R4, (void*)&result, parms, &Point, JointNumber);
	return result;
}
void VSaveProps()
{
	InvokeHelper(0x99, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
void EnableEvent(long EventNumber, long Enabled)
{
	static BYTE parms[] = VTS_I4 VTS_I4 ;
	InvokeHelper(0x9a, DISPATCH_METHOD, VT_EMPTY, NULL, parms, EventNumber, Enabled);
}
void AssignPoint(short Destination, VARIANT Source)
{
	static BYTE parms[] = VTS_I2 VTS_VARIANT ;
	InvokeHelper(0x9b, DISPATCH_METHOD, VT_EMPTY, NULL, parms, Destination, &Source);
}
void Go(VARIANT Destination)
{
	static BYTE parms[] = VTS_VARIANT ;
	InvokeHelper(0x9c, DISPATCH_METHOD, VT_EMPTY, NULL, parms, &Destination);
}
void Jump(VARIANT Destination)
{
	static BYTE parms[] = VTS_VARIANT ;
	InvokeHelper(0x9d, DISPATCH_METHOD, VT_EMPTY, NULL, parms, &Destination);
}
void Move(VARIANT Destination)
{
	static BYTE parms[] = VTS_VARIANT ;
	InvokeHelper(0x9e, DISPATCH_METHOD, VT_EMPTY, NULL, parms, &Destination);
}
void Pallet(short PalletNumber, VARIANT Point1, VARIANT Point2, VARIANT Point3, VARIANT Point4, short Columns, short Rows)
{
	static BYTE parms[] = VTS_I2 VTS_VARIANT VTS_VARIANT VTS_VARIANT VTS_VARIANT VTS_I2 VTS_I2 ;
	InvokeHelper(0x9f, DISPATCH_METHOD, VT_EMPTY, NULL, parms, PalletNumber, &Point1, &Point2, &Point3, &Point4, Columns, Rows);
}
void Xqt(short TaskNumber, LPCTSTR Function, VARIANT NoPause)
{
	static BYTE parms[] = VTS_I2 VTS_BSTR VTS_VARIANT ;
	InvokeHelper(0xa0, DISPATCH_METHOD, VT_EMPTY, NULL, parms, TaskNumber, Function, &NoPause);
}
short RobotType()
{
	short result;
	InvokeHelper(0xa1, DISPATCH_METHOD, VT_I2, (void*)&result, NULL);
	return result;
}
void GetIODef(long IOType, short BitNumber, BSTR * IOName, BSTR * Description)
{
	static BYTE parms[] = VTS_I4 VTS_I2 VTS_PBSTR VTS_PBSTR ;
	InvokeHelper(0xa2, DISPATCH_METHOD, VT_EMPTY, NULL, parms, IOType, BitNumber, IOName, Description);
}
void SetIODef(long IOType, short BitNumber, LPCTSTR IOName, LPCTSTR Description)
{
	static BYTE parms[] = VTS_I4 VTS_I2 VTS_BSTR VTS_BSTR ;
	InvokeHelper(0xa3, DISPATCH_METHOD, VT_EMPTY, NULL, parms, IOType, BitNumber, IOName, Description);
}
void LoadPoints(LPCTSTR PointFileName, VARIANT Merge)
{
	static BYTE parms[] = VTS_BSTR VTS_VARIANT ;
	InvokeHelper(0xa4, DISPATCH_METHOD, VT_EMPTY, NULL, parms, PointFileName, &Merge);
}
void Arc(VARIANT MidPoint, VARIANT EndPoint)
{
	static BYTE parms[] = VTS_VARIANT VTS_VARIANT ;
	InvokeHelper(0xa5, DISPATCH_METHOD, VT_EMPTY, NULL, parms, &MidPoint, &EndPoint);
}
void VCreateSequence(LPCTSTR SequenceName)
{
	static BYTE parms[] = VTS_BSTR ;
	InvokeHelper(0xa6, DISPATCH_METHOD, VT_EMPTY, NULL, parms, SequenceName);
}
void VCreateObject(LPCTSTR Sequence, LPCTSTR ObjectName, long ObjectType)
{
	static BYTE parms[] = VTS_BSTR VTS_BSTR VTS_I4 ;
	InvokeHelper(0xa7, DISPATCH_METHOD, VT_EMPTY, NULL, parms, Sequence, ObjectName, ObjectType);
}
void VDeleteSequence(LPCTSTR Sequence)
{
	static BYTE parms[] = VTS_BSTR ;
	InvokeHelper(0xa8, DISPATCH_METHOD, VT_EMPTY, NULL, parms, Sequence);
}
void VDeleteObject(LPCTSTR Sequence, LPCTSTR Object)
{
	static BYTE parms[] = VTS_BSTR VTS_BSTR ;
	InvokeHelper(0xa9, DISPATCH_METHOD, VT_EMPTY, NULL, parms, Sequence, Object);
}
void Base(float X, float Y, float Z, float U, VARIANT V, VARIANT W)
{
	static BYTE parms[] = VTS_R4 VTS_R4 VTS_R4 VTS_R4 VTS_VARIANT VTS_VARIANT ;
	InvokeHelper(0xaa, DISPATCH_METHOD, VT_EMPTY, NULL, parms, X, Y, Z, U, &V, &W);
}
float ENetIO_AnaIn(long Channel)
{
	float result;
	static BYTE parms[] = VTS_I4 ;
	InvokeHelper(0xab, DISPATCH_METHOD, VT_R4, (void*)&result, parms, Channel);
	return result;
}
void ENetIO_AnaOut(long Channel, float Value)
{
	static BYTE parms[] = VTS_I4 VTS_R4 ;
	InvokeHelper(0xac, DISPATCH_METHOD, VT_EMPTY, NULL, parms, Channel, Value);
}
BOOL ENetIO_Sw(long BitNumber)
{
	BOOL result;
	static BYTE parms[] = VTS_I4 ;
	InvokeHelper(0xad, DISPATCH_METHOD, VT_BOOL, (void*)&result, parms, BitNumber);
	return result;
}
short ENetIO_In(long PortNumber)
{
	short result;
	static BYTE parms[] = VTS_I4 ;
	InvokeHelper(0xae, DISPATCH_METHOD, VT_I2, (void*)&result, parms, PortNumber);
	return result;
}
void ENetIO_Out(long PortNumber, long Value)
{
	static BYTE parms[] = VTS_I4 VTS_I4 ;
	InvokeHelper(0xaf, DISPATCH_METHOD, VT_EMPTY, NULL, parms, PortNumber, Value);
}
void ENetIO_AnaGetConfig(long Channel, float * Gain, float * Offset, float * LoScale, float * HiScale)
{
	static BYTE parms[] = VTS_I4 VTS_PR4 VTS_PR4 VTS_PR4 VTS_PR4 ;
	InvokeHelper(0xb0, DISPATCH_METHOD, VT_EMPTY, NULL, parms, Channel, Gain, Offset, LoScale, HiScale);
}
void ENetIO_AnaSetConfig(long Channel, float Gain, float Offset, float LoScale, float HiScale)
{
	static BYTE parms[] = VTS_I4 VTS_R4 VTS_R4 VTS_R4 VTS_R4 ;
	InvokeHelper(0xb1, DISPATCH_METHOD, VT_EMPTY, NULL, parms, Channel, Gain, Offset, LoScale, HiScale);
}
void ENetIO_ClearLatches(long BitNumber)
{
	static BYTE parms[] = VTS_I4 ;
	InvokeHelper(0xb2, DISPATCH_METHOD, VT_EMPTY, NULL, parms, BitNumber);
}
BOOL ENetIO_SwLatch(long BitNumber, long LatchType)
{
	BOOL result;
	static BYTE parms[] = VTS_I4 VTS_I4 ;
	InvokeHelper(0xb3, DISPATCH_METHOD, VT_BOOL, (void*)&result, parms, BitNumber, LatchType);
	return result;
}
void Force_Calibrate()
{
	InvokeHelper(0xb4, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
void Force_ClearTrigger()
{
	InvokeHelper(0xb5, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
float Force_GetForce(long Axis)
{
	float result;
	static BYTE parms[] = VTS_I4 ;
	InvokeHelper(0xb6, DISPATCH_METHOD, VT_R4, (void*)&result, parms, Axis);
	return result;
}
void ENetIO_On(long BitNumber, VARIANT Seconds)
{
	static BYTE parms[] = VTS_I4 VTS_VARIANT ;
	InvokeHelper(0xb7, DISPATCH_METHOD, VT_EMPTY, NULL, parms, BitNumber, &Seconds);
}
void ENetIO_Off(long BitNumber, VARIANT Seconds)
{
	static BYTE parms[] = VTS_I4 VTS_VARIANT ;
	InvokeHelper(0xb8, DISPATCH_METHOD, VT_EMPTY, NULL, parms, BitNumber, &Seconds);
}
void Force_GetForces(VARIANT Axes)
{
	static BYTE parms[] = VTS_VARIANT ;
	InvokeHelper(0xb9, DISPATCH_METHOD, VT_EMPTY, NULL, parms, &Axes);
}
void Force_SetTrigger(long Axis, float Threshold, long CompareType)
{
	static BYTE parms[] = VTS_I4 VTS_R4 VTS_I4 ;
	InvokeHelper(0xba, DISPATCH_METHOD, VT_EMPTY, NULL, parms, Axis, Threshold, CompareType);
}
void Force_TCLim(short J1TorqueLimit, short J2TorqueLimit, short J3TorqueLimit, short J4TorqueLimit, VARIANT J5TorqueLimit, VARIANT J6TorqueLimit)
{
	static BYTE parms[] = VTS_I2 VTS_I2 VTS_I2 VTS_I2 VTS_VARIANT VTS_VARIANT ;
	InvokeHelper(0xbb, DISPATCH_METHOD, VT_EMPTY, NULL, parms, J1TorqueLimit, J2TorqueLimit, J3TorqueLimit, J4TorqueLimit, &J5TorqueLimit, &J6TorqueLimit);
}
void Force_TCSpeed(short Speed)
{
	static BYTE parms[] = VTS_I2 ;
	InvokeHelper(0xbc, DISPATCH_METHOD, VT_EMPTY, NULL, parms, Speed);
}
BOOL ENetIO_Oport(long BitNumber)
{
	BOOL result;
	static BYTE parms[] = VTS_I4 ;
	InvokeHelper(0xbd, DISPATCH_METHOD, VT_BOOL, (void*)&result, parms, BitNumber);
	return result;
}
void LogIn(LPCTSTR LogID, LPCTSTR Password)
{
	static BYTE parms[] = VTS_BSTR VTS_BSTR ;
	InvokeHelper(0xbe, DISPATCH_METHOD, VT_EMPTY, NULL, parms, LogID, Password);
}
CString GetCurrentUser()
{
	CString result;
	InvokeHelper(0xbf, DISPATCH_METHOD, VT_BSTR, (void*)&result, NULL);
	return result;
}
void VShowSequence(LPCTSTR Sequence)
{
	static BYTE parms[] = VTS_BSTR ;
	InvokeHelper(0xc0, DISPATCH_METHOD, VT_EMPTY, NULL, parms, Sequence);
}
void VShowModel(LPCTSTR Sequence, LPCTSTR Object)
{
	static BYTE parms[] = VTS_BSTR VTS_BSTR ;
	InvokeHelper(0xc1, DISPATCH_METHOD, VT_EMPTY, NULL, parms, Sequence, Object);
}
BOOL VTrain(LPCTSTR Sequence, LPCTSTR Object, VARIANT Flags)
{
	BOOL result;
	static BYTE parms[] = VTS_BSTR VTS_BSTR VTS_VARIANT ;
	InvokeHelper(0xc2, DISPATCH_METHOD, VT_BOOL, (void*)&result, parms, Sequence, Object, &Flags);
	return result;
}
void Initialize()
{
	InvokeHelper(0xc3, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
void RestartSPEL()
{
	InvokeHelper(0xc4, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
void Shutdown(long Mode)
{
	static BYTE parms[] = VTS_I4 ;
	InvokeHelper(0xc5, DISPATCH_METHOD, VT_EMPTY, NULL, parms, Mode);
}
void RebuildProject()
{
	InvokeHelper(0xc6, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
void Curve(LPCTSTR FileName, long Closure, long Mode, long NumOfAxes, LPCTSTR PointList)
{
	static BYTE parms[] = VTS_BSTR VTS_I4 VTS_I4 VTS_I4 VTS_BSTR ;
	InvokeHelper(0xc7, DISPATCH_METHOD, VT_EMPTY, NULL, parms, FileName, Closure, Mode, NumOfAxes, PointList);
}
void CVMove(LPCTSTR FileName, VARIANT OptionList)
{
	static BYTE parms[] = VTS_BSTR VTS_VARIANT ;
	InvokeHelper(0xc8, DISPATCH_METHOD, VT_EMPTY, NULL, parms, FileName, &OptionList);
}
BOOL TillOn()
{
	BOOL result;
	InvokeHelper(0xc9, DISPATCH_METHOD, VT_BOOL, (void*)&result, NULL);
	return result;
}
short CtrlDev()
{
	short result;
	InvokeHelper(0xca, DISPATCH_METHOD, VT_I2, (void*)&result, NULL);
	return result;
}
void WaitCommandComplete()
{
	InvokeHelper(0xcc, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
void WaitAbortComplete()
{
	InvokeHelper(0xcd, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
void DisableMsgDispatch(long Disabled)
{
	static BYTE parms[] = VTS_I4 ;
	InvokeHelper(0xce, DISPATCH_METHOD, VT_EMPTY, NULL, parms, Disabled);
}
long ENetIO_ReadCount(long BitNumber, long ClearCounter)
{
	long result;
	static BYTE parms[] = VTS_I4 VTS_I4 ;
	InvokeHelper(0xcf, DISPATCH_METHOD, VT_I4, (void*)&result, parms, BitNumber, ClearCounter);
	return result;
}
long ENetIO_DigGetConfig(long BitNumber)
{
	long result;
	static BYTE parms[] = VTS_I4 ;
	InvokeHelper(0xd0, DISPATCH_METHOD, VT_I4, (void*)&result, parms, BitNumber);
	return result;
}
long ENetIO_DigSetConfig(long BitNumber, long Config)
{
	long result;
	static BYTE parms[] = VTS_I4 VTS_I4 ;
	InvokeHelper(0xd1, DISPATCH_METHOD, VT_I4, (void*)&result, parms, BitNumber, Config);
	return result;
}
short FbusIO_In(long BusNumber, long DeviceID, long PortNumber)
{
	short result;
	static BYTE parms[] = VTS_I4 VTS_I4 VTS_I4 ;
	InvokeHelper(0xd2, DISPATCH_METHOD, VT_I2, (void*)&result, parms, BusNumber, DeviceID, PortNumber);
	return result;
}
long FbusIO_InW(long BusNumber, long DeviceID, long PortNumber)
{
	long result;
	static BYTE parms[] = VTS_I4 VTS_I4 VTS_I4 ;
	InvokeHelper(0xd3, DISPATCH_METHOD, VT_I4, (void*)&result, parms, BusNumber, DeviceID, PortNumber);
	return result;
}
short FbusIO_Off(long BusNumber, long DeviceID, long BitNumber, VARIANT Seconds)
{
	short result;
	static BYTE parms[] = VTS_I4 VTS_I4 VTS_I4 VTS_VARIANT ;
	InvokeHelper(0xd4, DISPATCH_METHOD, VT_I2, (void*)&result, parms, BusNumber, DeviceID, BitNumber, &Seconds);
	return result;
}
short FbusIO_On(long BusNumber, long DeviceID, long BitNumber, VARIANT Seconds)
{
	short result;
	static BYTE parms[] = VTS_I4 VTS_I4 VTS_I4 VTS_VARIANT ;
	InvokeHelper(0xd5, DISPATCH_METHOD, VT_I2, (void*)&result, parms, BusNumber, DeviceID, BitNumber, &Seconds);
	return result;
}
short FbusIO_Oport(long BusNumber, long DeviceID, long BitNumber)
{
	short result;
	static BYTE parms[] = VTS_I4 VTS_I4 VTS_I4 ;
	InvokeHelper(0xd6, DISPATCH_METHOD, VT_I2, (void*)&result, parms, BusNumber, DeviceID, BitNumber);
	return result;
}
short FbusIO_Out(long BusNumber, long DeviceID, long PortNumber, long Value)
{
	short result;
	static BYTE parms[] = VTS_I4 VTS_I4 VTS_I4 VTS_I4 ;
	InvokeHelper(0xd7, DISPATCH_METHOD, VT_I2, (void*)&result, parms, BusNumber, DeviceID, PortNumber, Value);
	return result;
}
short FbusIO_OutW(long BusNumber, long DeviceID, long PortNumber, long Value)
{
	short result;
	static BYTE parms[] = VTS_I4 VTS_I4 VTS_I4 VTS_I4 ;
	InvokeHelper(0xd8, DISPATCH_METHOD, VT_I2, (void*)&result, parms, BusNumber, DeviceID, PortNumber, Value);
	return result;
}
short FbusIO_Sw(long BusNumber, long DeviceID, long BitNumber)
{
	short result;
	static BYTE parms[] = VTS_I4 VTS_I4 VTS_I4 ;
	InvokeHelper(0xd9, DISPATCH_METHOD, VT_I2, (void*)&result, parms, BusNumber, DeviceID, BitNumber);
	return result;
}
short FbusIO_SendMsg(long BusNumber, long DeviceID, long MsgParam, VARIANT * SendBytes, VARIANT * RecvBytes)
{
	short result;
	static BYTE parms[] = VTS_I4 VTS_I4 VTS_I4 VTS_PVARIANT VTS_PVARIANT ;
	InvokeHelper(0xda, DISPATCH_METHOD, VT_I2, (void*)&result, parms, BusNumber, DeviceID, MsgParam, SendBytes, RecvBytes);
	return result;
}
void Arc3(VARIANT MidPoint, VARIANT EndPoint)
{
	static BYTE parms[] = VTS_VARIANT VTS_VARIANT ;
	InvokeHelper(0xdb, DISPATCH_METHOD, VT_EMPTY, NULL, parms, &MidPoint, &EndPoint);
}
void AccelsEx(float Accel, float Decel, float DepartAccel, float DepartDecel, float ApproAccel, float ApproDecel)
{
	static BYTE parms[] = VTS_R4 VTS_R4 VTS_R4 VTS_R4 VTS_R4 VTS_R4 ;
	InvokeHelper(0xdc, DISPATCH_METHOD, VT_EMPTY, NULL, parms, Accel, Decel, DepartAccel, DepartDecel, ApproAccel, ApproDecel);
}
float CV(VARIANT Point)
{
	float result;
	static BYTE parms[] = VTS_VARIANT ;
	InvokeHelper(0xdd, DISPATCH_METHOD, VT_R4, (void*)&result, parms, &Point);
	return result;
}
float CW(VARIANT Point)
{
	float result;
	static BYTE parms[] = VTS_VARIANT ;
	InvokeHelper(0xde, DISPATCH_METHOD, VT_R4, (void*)&result, parms, &Point);
	return result;
}
long Recover()
{
	long result;
	InvokeHelper(0xdf, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}
void Jump3(VARIANT DepartPoint, VARIANT ApproPoint, VARIANT DestPoint)
{
	static BYTE parms[] = VTS_VARIANT VTS_VARIANT VTS_VARIANT ;
	InvokeHelper(0xe0, DISPATCH_METHOD, VT_EMPTY, NULL, parms, &DepartPoint, &ApproPoint, &DestPoint);
}
void Jump3CP(VARIANT DepartPoint, VARIANT ApproPoint, VARIANT DestPoint)
{
	static BYTE parms[] = VTS_VARIANT VTS_VARIANT VTS_VARIANT ;
	InvokeHelper(0xe1, DISPATCH_METHOD, VT_EMPTY, NULL, parms, &DepartPoint, &ApproPoint, &DestPoint);
}
void GetPointEx(VARIANT Point, float * X, float * Y, float * Z, float * U, float * V, float * W, short * Local, short * Hand, short * Elbow, short * Wrist, short * J4Flag, short * J6Flag)
{
	static BYTE parms[] = VTS_VARIANT VTS_PR4 VTS_PR4 VTS_PR4 VTS_PR4 VTS_PR4 VTS_PR4 VTS_PI2 VTS_PI2 VTS_PI2 VTS_PI2 VTS_PI2 VTS_PI2 ;
	InvokeHelper(0xe2, DISPATCH_METHOD, VT_EMPTY, NULL, parms, &Point, X, Y, Z, U, V, W, Local, Hand, Elbow, Wrist, J4Flag, J6Flag);
}
void SetPointEx(VARIANT Point, float X, float Y, float Z, float U, float V, float W, short Local, short Hand, short Elbow, short Wrist, short J4Flag, short J6Flag)
{
	static BYTE parms[] = VTS_VARIANT VTS_R4 VTS_R4 VTS_R4 VTS_R4 VTS_R4 VTS_R4 VTS_I2 VTS_I2 VTS_I2 VTS_I2 VTS_I2 VTS_I2 ;
	InvokeHelper(0xe3, DISPATCH_METHOD, VT_EMPTY, NULL, parms, &Point, X, Y, Z, U, V, W, Local, Hand, Elbow, Wrist, J4Flag, J6Flag);
}
long FbusIO_GetBusStatus(long BusNumber)
{
	long result;
	static BYTE parms[] = VTS_I4 ;
	InvokeHelper(0xe4, DISPATCH_METHOD, VT_I4, (void*)&result, parms, BusNumber);
	return result;
}
long FbusIO_GetDeviceStatus(long BusNumber, long DeviceID)
{
	long result;
	static BYTE parms[] = VTS_I4 VTS_I4 ;
	InvokeHelper(0xe5, DISPATCH_METHOD, VT_I4, (void*)&result, parms, BusNumber, DeviceID);
	return result;
}
void VCreateCalibration(LPCTSTR CalibName)
{
	static BYTE parms[] = VTS_BSTR ;
	InvokeHelper(0xe6, DISPATCH_METHOD, VT_EMPTY, NULL, parms, CalibName);
}
void VDeleteCalibration(LPCTSTR CalibName)
{
	static BYTE parms[] = VTS_BSTR ;
	InvokeHelper(0xe7, DISPATCH_METHOD, VT_EMPTY, NULL, parms, CalibName);
}
void AccelR(short Accel, VARIANT Decel)
{
	static BYTE parms[] = VTS_I2 VTS_VARIANT ;
	InvokeHelper(0xe8, DISPATCH_METHOD, VT_EMPTY, NULL, parms, Accel, &Decel);
}
void ECP(short ECPNumber)
{
	static BYTE parms[] = VTS_I2 ;
	InvokeHelper(0xe9, DISPATCH_METHOD, VT_EMPTY, NULL, parms, ECPNumber);
}
short GetECP()
{
	short result;
	InvokeHelper(0xea, DISPATCH_METHOD, VT_I2, (void*)&result, NULL);
	return result;
}
void ECPSet(short ECPNumber, float XCoord, float YCoord, float ZCoord, float UCoord, VARIANT VCoord, VARIANT WCoord)
{
	static BYTE parms[] = VTS_I2 VTS_R4 VTS_R4 VTS_R4 VTS_R4 VTS_VARIANT VTS_VARIANT ;
	InvokeHelper(0xeb, DISPATCH_METHOD, VT_EMPTY, NULL, parms, ECPNumber, XCoord, YCoord, ZCoord, UCoord, &VCoord, &WCoord);
}
void SpeedR(short Speed)
{
	static BYTE parms[] = VTS_I2 ;
	InvokeHelper(0xec, DISPATCH_METHOD, VT_EMPTY, NULL, parms, Speed);
}
void PTPBoost(float BoostValue, VARIANT DepartBoost, VARIANT ApproBoost)
{
	static BYTE parms[] = VTS_R4 VTS_VARIANT VTS_VARIANT ;
	InvokeHelper(0xed, DISPATCH_METHOD, VT_EMPTY, NULL, parms, BoostValue, &DepartBoost, &ApproBoost);
}
BOOL PTPBoostOK(VARIANT Destination)
{
	BOOL result;
	static BYTE parms[] = VTS_VARIANT ;
	InvokeHelper(0xee, DISPATCH_METHOD, VT_BOOL, (void*)&result, parms, &Destination);
	return result;
}
BOOL TargetOK(VARIANT Destination)
{
	BOOL result;
	static BYTE parms[] = VTS_VARIANT ;
	InvokeHelper(0xef, DISPATCH_METHOD, VT_BOOL, (void*)&result, parms, &Destination);
	return result;
}
void ImportPoints(LPCTSTR SourcePath, LPCTSTR ProjectFile)
{
	static BYTE parms[] = VTS_BSTR VTS_BSTR ;
	InvokeHelper(0xf0, DISPATCH_METHOD, VT_EMPTY, NULL, parms, SourcePath, ProjectFile);
}
void AboutBox()
{
	InvokeHelper(DISPID_ABOUTBOX, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

// Properties
//

CString GetPassword()
{
	CString result;
	GetProperty(0x1, VT_BSTR, (void*)&result);
	return result;
}
void SetPassword(CString propVal)
{
	SetProperty(0x1, VT_BSTR, propVal);
}
short GetTimeOut()
{
	short result;
	GetProperty(0x2, VT_I2, (void*)&result);
	return result;
}
void SetTimeOut(short propVal)
{
	SetProperty(0x2, VT_I2, propVal);
}
BOOL GetMotorsOn()
{
	BOOL result;
	GetProperty(0x3, VT_BOOL, (void*)&result);
	return result;
}
void SetMotorsOn(BOOL propVal)
{
	SetProperty(0x3, VT_BOOL, propVal);
}
long GetAction()
{
	long result;
	GetProperty(0x4, VT_I4, (void*)&result);
	return result;
}
void SetAction(long propVal)
{
	SetProperty(0x4, VT_I4, propVal);
}
CString GetCommand()
{
	CString result;
	GetProperty(0x5, VT_BSTR, (void*)&result);
	return result;
}
void SetCommand(CString propVal)
{
	SetProperty(0x5, VT_BSTR, propVal);
}
CString GetErrorMessage()
{
	CString result;
	GetProperty(0x6, VT_BSTR, (void*)&result);
	return result;
}
void SetErrorMessage(CString propVal)
{
	SetProperty(0x6, VT_BSTR, propVal);
}
long GetErrorNumber()
{
	long result;
	GetProperty(0x7, VT_I4, (void*)&result);
	return result;
}
void SetErrorNumber(long propVal)
{
	SetProperty(0x7, VT_I4, propVal);
}
BOOL GetDesignMode()
{
	BOOL result;
	GetProperty(0x8, VT_BOOL, (void*)&result);
	return result;
}
void SetDesignMode(BOOL propVal)
{
	SetProperty(0x8, VT_BOOL, propVal);
}
BOOL GetPowerHigh()
{
	BOOL result;
	GetProperty(0x9, VT_BOOL, (void*)&result);
	return result;
}
void SetPowerHigh(BOOL propVal)
{
	SetProperty(0x9, VT_BOOL, propVal);
}
CString GetProject()
{
	CString result;
	GetProperty(0xa, VT_BSTR, (void*)&result);
	return result;
}
void SetProject(CString propVal)
{
	SetProperty(0xa, VT_BSTR, propVal);
}
BOOL GetPortOpen()
{
	BOOL result;
	GetProperty(0xb, VT_BOOL, (void*)&result);
	return result;
}
void SetPortOpen(BOOL propVal)
{
	SetProperty(0xb, VT_BOOL, propVal);
}
BOOL GetQPOn()
{
	BOOL result;
	GetProperty(0xc, VT_BOOL, (void*)&result);
	return result;
}
void SetQPOn(BOOL propVal)
{
	SetProperty(0xc, VT_BOOL, propVal);
}
LPDISPATCH GetVideoControl()
{
	LPDISPATCH result;
	GetProperty(0xd, VT_DISPATCH, (void*)&result);
	return result;
}
void SetVideoControl(LPDISPATCH propVal)
{
	SetProperty(0xd, VT_DISPATCH, propVal);
}
short GetRobot()
{
	short result;
	GetProperty(0xe, VT_I2, (void*)&result);
	return result;
}
void SetRobot(short propVal)
{
	SetProperty(0xe, VT_I2, propVal);
}
short GetForce_Sensor()
{
	short result;
	GetProperty(0xf, VT_I2, (void*)&result);
	return result;
}
void SetForce_Sensor(short propVal)
{
	SetProperty(0xf, VT_I2, propVal);
}
BOOL GetForce_TCOn()
{
	BOOL result;
	GetProperty(0x10, VT_BOOL, (void*)&result);
	return result;
}
void SetForce_TCOn(BOOL propVal)
{
	SetProperty(0x10, VT_BOOL, propVal);
}
BOOL GetAsyncMode()
{
	BOOL result;
	GetProperty(0xcb, VT_BOOL, (void*)&result);
	return result;
}
void SetAsyncMode(BOOL propVal)
{
	SetProperty(0xcb, VT_BOOL, propVal);
}


};
