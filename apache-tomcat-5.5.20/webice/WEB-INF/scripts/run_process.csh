#!/bin/csh -f

############################################################
#
# Process images and they are written out by the detector.
# Input parameters are read from process.properties
# in working directory. Output are written to stdout and
# files in current dir.
#
# This script should be split in two parts : 1) gathering all 
# the input and setting up the data processing and 2) generating,
# running the scripts and extracting results
#
# Usage:
#	run_process.csh
#
############################################################

# Set script dir to this script location
setenv WEBICE_SCRIPT_DIR `dirname $0`

# Setup env with path to software, etc.
source $WEBICE_SCRIPT_DIR/setup_env.csh

echo `date +"%T"` " Started processing data"
echo `date +"%T"` " HOST = $HOST"

# workDir is current dir
set workDir = `pwd`

# Parse process.properties - the input to this script can change in the future!

#runName: a unique identifier for the data processing job. It is either provided by the user
#or generated by the data collection software

set runName = `awk '/runName=/{print substr($0, 9);}' process.properties`
set imageDir = `awk '/^imageDir=/{print substr($0, 10);}' process.properties`
set imageRootName = `awk '/imageRootName=/{print substr($0, 15);}' process.properties`

#Knowing the beamline is useful when the crystal analysis server is common to several beamlines. It serves to identify the correct
#beamline dump file and the beamline properties file (containing beamline dependent data processing parameters)

set beamline = `awk '/beamline=/{print substr($0, 10);}' process.properties`
set beamlineDumpFile = `awk '/dcsDumpFile=/{print substr($0, 13);}' process.properties`
set beamlineFile = `awk '/beamlineFile=/{print substr($0, 14);}' process.properties`

#The experiment type can be native, MAD or SAD; default is Native
echo `date +"%T"` "Initial data processing parameters:"
echo `date +"%T"` " scriptDir = $WEBICE_SCRIPT_DIR"
echo `date +"%T"` " runName = $runName"
echo `date +"%T"` " workDir = $workDir"
echo `date +"%T"` " imageDir = $imageDir"
echo `date +"%T"` " imageRootName = $imageRootName"
echo `date +"%T"` " beamline = $beamline"

#Last image collected: Last image written to disk by data collection software.
#Last image processed: the last image that has been integrated (with mosflm or XDS). If the data are
#being collected in wedges (e.g., for a MAD or SAD experiment), there will be a last image processed 
#for each energy or inverse pass) 
#last image processed and last image collected are set to 0 to begin with


#Make a  directory to store the beamline dump file and beamline properties file
if (! -d PARAMETERS) then
mkdir -p PARAMETERS
endif

# Copy beamline property file
if (-e $beamlineFile) then
    echo `date +"%T"` " Copying $beamlineFile"
    cp $beamlineFile PARAMETERS/beamline.properties
else
    set tmp1 = `dirname $beamlineFile`"/default.properties"
    echo `date +"%T"` " Cannot find $beamlineFile"
    echo `date +"%T"` " Copying $tmp1 instead"
    cp $tmp1 PARAMETERS/beamline.properties
endif

#If data collection is going on, update the data processing parameters

$WEBICE_SCRIPT_DIR/get_collection_status.csh

if (status == 0) then    

#Update data collection properties    

    set run_info = `awk -f $WEBICE_SCRIPT_DIR/get_run_info.awk PARAMETERS/dcs_params.txt`

    echo "runName=$runName" > process.properties
    echo "imageDir=$imageDir" >> process.properties
    echo "imageRootName=$imageRootName" >> process.properties
    echo "expType=$expType" >> process.properties
    echo "beamline=$beamline" >> process.properties
    echo "dcsDumpFile=$dcsDumpFile" >> process.properties
    echo "beamlineFile=$beamlineFile" >> process.properties
    echo "lastprocessed=$lastprocessed" >> process.properties
    echo "dcsrunLabel=$run_info[4]" >> process.properties
    echo "dcsimageName=$run_info[5]" >> process.properties
    echo "dcsimageDir=$run_info[6]" >> process.properties
    echo "endPhi=$run_info[8]" >> process.properties
    echo "detectorDistance=$run_info[10]" >> process.properties
    echo "numEnergy=$run_info[11]" >> process.properties
    echo "energy1=$run_info[12]" >> process.properties
    echo "energy2=$run_info[13]" >> process.properties
    echo "energy3=$run_info[14]" >> process.properties
    echo "energy4=$run_info[15]" >> process.properties
    echo "energy5=$run_info[16]" >> process.properties
    echo "inverse=$run_info[17]" >> process.properties

    #Have we started proccessing the data? Do we have the first image in the data set, experiment and detector type?

    if ($?firstimage ) then

	@ try = 1                 #Give the BL software a chance to collect and write out the first image
	while ($try < 60) 
	    set listImageCollected = `ls -tr ${imageDir}/${imageRootName}_${runLabel}*`
	    if ($status == 0) then
		set firstImageCollected = $listImageCollected[1]
		set firstimage = `echo $firstImageCollected:t:r | sed "s/[a-z]//g" | sed "s/[0-9_]_0*//g" `
		set startingPhi = `/usr/local/dcs/diffimage/linux/getImgHeader $firstImageCollected | grep PHI`
		set deltaPhi = `/usr/local/dcs/diffimage/linux/getImgHeader $firstImageCollected | grep OSC_RANGE`
		set imageNumberTemplate = ` echo $firstImageCollected:t | sed "s/[a-z]//g" | sed "s/_*[0-9]./#/g" `
		set imgExt = $firstImageCollected:e
		break
	    else
		sleep 60
		@ try ++
	    endif       
	end

	#If the first image is not there after one hour, give up.
	if ($?firstimage == "") then
	    echo "Could not find first image in 60 tries"
	    exit 
	endif
 	
    endif

    echo "firstimage=$firstimage" >> process.properties
    echo "startingPhi=$startingPhi[2]" >> process.properties
    echo "deltaPhi=$deltaPhi[2]" >> process.properties
    echo "firstimagePath = $firstImageCollected" >> process.properties
    echo "imgExt = $imgExt" >> process.properties


    set expType = native
    if ($run_info[13] != 0 ) then 
	set expType = MAD
    else 
	if ( $run_info[17] == 1 ) set expType = SAD
    endif
    echo "expType=$expType" >> process.properties

else
    echo "Data collection stopped before images were collected"
    exit 

#read last image

	
endif #If status = collecting



###############################
# Run processing scripts here
###############################

set runName = `awk '/runName=/{print substr($0, 9);}' process.properties`
set imageDir = `awk '/^imageDir=/{print substr($0, 10);}' process.properties`
set imageRootName = `awk '/imageRootName=/{print substr($0, 15);}' process.properties`
set imgExt = `awk '/^imgExt=/{print substr($0, 8);}' process.properties `
set beamline = `awk '/beamline=/{print substr($0, 10);}' process.properties`
set expType = `awk '/expType=/{print substr($0, 9);}' process.properties`
set beamlineDumpFile = `awk '/dcsDumpFile=/{print substr($0, 13);}' process.properties`
set beamlineFile = `awk '/beamlineFile=/{print substr($0, 14);}' process.properties`
set lastprocessed = `awk '/lastprocessed/{print substr($0, 15);}' process.properties`
set lastimage = `awk '/lastimage/{print substr($0, 11);}' process.properties` 
set firstimage = `awk '/firstimage/{print substr($0, 12);}' process.properties` 
set runLabel = `awk '/dcsrunLabel/{print substr($0, 13);}' process.properties`
set imageName = `awk '/dcsimageName/{print substr($0, 14);}' process.properties`
set imageDir = `awk '/dcsimageDir/{print substr($0, 13);}' process.properties`
set startingPhi = `awk '/startingPhi/{print substr($0, 13);}' process.properties`
set endPhi = `awk '/endPhi/{print substr($0, 8);}' process.properties`     
set deltaPhi = `awk '/deltaPhi/{print substr($0, 10);}' process.properties`   
set detectorDistance = `awk '/detectorDistance/{print substr($0, 18);}' process.properties`
set numEnergy = `awk '/numEnergy/{print substr($0, 11);}' process.properties`
set energy1 = `awk '/energy1/{print substr($0, 9);}' process.properties`
set energy2 = `awk '/energy2/{print substr($0, 9);}' process.properties`
set lastprocessedE2 = `awk '/lastprocessedE2/{print substr($0, 17);}' process.properties`
set lastimageE2 = `awk '/lastimageE2/{print substr($0, 13);}' process.properties` 
set energy3 = `awk '/energy3/{print substr($0, 9);}' process.properties`
set lastprocessedE3 = `awk '/lastprocessedE3/{print substr($0, 17);}' process.properties`
set lastimageE3 = `awk '/lastimageE3/{print substr($0, 13);}' process.properties` 
set energy4 = `awk '/energy4/{print substr($0, 9);}' process.properties`
set lastprocessedE4 = `awk '/lastprocessedE4/{print substr($0, 17);}' process.properties`
set lastimageE4 = `awk '/lastimageE4/{print substr($0, 13);}' process.properties` 
set inverse = `awk '/inverse/{print substr($0, 9);}' process.properties`
set lastprocessedInv = `awk '/lastprocessedInv/{print substr($0, 18);}' process.properties`
set lastimageInv = `awk '/lastimageInv/{print substr($0, 14);}' process.properties` 
set firstimageInv = `awk '/firstimageInv/{print substr($0, 15);}' process.properties` 


###########################################################################
# If the run has been started from Web-Ice, look for the autoindexing results
# I am not sure how to check this! Right now, if a directory named after the 
# runName exists under the webice autoindex area, the autoindex results get copied.
# This will only work if a) the crystal has not been remounted (or the information
# about the crystal orientation is preserved and b) the runName choice is not free.
# 
###########################################################################

set isWebiceRun = 0

set autoindexDir = /data/$USER/webice/autoindex/$runName/LABELIT

# We should apply more checks to this or comment it out

if ( -e autoindexDir/labelit.out) set isWebiceRun = 1

set labelit_error = ""

if ($isWebiceRun) then
    # Check if no autoindex solution
    set labelit_error = (`cat $autoindexDir/labelit.out | awk '/^No_Indexing_Solution/{ print $0; }'`)

    # Check if autoindex is ok, if not, print last line
    if ("$labelit_error" == "") then
	set labelit_error = (`cat $autoindexDir/labelit.out | awk 'BEGIN{ err = ""; found = 0; } /LABELIT Indexing results/{ found = 1; } { if (found == 0) { err = $0; }}  END{ if (found == 1) {print err;}}'`)
    endif

    if ("$labelit_error" != "") then
	goto autoindex
    else
	ln -snf $autoindexDir .
	echo `date +"%T"` "Linked to LABELIT results"
	goto integration
    endif
else
    goto autoindex
	
endif #isWebiceRun

#########################################################################################################
#Autoindexing:
#The images need a minimum separation in phi ($autoindexDiff) for results to be semi-reliable
#If the autoindex fails, try with another pair of images.
###############################################################################################################

autoindex:

echo `date +"%T"` "No autoindexing results found. Autoindexing from scratch"


set isAutoindexOK = 0 # if isAutoindexOK = 1, it means that the autoindexing was carried out sucessfully
set autoindexDiff = 10 # autoindexDiff is the MINIMUM separation in phi between the two images used for autoindexing
# The higher , the better. The values should not be set in the script, move to beamline properties (autoindex_diff)

while ($isAutoindexOK == 0)

    $WEBICE_SCRIPT_DIR/PROCESS/wait_for_image.csh $firstimage $autoindexDiff
    if ($status == 1) exit 
    set lastimage = `awk '/lastimage/{print substr($0, 11);}' process.properties` 

    # Autoindex two images. Results will be in /data/$USER/webice/autoindex/$runName

    set imageRootName = ${imageName}_${runLabel}
    if ($expType == MAD) set imageRootName = ${imageRootName}_E1  #autoindex with the first energy


    $WEBICE_SCRIPT_DIR/PROCESS/run_autoindex.csh $runName $imageDir $imageRootName $firstimage $lastimage $imgExt 

sleep 100 # wait for autoindex results; there must be a better way to do this...

	
    set labelit_error = (`cat $autoindexDir/labelit.out | awk 'BEGIN{ err = ""; found = 0; } /LABELIT Indexing results/{ found = 1; } { if (found == 0) { err = $0; }}  END{ if (found == 1) {print err;}}'`)
    if ("$labelit_error" != "") then
	# If labelit has an error, try a different image number, with a larger autoindexDiff values.
	echo `date +"%T"` "Autoindexing failed: $labelit_error . Trying again with a different image"
	set autoindexDiff =`echo "$autoindexDiff + 5 "| bc`
     else
        ln -snf $autoindexDir .
	echo `date +"%T"` "Linked to LABELIT results"
	set isAutoindexOK = 1
   endif #$labelit_error" != ""

end #isAutoindexOK

##########################################################
# Integrate: 
# Generate and execute integrating file (mosflm or XDS)
###########################################################

integration:

@ iteration = 1

#use 10 as an ireration limit for tests
while ($iteration < 10 )

#if using mosflm:

$WEBICE_SCRIPT_DIR/PROCESS/run_integrate_mosflm.csh $iteration
if ($status == 1 ) then 
    break

##########################################################
# Scale : 
# Generate and execute scale file (if integration worked)
###########################################################
else 
    if ($status == 0) then
	$WEBICE_SCRIPT_DIR/PROCESS/run_scale_scala.csh $iteration

    endif

endif

@ iteration++
end


#set stopFile = "stop.txt"
#while (! -e $stopFile)
#sleep 5
#echo `date +"%T"` " Processing data"
#end

echo `date +"%T"` " Finished processing data"
