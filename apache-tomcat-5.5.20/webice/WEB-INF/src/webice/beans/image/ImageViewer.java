/**
 * Javabean for SMB resources
 */
package webice.beans.image;

import webice.beans.*;
import java.net.*;
import java.io.*;
import java.util.*;
import java.text.*;

/**
 * @class ImageViewer
 * Bean class that represents an image viewer. Holds parameters for setting
 * up a display for the image.
 */
public class ImageViewer implements PropertyListener
{

	protected Client client = null;

	public static String SHOW_IMAGE_ONLY =    "DisplayImage";
	public static String SHOW_ANALYSE_IMAGE = "AnalyzeImage";

	public static String TAB_HEADER = "header";
	public static String TAB_ANALYSE = "spotfinder";
	public static String TAB_STATISTICS = "statistics";
	public static String TAB_CRYSTAL = "crystal";


	private FileBrowser fileBrowser = null;

	private String impServerHost = null;
	private int impServerPort = 0;
	private String spotServerHost = null;
	private int spotServerPort = 0;
	private String imgServerHost = null;
	private int imgServerPort = 0;
	

	/**
	 * Image file being displayed
	 */
	private String defImageFile = "";
	private String currentImageFile = "";

	/**
	 * Directory containing images. Used by file browser.
	 */
	private String  defImageDir = "";

	/**
	 * Flag indicating whether we use the global image dir or not.
	 */
	private boolean  defUseGlobalImageDir = true;

	/**
	 * Center of the displayed image on X axis, where x runs from 0.0 - 1.0.
	 */
	private double  defCenterX = 0.5;


	/**
	 * Center of the displayed image on X axis, where x runs from 0.0 - 1.0.
	 */
	private double  defCenterY = 0.5;

	/**
	 * Brightness scale, the larger the number the brighter the image.
	 */
	private int  defGray = 400;

	/**
	 * Zooming factor, running from (0.0 - 1.0]. Value 1.0 is full size (no zoom).
	 */
	private double  defZoom = 1.0;

	/**
	 * Width of the image in pixels.
	 */
	private int  defWidth = 400;

	/**
	 * Height of the image in pixels.
	 */
	private int  defHeight = 400;

	/**
	 */
	private boolean defUseGlabalImageDir = true;


	/**
	 * List of width of the image (image is square).
	 */
	private int[] sizeList = null;

	/**
	 */
	private String infoTab = TAB_HEADER;

	/**
	 * Whether or not to show spots found by spot finder
	 */
	private boolean defShowSpots = false;

	/**
	 * Image parameters used to calculate image resolution
	 */
	private ImageHeader imageHeader = new ImageHeader();

	private String headerString = "";

	protected String viewerName = "image";


	/**
	 * Directory where images generated by spot finder reside
	 */
	private String workDir = "";

	/**
	 * Info from log file generated by spot finder
	 */
	private String spotInfo = "";
	
	// Automatically analyze every loaded image
	private boolean defAutoAnalyzeImage = true;

	/**
	 * Bean constructor
	 */
	public ImageViewer()
		throws Exception
	{
		// do not call init here.
	}

	/**
	 * Constructor
	 */
	public ImageViewer(Client c)
		throws Exception
	{
		this.client = c;

		init();
	}

	/**
	 * Constructor
	 */
	public ImageViewer(String name)
		throws Exception
	{
		viewerName = name;

		init();
	}

	/**
	 * Constructor
	 */
	public ImageViewer(String name, Client c)
		throws Exception
	{
		client = c;
		viewerName = name;

		init();
	}


	/**
	 * Initializes variables
	 */
	protected void init()
		throws Exception
	{

		setDefaultProperties();
		WebiceLogger.info("Initializing ImageViewer for user " + client.getUser());

		if (isUseGlobalImageDir())
			fileBrowser = client.getFileBrowser();
		else
			fileBrowser = new FileBrowser(client);
		WebiceLogger.info("ImageViewer created file browser for user " + client.getUser());

		impServerHost = ServerConfig.getImpServerHost();
		impServerPort = ServerConfig.getImpServerPort();
		imgServerHost = ServerConfig.getImgServerHost();
		imgServerPort = ServerConfig.getImgServerPort();
		spotServerHost = ServerConfig.getSpotServerHost();
		spotServerPort = ServerConfig.getSpotServerPort();

		sizeList = new int[6];

		sizeList[0] = 200;
		sizeList[1] = 300;
		sizeList[2] = 400;
		sizeList[3] = 500;
		sizeList[4] = 600;
		sizeList[5] = 700;

		if (!client.getImperson().dirExists(getWorkDir()))
			client.getImperson().createDirectory(getWorkDir());

		WebiceLogger.info("ImageViewer checked dir " + getWorkDir() + " for user " + client.getUser());
		WebiceLogger.info("ImageViewer loading image header " + getImageFile() + " for user " + client.getUser());

		try {

		// Load image header if image file
		// is set in config.
		// Need to do this so that we have
		// header info for calculating
		// resolution when mouse move
		// inside the jpg.
		if (getImageFile().length() > 0)
			loadHeaderString();

		WebiceLogger.info("ImageViewer loaded image header " + getImageFile() + " for user " + client.getUser());

		} catch (Exception e) {
			// Ignore if we can't load header
			// The image in the preference (image.imageFile)
			// may not exist.
			WebiceLogger.warn("ImageViewer failed to load image " + getImageFile() + ": " + e.getMessage());
		}
	}

	public String getWorkDir()
	{
		return client.getWorkDir() + "/" + viewerName;
	}

	/**
	 * Set default config for this viewer
	 */
	private void setDefaultProperties()
	{
		defImageFile = "";
		defImageDir = "";

		if (client != null)
			defImageDir = client.getImageDir();

		defZoom = 1.0;
		defGray = 400;
		defCenterX = 0.5;
		defCenterY = 0.5;
		defWidth = 400;
		defHeight = 400;

		defUseGlabalImageDir = true;

	}

	/**
	 * Called after the property value has changed
	 */
	public void propertyChanged(String name, String val)
		throws Exception
	{
		// Work dir has changed
		if (name.equals("top.workDir")) {
			if (!client.getImperson().dirExists(getWorkDir()))
				client.getImperson().createDirectory(getWorkDir());
		} else if (name.equals("top.imageDir") && isUseGlobalImageDir()) {
			setImageDir(val);

		} else if (name.equals(getViewerName() + ".useGlobalImageDir")) {
			if (isUseGlobalImageDir())
				fileBrowser = client.getFileBrowser();
			else if (fileBrowser == client.getFileBrowser())
				fileBrowser = new FileBrowser(client);
		}
	}

	/**
	 * Set the client
	 */
	public void setClient(Client c)
	{
		client = c;
	}


	/**
	 * Set method for imageFile
	 * @param dir Image file
	 */
	public void setImageFile(String file)
		throws Exception
	{

		spotInfo = "";
		
		file = file.trim();
		

		// If the dir of this file path
		// is not the same as the current dir
		// then change dir.
		int pos = file.lastIndexOf('/');
		
		if (pos > 0) {

			// Check if the entered path is a directory
			if (file.endsWith("/")) {
				setImageDir(file.substring(0, pos));
				file = "";
			} else {
				// Check if the file contains a file extension
				// expect image fiele to have a file extension.
				int pos2 = file.indexOf(".", pos);
				// The entered path is not an image file
				// assume that it is a directory
				if (pos2 < 0) {
					setImageDir(file);
					file = "";
				} else {
					String d = file.substring(0, pos);
					if ((d.length() > 0) && !d.equals(getImageDir())) {
						// Change dir of image viewer
						setImageDir(d);
					}
				}
			}


		}

		client.getProperties().setProperty(getViewerName() + ".imageFile", file);

		// Load header for this image
		loadHeaderString();
		
		// Untick "Show spot overlay" tick box.
		if (!isAutoAnalyzeImage())
			setShowSpots(false);
		
		// Automatically analyze the image
		// or load existing results
		if (isShowSpots() || getInfoTab().equals(TAB_ANALYSE))
			findSpots(isAutoAnalyzeImage());
			
		currentImageFile = file;
	}
	
	public boolean isAutoAnalyzeImage()
	{
		return client.getProperties().getPropertyBoolean(getViewerName() + ".autoAnalyzeImage", defAutoAnalyzeImage);
	}
	
	public void setAutoAnalyzeImage(boolean s)
	{
		client.getProperties().setProperty(getViewerName() + ".autoAnalyzeImage", s);
	}
	
	public boolean getShowSpots()
	{
		return isShowSpots();
	}
	
	public boolean isShowSpots()
	{
		return client.getProperties().getPropertyBoolean(getViewerName() + ".showSpots", defShowSpots);
	}

	/**
	 * Get method for imageFile
	 * @return Image file
	 */
	public String getImageFile()
	{
		return client.getProperties().getProperty(getViewerName() + ".imageFile", defImageFile);
	}
	
	/**
	 */
	public ImageHeader getImageHeader()
	{
		return imageHeader;
	}
	
	public String getSpotFile()
	{
		return getSpotFile(true);
	}

	/**
	 * Get file name of image generated by spot finder
	 * for the current image
	 */
	synchronized private String getSpotFile(boolean sync)
	{
		String file = getImageFile();
			
		if (sync) {	
		try {	
		
		if (!file.equals(currentImageFile))
			setImageFile(file);
			
		} catch (Exception e) {
			WebiceLogger.error("Failed in getSpotFile: currently loaded image = " 
					+ currentImageFile + " new image = " + file
					+ " because " + e.getMessage());
		}
		
		}


		// Spot image file is in spot dir
		int pos = file.lastIndexOf('/');
		// Find file extension
		String ret = getSpotDir() + "/";
		String f = "";
		if (pos < 0) {
			f = file;
		} else {
			f = file.substring(pos+1);
		}

		int pos2 = f.lastIndexOf('.');
		if (pos2 < 0) {
			ret += f + ".spt";
		} else {
			// spot file always has .spt.img extension
			ret += f.substring(0, pos2)
					+ ".spt.img";
		}

		return ret;
	}
	
	public String getPredictionFile()
	{
		return getSpotFile();
	}


	/**
	 * Get file name of the jpeg file
	 * for the crystal snapshot.
	 */
	public String getCrystalJpegUrl()
	{
		try {

		String file = getImageFile();

		// Spot image file is in spot dir
		int pos = file.lastIndexOf('/');
		// Find file extension
		String ret = getSpotDir() + "/";
		String f = "";
		String d = "";
		if (pos < 0) {
			f = file;
			d = "";
		} else {
			f = file.substring(pos+1);
			d = file.substring(0, pos);
		}

		String jpeg = "";
		int pos1 = f.lastIndexOf('_');
		if (pos1 < 0)
			return "";
			
		int pos2 = f.indexOf('.', pos1);
		if (pos2 < 0)
			return "";

		jpeg = f.substring(0, pos1) + "*" + f.substring(pos1, pos2) + ".jpg";

		TreeMap files = new TreeMap();
		client.getImperson().listDirectory(d, jpeg, null, files);
		if (files.size() == 0)
			return "";

		jpeg = (String)files.firstKey();

		String url = "servlet/loader/readJpegFile?impFilePath=" + d + "/" + jpeg;


		return url;

		} catch (Exception e) {
			WebiceLogger.error("Error in getCrystalCrystalJpegUrl: listDirectory failed because "
								+ e.getMessage());
			return "";
		}
	}


	/**
	 * Get log file generated by spot finder
	 * for the current image
	 */
	public String getSpotLogFile()
	{

		String file = getImageFile();

		// Spot image file is in spot dir
		int pos = file.lastIndexOf('/');
		// Find file extension
		String ret = getSpotDir() + "/";
		String f = "";
		if (pos < 0) {
			f = file;
		} else {
			f = file.substring(pos+1);
		}

		int pos2 = f.lastIndexOf('.');
		if (pos2 < 0) {
			ret += f + ".log";
		} else {
			ret += f.substring(0, pos2) + ".log";
		}

		return ret;
	}

	/**
	 * Get method for imageUrl
	 * @return Image url for the image server.
	 */
	public String getImageUrl()
	{
		return getUrl(getImageFile(), "full");
	}
	/**
	 * Get method for thumbnailUrl
	 * @return Thumbnail url for the image server.
	 */
	public String getThumbnailUrl()
	{
		return getUrl(getImageFile(), "thumb");
	}

	/**
	 * Get method for thumbnailUrl
	 * @return Thumbnail url for the image server.
	 */
	public String getSpotImageUrl()
	{
		return getUrl(getSpotFile(), "full");
	}

	/**
	 * Get method for thumbnailUrl
	 * @return Thumbnail url for the image server.
	 */
	public String getSpotThumbnailUrl()
	{
		return getUrl(getSpotFile(), "thumb");
	}
	
	public String getPredictionImageUrl()
	{
		return getUrl(getPredictionFile(), "full");
	}
	
	public String getPredictionThumbnailUrl()
	{
		return getUrl(getPredictionFile(), "thumb");
	}

	/**
	 * Get url for imgsrv
	 * @param file File path of the image
	 * @param type Output image type: thumb or full
	 */
	public String getUrl(String file, String type)
	{
		String command = "getImage";
		if (type.equals("thumb")) {
			command = "getThumbnail";
		}

		// userName and sessionId param will be added by the servlet.
		String url = "servlet/loader/" + command + "?fileName=" + file
					+ "&sizeX=" + String.valueOf(getWidth())
					+ "&sizeY=" + String.valueOf(getHeight())
					+ "&percentX=" + String.valueOf(getCenterX())
					+ "&percentY=" + String.valueOf(getCenterY())
					+ "&gray=" + String.valueOf(getGray())
					+ "&zoom=" + String.valueOf(getZoom());

		return url;
	}

	/**
	 */
	public String getHeaderString()
		throws Exception
	{
		return headerString;
	}


	/**
	 * Get method for retrieving image header string from image server
	 * @return Image header string.
	 */
/*	protected void loadHeaderStringUsingHttp()
		throws Exception
	{
		headerString = "";
		imageHeader = null;

		imageHeader = new ImageHeader();

		try {

		String file = getImageFile();
		if (file.length() == 0)
			return;
			
		String oneTimeSessionId = client.getOneTimeSession(impServerHost);

		String urlStr = "http://" + imgServerHost + ":" + String.valueOf(imgServerPort)
					+ "/getHeader?fileName=" + file
					+ "&userName=" + client.getUser()
					+ "&sessionId=" + oneTimeSessionId;



		URL url = new URL(urlStr);

		HttpURLConnection con = (HttpURLConnection)url.openConnection();
		con.setConnectTimeout(10*1000); // timeout after 10 seconds.
		con.setRequestMethod("GET");
//		WebiceLogger.info("Loading image header from URL " + urlStr);
		int response = con.getResponseCode();
//		WebiceLogger.info("Got response " + response + " from imgsrv");
		if (response != 200)
			throw new Exception("getHeaderString failed: imgsrv returns "
						+ String.valueOf(response) + " " + con.getResponseMessage()
						+ " (for " + urlStr + ")");

		BufferedReader reader = new BufferedReader(new InputStreamReader(con.getInputStream()));


		headerString = "";
		String line = null;
		Vector headerVec = new Vector();
		while ((line=reader.readLine()) != null) {
			headerString += line + "\n";
			headerVec.add(line);
		}

		reader.close();
		con.disconnect();


		imageHeader.parse(headerVec);

		} catch (Exception e) {
			headerString = "Error: " + e.toString();
		}

	}
*/	
	// Load header from image server so that staff can always look at 
	// any images even without file permissions. 
	// Read image header from image server using socket instead of http class
	// so that we can set timeout on read in case the image server hangs.
	protected void loadHeaderString()
		throws Exception
	{
		headerString = "";
		imageHeader = null;

		imageHeader = new ImageHeader();

		try {

		String file = getImageFile();
		if (file.length() == 0)
			return;
			
		String oneTimeSessionId = client.getOneTimeSession(impServerHost);

		String urlStr = "/getHeader?fileName=" + file
				+ "&userName=" + client.getUser()
				+ "&sessionId=" + oneTimeSessionId;
		String httpStr = "GET " + urlStr + " HTTP/1.1\n"
				+ "Host: " + imgServerHost + ":" + String.valueOf(imgServerPort) + "\n"
				+ "Connection: close\n\n";

		Socket sock = new Socket(imgServerHost, imgServerPort);
		sock.setSoTimeout(10000); // wait on read for 10 seconds before giving up.
		OutputStream out = sock.getOutputStream();
		out.write(httpStr.getBytes());
		out.flush();
		sock.shutdownOutput();
		
		BufferedReader reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));

		headerString = "";
		String line = reader.readLine();
		if (!line.startsWith("HTTP/1.1 200 OK")) {
			sock.close();
			throw new Exception("getHeaderString failed: imgsrv returns " + line + " (for " + urlStr + ")");
		}
		
		// Read response header
		while ((line=reader.readLine()) != null) {
			if (line.trim().length() == 0)
				break;
		}
		
		Vector headerVec = new Vector();
		// Read response body
		while ((line=reader.readLine()) != null) {
			headerString += line + "\n";
			headerVec.add(line);
		}

		reader.close();
		sock.close();


		imageHeader.parse(headerVec);

		} catch (Exception e) {
			headerString = "Error: " + e.getMessage();
		}

	}
	
	// Load header string from imperson daemon.
	// Use socket instead of http so that we can set read timeout in case
	// the image server hangs. 
	private void loadHeaderStringFromImperson()
		throws Exception
	{
		headerString = "";
		imageHeader = null;

		imageHeader = new ImageHeader();

		try {

		String file = getImageFile();
		if (file.length() == 0)
			return;
			
		String oneTimeSessionId = client.getOneTimeSession(impServerHost);

		String commandline = ServerConfig.getImgsrvCommand() + " " + file;
		String urlStr = "/runScript";
		String httpStr = "GET " + urlStr + " HTTP/1.1\n"
				+ "Host: " + ServerConfig.getImgsrvCommandHost() + ":" + String.valueOf(ServerConfig.getImgsrvCommandPort())
				+ "impShell: /bin/tcsh\n"
				+ "impCommandLine: " + commandline + "\n"
				+ "impUser: " + client.getUser() + "\n"
				+ "impEnv1: " + "HOME=" + client.getUserConfigDir() + "\n"
				+ "impSessionID: " + oneTimeSessionId + "\n\n";				
		
		WebiceLogger.info("getImageHeader URL: " + urlStr + "?impCommandLine" + commandline);
			
		Socket sock = new Socket(ServerConfig.getImgsrvCommandHost(), ServerConfig.getImgsrvCommandPort());
		sock.setSoTimeout(10000); // wait on read for 10 seconds before giving up.
	
		// Send request
		OutputStream out = sock.getOutputStream();
		out.write(httpStr.getBytes());
		out.flush();
		sock.shutdownOutput();

		BufferedReader reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));
		String line = reader.readLine();
		if (!line.startsWith("HTTP/1.1 200 OK")) {
			WebiceLogger.error("Image server returns error: " + line);
			sock.close();
			throw new Exception(line);
		}
		
		// Read response header
		while ((line=reader.readLine()) != null) {
			if (line.trim().length() == 0)
				break;
		}
		
		// Read response body
		Vector headerVec = new Vector();
		// Read response body
		while ((line=reader.readLine()) != null) {
			headerString += line + "\n";
			headerVec.add(line);
		}
		
		reader.close();
		sock.close();
						
		imageHeader.parse(headerVec);
				
		} catch (Exception e) {
			headerString = "Error: " + e.getMessage();
		}

		
	}
	

	/**
	 * Get method for retrieving image header string from image server
	 * @return Image header string.
	 */
	public String getSpotInfo()
	{
		return spotInfo;
	}

	/**
	 */
	protected void setSpotInfo(String i)
	{
		spotInfo = i;

		if (spotInfo == null)
			spotInfo = "";
	}


	/**
	 * Set method for centerX
	 * @param x New value for center x. Must be between 0.0 - 1.0
	 */
	public void setCenterX(double x)
	{
		client.getProperties().setProperty(getViewerName() + ".centerX", x);
	}

	/**
	 * Get method for centerX
	 * @return Center x value
	 */
	public double getCenterX()
	{
		return client.getProperties().getPropertyDouble(getViewerName() + ".centerX", defCenterX);
	}


	/**
	 * Set method for centerY
	 * @param y New value for center x. Must be between 0.0 - 1.0
	 */
	public void setCenterY(double y)
	{
		client.getProperties().setProperty(getViewerName() + ".centerY", y);
	}

	/**
	 * Get method for centerY
	 * @return Center y value
	 */
	public double getCenterY()
	{
		return client.getProperties().getPropertyDouble(getViewerName() + ".centerY", defCenterY);
	}


	/**
	 * Set method for gray
	 * @param g New gray value. Should be around 100-500
	 */
	public void setGray(int g)
	{
		if (g <= 0)
			return;

		client.getProperties().setProperty(getViewerName() + ".gray", g);
	}

	/**
	 * Get method for gray
	 * @return gray value
	 */
	public int getGray()
	{
		return client.getProperties().getPropertyInt(getViewerName() + ".gray", defGray);
	}

	/**
	 * Set method for zoom
	 * @param z New value for zoom. Must be between >= 1.0
	 */
	public void setZoom(double z)
	{
		if (z < 1.0)
			z = 1.0;

		if (z > 200.0)
			z = 200.0;

		client.getProperties().setProperty(getViewerName() + ".zoom", z);

	}

	/**
	 * Get method for zoom
	 * @return zoom value
	 */
	public double getZoom()
	{
		return client.getProperties().getPropertyDouble(getViewerName() + ".zoom", defZoom);
	}

	/**
	 * Set method for width
	 * @param w New width. Must be > 0
	 */
	public void setWidth(int w)
	{
		if (w <= 0)
			return;

		client.getProperties().setProperty(getViewerName() + ".width", w);
	}

	/**
	 * Get method for width
	 * @return gray value
	 */
	public int getWidth()
	{
		return client.getProperties().getPropertyInt(getViewerName() + ".width", defWidth);
	}

	/**
	 * Set method for height
	 * @param h New height. Must be > 0
	 */
	public void setHeight(int h)
	{
		if (h <= 0)
			return;

		client.getProperties().setProperty(getViewerName() + ".height", h);
	}
	
	public void setImageSize(int w, int h)
	{
		setWidth(w);
		setHeight(h);
		
		try {
			client.saveProperties();
		} catch (Exception e) {
			// Ignore error
			WebiceLogger.warn("in ImageViewer setImageSize: failed to save properties file because " + e.getMessage());
		}
	}

	/**
	 * Get method for width
	 * @return gray value
	 */
	public int getHeight()
	{
		return client.getProperties().getPropertyInt(getViewerName() + ".height", defHeight);
	}


	/**
	 * Set method for sizeList
	 * @param s New size list. Must not be null.
	 */
	public void setSizeList(int[] s)
	{
		if (s == null)
			return;

		sizeList = s;
	}

	/**
	 * Get method for width
	 * @return gray value
	 */
	public int[] getSizeList()
	{
		return sizeList;
	}

	public boolean isUseGlobalImageDir()
	{
		return client.getProperties().getPropertyBoolean(
						getViewerName() + ".useGlabalImageDir",
						defUseGlabalImageDir);
	}

	public void setImageDir(String s)
	{
		client.getProperties().setProperty(getViewerName() + ".imageDir", s);
		if (!s.equals(client.getImageDir()) && isUseGlobalImageDir()) {
			client.setImageDir(s);
			try {
				client.saveProperties();
			} catch (Exception e) {
				// Ignore error.
				WebiceLogger.warn("in ImageViewer setImageDir: failed to save properties file because " + e.getMessage());
			}
		}

	}

	public String getImageDir()
	{
		if (isUseGlobalImageDir())
			return client.getImageDir();

		return client.getProperties().getProperty(getViewerName() + ".imageDir", defImageDir);
	}

	/***************************************************************
	 ***************************************************************/

	/**
	 * Pan the image up by p units.
	 * Method that can be called from JSP
	 * @param p Distance to pan scale from 0.0-1.0
	 */
	public void setPanUp(double p)
	{
		double newval = getCenterY() - p;

		setCenterY(newval);

	}

	/**
	 * Pan the image down by p units.
	 * Method that can be called from JSP
	 * @param p Distance to pan scale from 0.0-1.0
	 */
	public void setPanDown(double p)
	{
		double newval = getCenterY() + p;

		setCenterY(newval);
	}

	/**
	 * Pan the image left by p units.
	 * Method that can be called from JSP
	 * @param p Distance to pan scale from 0.0-1.0
	 */
	public void setPanLeft(double p)
	{
		double newval = getCenterX() - p;

		setCenterX(newval);
	}

	/**
	 * Pan the image right by p units.
	 * Method that can be called from JSP
	 * @param p Distance to pan scale from 0.0-1.0
	 */
	public void setPanRight(double p)
	{
		double newval = getCenterX() + p;

		setCenterX(newval);
	}

	/**
	 * Reset the display center to the center of the image.
	 * Method that can be called from JSP
	 */
	public void setCenter()
	{
		setCenterX(0.5);
		setCenterY(0.5);
	}

	/**
	 * Set display center for the image to a new location passed in as a string.
	 * @param s Location string in x,y format, where x and y are in pixel.
	 */
	public void setCenterStr(String s)
	{
		// Center x and y in pixel separated by comma
		try {

			if (s == null)
				return;

			double oldCenterX = getCenterX();
			double oldCenterY = getCenterY();


			int pos = s.indexOf(',');

			if (pos < 0)
				return;

			double pixelX = (double)Integer.parseInt(s.substring(0, pos));
			double pixelY = (double)Integer.parseInt(s.substring(pos+1));

			int w = getWidth();
			int h = getHeight();
			double z = getZoom();
			setCenterX(oldCenterX - (w/2.0 - pixelX)/(w*z));
			setCenterY(oldCenterY - (h/2.0 - pixelY)/(h*z));

		} catch (NumberFormatException e) {
		}
	}

	/**
	 * Set display center for the thumbnail to a new location passed in as a string.
	 * @param s Location string in x,y format, where x and y are in pixel.
	 */
	public void setThumbnailCenterStr(String s)
	{
		// Center x and y in pixel separated by comma
		try {

			if (s == null)
				return;


			int pos = s.indexOf(',');

			if (pos < 0)
				return;

			double pixelX = (double)Integer.parseInt(s.substring(0, pos));
			double pixelY = (double)Integer.parseInt(s.substring(pos+1));


			double thumbwidth = 128;
			double thumbheight = 128;

			setCenterX(0.5 - (thumbwidth/2.0 - pixelX)/(thumbwidth));
			setCenterY(0.5 - (thumbheight/2.0 - pixelY)/(thumbheight));

		} catch (NumberFormatException e) {
		}
	}


	/**
	 * Zoom in the image by the given amount
	 * @param zoomBy How much to zoom in by.
	 */
	public void setZoomIn(double zoomBy)
	{
		if (zoomBy > 0.0) {
			double newval = getZoom()*zoomBy;
			setZoom(newval);
		}

	}

	/**
	 * Zoom out the image by the given amount
	 * @param zoomBy How much to zoom out by.
	 */
	public void setZoomOut(double zoomBy)
	{
		if (zoomBy > 0.0) {
			double newval = getZoom()/zoomBy;
			setZoom(newval);
		}
	}

	/**
	 * Set increase gray scale by the given amount so that the image lighter.
	 * @param g How much to to increase the gray scale.
	 */
	public void setLighter(int g)
	{
		int newval = getGray() + g;
		setGray(newval);
	}

	/**
	 * Set reduce gray scale by the given amount so that the image darker.
	 * @param g How much to to reduce the gray scale.
	 */
	public void setDarker(int g)
	{
		int newval = getGray() - g;

		if (newval < 0)
			newval = 0;
		setGray(newval);
	}

	public void setInfoTab(String tab)
	{
		if (tab == null)
			return;
			
		infoTab = tab;
			
		// Check if tab is Spot Summay
		// Automatically run spotfinder
		// and load spot info
		// if autoAnalyzeImage is on.
		if (tab.equals(TAB_ANALYSE)) {
			setShowSpots(isAutoAnalyzeImage());
//			findSpots(isAutoAnalyzeImage());
		}
	}

	public String getInfoTab()
	{
		return infoTab;
	}

	public void setShowSpots(boolean s)
	{
		if (isShowSpots() == s)
			return;

		client.getProperties().setProperty(getViewerName() + ".showSpots", s);
		
		if (isShowSpots())
			findSpots(isAutoAnalyzeImage());

	}
	
	public void analyzeImage()
	{
		client.getProperties().setProperty(getViewerName() + ".showSpots", true);
		
		findSpots(true);
	}
	

	public String getSpotDir()
	{
		return getWorkDir();
	}


	/**
	 */
	protected void findSpots(boolean autoAnalyze)
	{

		try {

			boolean stale = true;

			// See if spot file and log file exist and are newer than the
			// orginal image file
			Hashtable spotFileStatus = getFileStatus(getSpotFile(false));
			if (spotFileStatus != null) {

				Hashtable imageFileStatus = getFileStatus(getImageFile());

				if (imageFileStatus != null) {

					String tmp1 = (String)spotFileStatus.get("impFileMtime");
					String tmp2 = (String)imageFileStatus.get("impFileMtime");

					SimpleDateFormat formatter = new SimpleDateFormat("EEE MMM d HH:mm:ss yyyy");

					if (formatter.parse(tmp1).after(formatter.parse(tmp2))) {
						stale = false;
					}

				}

			}
			
			if (!stale) {

				if (spotInfo.length() != 0)
					return;

				// loadSpotInfo returns image filepath
				// for which the spot info was generated.
				String spotInfoImageFile = loadSpotInfo();
				// Compare this filepath to our image filepath
				// and make sure that they refer to the same file.
				if (spotInfoImageFile.equals(getImageFile()))
					return;
			}

			// If file does not exist or is older then create a new one
			// Then run spot finder
			if (autoAnalyze)
				runSpotFinder();


		} catch (Exception e) {
			spotInfo += "findSpots failed: " + e.getMessage() + "\n";
		}

	}

	/**
	 * Get status of a remote file
	 */
	protected Hashtable getFileStatus(String file)
	{
		try {
		
		String oneTimeSession = client.getOneTimeSession(impServerHost);
		String urlStr = "http://" + impServerHost + ":" + String.valueOf(impServerPort)
						+ "/getFileStatus?impFilePath=" + file
						+ "&impUser=" + client.getUser()
						+ "&impSessionID=" + oneTimeSession;

		URL url = new URL(urlStr);

		HttpURLConnection con = (HttpURLConnection)url.openConnection();

		con.setRequestMethod("GET");

		int response = con.getResponseCode();
		if (response != 200)
			return null;
			
//		if (!client.getImperson().fileExists(file))
//			return null;
		

		BufferedReader reader = new BufferedReader(new InputStreamReader(con.getInputStream()));

		Hashtable ret = new Hashtable();
		int pos = 0;
		String line = null;
		while ((line=reader.readLine()) != null) {
			pos = line.indexOf('=');
			if (pos >=0)
				ret.put(line.substring(0, pos), line.substring(pos+1));
		}

		reader.close();
		con.disconnect();

		return ret;

		} catch (Exception e) {
			spotInfo += "getFileStatus failed: " + e.getMessage() + "\n";
			return null;
		}

	}

	/**
	 * Run spot finder script remotely via the impersonation server on decunix
	 */
	private void runSpotFinder()
		throws Exception
	{
		if (getImageFile().trim().length() == 0)
			return;
		WebiceLogger.info("User " + client.getUser() + " running spotfinder for image " + getImageFile());
		
		spotInfo = "";

		String oneTimeSession = client.getOneTimeSession(spotServerHost);
		String urlStr = "http://" + spotServerHost + ":" + String.valueOf(spotServerPort)
						+ "/runScript?impShell=/bin/tcsh"
						+ "&impCommandLine=" +  ServerConfig.getScriptDir() + "/run_spotfinder.sh"
						+ "%20" + getImageFile()
						+ "&impEnv1=SPOTBIN%3D" + ServerConfig.getBinDir()
						+ "&impEnv2=SPOTWORK%3D" + getSpotDir()
						+ "&impUser=" + client.getUser()
						+ "&impSessionID=" + oneTimeSession;

		spotInfo += urlStr + "\n";

		URL url = new URL(urlStr);

		HttpURLConnection con = (HttpURLConnection)url.openConnection();

		con.setRequestMethod("GET");

		int response = con.getResponseCode();
		if (response != 200)
			throw new Exception("runSpotFinder failed: impserson server returns "
						+ String.valueOf(response) + " " + con.getResponseMessage()
						+ " (for " + urlStr + ")");

		spotInfo += response + " " + con.getResponseMessage() + "\n";

		BufferedReader reader = new BufferedReader(new InputStreamReader(con.getInputStream()));

		String line = null;
		while ((line=reader.readLine()) != null) {
			spotInfo += line + "\n";			
		}
		
		reader.close();
		con.disconnect();

		loadSpotInfo();

	}


	/**
	 */
	protected String loadSpotInfo()
		throws Exception
	{
		String spotInfoImageFile = "";
		try {
			spotInfo = client.getImperson().readFile(getSpotLogFile());
		} catch (Exception e) {
			spotInfo += e.getMessage();
			return spotInfoImageFile;
		}

		StringTokenizer tok = new StringTokenizer(spotInfo, "\n");
		if (tok.countTokens() == 0)
			return spotInfoImageFile;
			
		String line = null;

		// read first line
		spotInfoImageFile = tok.nextToken();

		// Read the rest in the log file
		while (tok.hasMoreTokens()) {
			line = tok.nextToken();
			
			if (ServerConfig.isNewSpotfinderVersion()) {
				spotInfo += line + "\n";
			} else {

			int pos = -1;

			if (line.endsWith("# number of spots")) {
				pos = line.indexOf("#");
				if (pos > 0) {
					spotInfo += "Number of spots                    " + line.substring(6, pos) + "\n";
					continue;
				}
			}

			pos = line.indexOf("# number of spots with overloaded pixels");
			if (pos > 0) {
				spotInfo += "Number of spots w/overloaded pixels" + line.substring(6, pos) + "\n";
				continue;
			}

			pos = line.indexOf("# ellipoid spot shape, mean");
			if (pos > 0) {
				spotInfo += "Spot shape                         " + line.substring(6, pos) + "\n";
				continue;
			}

			pos = line.indexOf("# resolution boundary by Method 2");
			if (pos > 0) {
				spotInfo += "Estimated resolution               " + line.substring(6, pos) + "\n";
				continue;
			}

			pos = line.indexOf("# number of ice-rings");
			if (pos > 0) {
				spotInfo += "Number of ice rings                " + line.substring(6, pos) + "\n";
				continue;
			}

			pos = line.indexOf("# composite score");
			if (pos > 0) {
				spotInfo += "Score                              " + line.substring(6, pos) + "\n";
				continue;
			}

			pos = line.indexOf("# average spot intensity");
			if (pos > 0) {
				spotInfo += "Diffraction strength               " + line.substring(6, pos) + "\n";
				continue;
			}
			
			} // if isNewSpotfinderVersion

		}

		return spotInfoImageFile;

	}

	/**
	 */
	protected String loadSpotInfo_saved()
		throws Exception
	{

		// Read the log file generated by the
		// spot finder program
		String oneTimeSession = client.getOneTimeSession(impServerHost);
		String urlStr = "http://" + impServerHost + ":" + String.valueOf(impServerPort)
					+ "/readFile?impFilePath=" + getSpotLogFile()
					+ "&impUser=" + client.getUser()
					+ "&impSessionID=" + oneTimeSession;


		URL url = new URL(urlStr);

		HttpURLConnection con = (HttpURLConnection)url.openConnection();

		con.setRequestMethod("GET");

		int response = con.getResponseCode();
		if (response != 200) {
			spotInfo += "getSpotInfo failed: imperson server returns "
						+ String.valueOf(response) + " " + con.getResponseMessage()
						+ " (for " + urlStr + ")\n";
		} else {
			spotInfo = "";
		}
		
		BufferedReader reader = new BufferedReader(new InputStreamReader(con.getInputStream()));

		String line = null;

		// read first line
		String spotInfoImageFile = reader.readLine();
		if (spotInfoImageFile == null)
			spotInfoImageFile = "";

		// Read the rest in the log file
		while ((line=reader.readLine()) != null) {
			
			if (ServerConfig.isNewSpotfinderVersion()) {
				spotInfo += line + "\n";
			} else {

			int pos = -1;

			if (line.endsWith("# number of spots")) {
				pos = line.indexOf("#");
				if (pos > 0) {
					spotInfo += "Number of spots                    " + line.substring(6, pos) + "\n";
					continue;
				}
			}

			pos = line.indexOf("# number of spots with overloaded pixels");
			if (pos > 0) {
				spotInfo += "Number of spots w/overloaded pixels" + line.substring(6, pos) + "\n";
				continue;
			}

			pos = line.indexOf("# ellipoid spot shape, mean");
			if (pos > 0) {
				spotInfo += "Spot shape                         " + line.substring(6, pos) + "\n";
				continue;
			}

			pos = line.indexOf("# resolution boundary by Method 2");
			if (pos > 0) {
				spotInfo += "Estimated resolution               " + line.substring(6, pos) + "\n";
				continue;
			}

			pos = line.indexOf("# number of ice-rings");
			if (pos > 0) {
				spotInfo += "Number of ice rings                " + line.substring(6, pos) + "\n";
				continue;
			}

			pos = line.indexOf("# composite score");
			if (pos > 0) {
				spotInfo += "Score                              " + line.substring(6, pos) + "\n";
				continue;
			}

			pos = line.indexOf("# average spot intensity");
			if (pos > 0) {
				spotInfo += "Diffraction strength               " + line.substring(6, pos) + "\n";
				continue;
			}
			
			} // if isNewSpotfinderVersion

		}

		reader.close();
		con.disconnect();

		return spotInfoImageFile;

	}

	/**
	 * Returns FileBrowser
	 * Used by viewers to get files/dirs
	 */
	public FileBrowser getFileBrowser()
	{
		return fileBrowser;
	}

	/**
	 */
	public String getViewerName()
	{
		return viewerName;
	}

	/**
	 * Can we enable "Last Image" button"
	 */
	public boolean lastImageCollectedEnabled()
	{
		return true;
	}
	
	public boolean analyzeImageEnabled()
	{
		return true;
	}
	
	public boolean prevAndNextEnabled()
	{
		return true;
	}
	
	public boolean fileOpenEnabled()
	{
		return true;
	}
	
	public String getImageFrame()
	{
		return "imgFrame";
	}
	
	public String getImageParentFrame()
	{
		return "imageViewerFrame";
	}
	
	public String getImageGrandParentFrame()
	{
		return "mainFrame";
	}
	
}


