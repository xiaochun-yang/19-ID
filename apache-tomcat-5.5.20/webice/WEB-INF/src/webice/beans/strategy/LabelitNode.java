/**
 * Javabean for SMB resources
 */
package webice.beans.strategy;

import webice.beans.*;
import java.util.*;
import java.io.*;
import javax.xml.parsers.*;
import org.w3c.dom.*;
import java.net.*;

/**
 * @class StrategyViewer
 * Bean class that represents a process viewer. Holds parameters for setting
 * up a display for data processing.
 */
public class LabelitNode extends NavNode
{

	/**
	 * Status names for this node
	 * TODO: should we move this to NavNode?
	 */
	public static int SETUP = 10;
	public static int READY = 20;
	public static int AUTOINDEX_RUNNING = 30;
	public static int AUTOINDEX_FINISH = 40;
	public static int ADDITONAL_INTEGRATION_RUNNING = 50;
	public static int ADDITONAL_INTEGRATION_FINISH = 60;
	public static int FINISH = 0;

	public static String TAB_SETUP = "Setup";
	public static String TAB_SOLUTIONS = "Solutions";
	public static String TAB_AUTOINDEX_SUMMARY = "Autoindex Summary";
	public static String TAB_DETAILS = "Details";
	public static String TAB_PREDICTIONS = "Predictions";

	/**
	 * Type of images to be displayed
	 * for images generated by labelit
	 */
	public static String IMAGE_LABELIT_SPOT = "labelit";
	public static String IMAGE_INDEX_SPOT = "index";
	public static String IMAGE_MOSFLM_SPOT = "mosflm";


	/**
	 * StrategyViewer
	 */
	private StrategyViewer top = null;

	/**
	 * Client
	 */
	private Client client = null;


	/**
	 */
	private String definitionFile = "input.xml";

	/**
	 * Whether or not to show file browser
	 * on the setup viewer for this node
	 */
	private boolean showFileBrowser = false;


	/**
	 * Summary of result of previous run.
	 * This text gets displayed in the
	 * summary viewer of this node
	 */
	private String summary = "";

	/**
	 * File name of image being displayed in
	 * image viewer of this node.
	 * This is the name of the original
	 * image file such as peak_1_001.img.
	 * The actual displayed image is
	 * a png file generated by labelit.
	 * For example, peak_1_001_distl.png
	 * or peak_1_001_index.png. The first one
	 * is displayed if image type is IMAGE_LABELIT_SPOT
	 * and the second for image type IMAGE_INDEX_SPOT.
	 * The first displays spots picked by spotfinder
	 * and the second displays both spots picked by spotfinder
	 * and mosflm's calculated spots.
	 */
	private String image = "";

	/**
	 * Type of image to be displayed.
	 * See comment above.
	 */
	private String imageType = LabelitNode.IMAGE_MOSFLM_SPOT;

	/**
	 * Width of the displayed png image.
	 * Image will be zoomed in or out according to
	 * the display size.
	 */
	private int imageWidth = 700;

	/**
	 * Width of the displayed png image
	 * Image will be zoomed in or out according to
	 * the display size.
	 */
	private int imageHeight = 700;


	/**
	 * List of known files generated by labelit
	 * Hashtable of filename and FileInfo
	 * File names are relative to workDir of
	 * this node
	 */
	private TreeMap resultFiles = new TreeMap();

	/**
	 */
	private String log = "";

	/**
	 */
	private String runLog = "";

	/**
	 */
	private LabelitResult labelitResult = new LabelitResult();

	private boolean aborted = false;

	/**
	 * Current setup data
	 */
	private LabelitSetupData curSetupData = new LabelitSetupData();

	/**
	 * Editable setup data. Used during setup
	 */
	private LabelitSetupData setupData = new LabelitSetupData();

	/**
	 */
	private String laueGroup = "";

	/**
 	 */
	private RunStatus runStatus = new RunStatus();

	/**
	 */
	private boolean setupDone = false;

	/**
	 */
	private boolean hasAutoindexLog = false;

	/**
	 */
	private boolean supportOldVersion = true;

	/**
	 */
	private boolean isLoaded = false;

	/**
	 */
	private boolean labelitDone = false;

	/**
	 */
	private boolean integrationDone = false;

	/**
	 */
	private boolean strategyDone = false;

	/**
	 */
	private boolean autoindexDone = false;


	/**
	 */
	private boolean additionalIntegrationDone = false;

	/**
	 */
	private ImageStats imageStats[] = new ImageStats[2];

	private boolean useApplet = false;

	/**
	 */
	private MonitorThread runMonitor = null;

	/**
	 * Constructor
	 */
	public LabelitNode(String n, NavNode p, StrategyViewer v)
		throws Exception
	{
		super(n, p);

		if (imageStats[0] == null)
			imageStats[0] = new ImageStats();
		if (imageStats[1] == null)
			imageStats[1] = new ImageStats();

		top = v;
		client = top.getClient();

		clearTabs();

		// These are tabs available for this type of node
		addTab(TAB_SETUP);
		addTab(TAB_SOLUTIONS);
		addTab(TAB_AUTOINDEX_SUMMARY);
		addTab(TAB_DETAILS);
		addTab(TAB_PREDICTIONS);

		// Set default tab for this node viewer
		setSelectedTab(TAB_SETUP);

		// Delay loading
		isLoaded = false;

	}

	/**
	 */
	public void finalize()
	{
		if ((runMonitor != null) && runMonitor.isAlive())
			runMonitor.stopMonitoring();
	}


	/**
	 * Load if needed
	 */
	public void load()
		throws Exception
	{
		load(false);
	}

	/**
	 * Force loading
	 */
	private void load(boolean force)
		throws Exception
	{
		if (isLoaded && !force)
			return;

		isLoaded = true;
		hasAutoindexLog = false;
		labelitDone = false;
		integrationDone = false;
		strategyDone = false;
		autoindexDone = false;
		additionalIntegrationDone = false;

		// Load definition file
		// And setup input
		loadSetup();

		// Get run status
		updateRunStatus();

		loadSolutions();

		// Load result from previous run
		loadSummary();

		loadImageStats();

		loadChildren();
	}

	/**
	 */
	public void loadSolutions()
		throws Exception
	{
	}

	/**
	 */
	public void loadDetails()
		throws Exception
	{
		// Clear old results
		resultFiles.clear();

		// Get sub directories
		TreeMap tmpFiles = new TreeMap();
		client.getImperson().listDirectory(
						getWorkDir(),
						null,
						null,
						tmpFiles);


		// Get result files
		Object values[] = tmpFiles.values().toArray();

		// Filter files of the known types
		if (values != null) {
			for (int i = 0; i < values.length; ++i) {
				FileInfo info = (FileInfo)values[i];
				info.type = FileHelper.getFileType(info.name);
				if (info.type != FileHelper.UNKNOWN) {
					resultFiles.put(info.name, info);
				}
			}
		}

	}

	/**
	 */
	public void loadPredictions()
		throws Exception
	{
	}

	/**
	 * Load up run definition and results if they exist.
	 * Need to set imageDir and list of images
	 */
	public void loadSetup()
		throws Exception
	{
		String runDefFile = null;
		try {

			setupDone = false;

			curSetupData.setImageDir(top.getImageDir());

			setupData.copy(curSetupData);

			runDefFile = getWorkDir() + "/" + definitionFile;
			String oldRunDefFile = getWorkDir() + "/autoindex.xml";
			String file = runDefFile;

			boolean needConversion = false;

			// Try to open input.xml. If not found then try to open autoindex.xml.
			// If neither can be found then throw an exception.
			// If only autoindex.xml can be found, then read it and
			// save it as to input.xml for next time.
			if (!client.getImperson().fileExists(runDefFile)) {
				throw new Exception("Cannot find or open file " + runDefFile);
			}

			// Read remote file either input.xml or autoindex.xml.
//			stream = client.getImperson().readFileStream(file);
			String xmlStr = client.getImperson().readFile(file);
			ByteArrayInputStream stream = new ByteArrayInputStream(xmlStr.getBytes());

			if (stream == null)
				throw new Exception("Null input stream");

			AutoindexSetupSerializer.load(stream, curSetupData);

			setupData.copy(curSetupData);

			if (setupData.validate())
				setupDone = true;


		} catch (Exception e) {
			e.printStackTrace();
			setLog("ERROR: " + e.getMessage() + "\n");
		}
	}

	/**
	 * Load result from previous run
	 */
	private void loadSummary()
		throws Exception
	{

		summary = "";
		labelitResult.clear();

		String summaryFile = getWorkDir() + "/labelit.out";
		try {


			// read summary file
			summary = client.getImperson().readFile(summaryFile);


			labelitResult.load(summary);

			Vector inRes = labelitResult.integrationResults;

			if (inRes.size() > 0) {
				IntegrationResult ing = (IntegrationResult)inRes.elementAt(0);
				laueGroup = ing.spacegroup;
			}


		} catch (Exception e) {

			summary += "\n\nFailed to load or parse " + summaryFile
					+ ": " + e.getMessage();

		}
	}

	/**
	 * This method is used to populate the navigation tree
	 * Keep it simple.
	 */
	public void loadChildren()
		throws Exception
	{
		try {

		removeChildren();

		// Get sub directories
		TreeMap dirs = new TreeMap();
		client.getImperson().listDirectory(
						getWorkDir(),
						null,
						dirs,
						null);

		// Each sub directory whose name
		// begins with solution is a child of this node
		Object keys[] = dirs.keySet().toArray();
		if (keys != null) {
			for (int i = 0; i < keys.length; ++i) {
				String key = (String)keys[i];
				if (key.indexOf("solution") == 0) {
					IntegrateNode child = new IntegrateNode(key, this, top);
					addChild(child);
				}
			}
		}


		} catch (Exception e) {
			System.out.println("loadChildren caught exception: " + e.getMessage());
			e.printStackTrace();
			throw e;
		}

	}

	/**
	 * Reload a child node. Delete old one, if exists, and
	 * replace it with a new one loaded from disk.
	 * @param s Child node name
	 * @exception Exception Thrown if reload fails.
	 */
	public NavNode reloadChild(String aName)
		throws Exception
	{

		// try to delete child node
		// If it does not exist then removeChild
		// does nothings
		removeChild(aName);


		// Create a new child node
		IntegrateNode aNode = new IntegrateNode(aName, this, top);
		addChild(aNode);

		return aNode;

	}

	public Object[] getResultFiles()
		throws Exception
	{
		loadDetails();
		return resultFiles.values().toArray();
	}

	public int getStatus()
	{
		if (this.isRunning() && runStatus.getType().equals("autoindex"))
			return AUTOINDEX_RUNNING;
		else if (this.isRunning() && runStatus.getType().equals("integrate"))
			return ADDITONAL_INTEGRATION_RUNNING;
		else if (autoindexDone)
			return AUTOINDEX_FINISH;
		else if (additionalIntegrationDone)
			return ADDITONAL_INTEGRATION_FINISH;
		else if (setupDone)
			return READY;

		return SETUP;
	}

	/**
	 */
	public boolean isRunning()
	{
		return runStatus.isRunning() || ((runMonitor != null) && runMonitor.isAlive());
	}

	/**
	 */
	public boolean isAutoindexDone()
	{
		return autoindexDone;
	}

	public String getType()
	{
		return "autoindex";
	}

	public String getDesc()
	{
		return "Autoindexing for Dataset";
	}

	/**
	 * Override NavNode method.
	 */
	public boolean isTabViewable(String tabName)
	{
		if (tabName.equals(TAB_SETUP)) {
			return true;
		} else if (tabName.equals(TAB_SOLUTIONS)) {
			return strategyDone;
		} else if (tabName.equals(TAB_AUTOINDEX_SUMMARY)) {
			return integrationDone;
		} else if (tabName.equals(TAB_DETAILS)) {
			return ((getStatus() != AUTOINDEX_RUNNING) || integrationDone);
		} else if (tabName.equals(TAB_PREDICTIONS)) {
			return autoindexDone;
		}

		return false;
	}


	public LabelitSetupData getSetupData()
	{
		return setupData;
	}

	public void editSetup()
		throws Exception
	{

		if (isRunning())
			return;

		// Delete previous results before
		// allow users to modify the setup.
		if (getStatus() > LabelitNode.READY) {
			// Delete all files under this dir
			deleteResults();
			// Save current setup data to input.xml
			saveSetup(getWorkDir() + "/" + definitionFile, setupData);
		}

		// Force reload results and children
		load(true);

		setupDone = false;

	}

	public void resetSetupData()
	{
		if (getStatus() != LabelitNode.SETUP)
			return;

		curSetupData.reset();
		curSetupData.setImageDir(top.getImageDir());
		setupData.copy(curSetupData);

	}


	public void finishSetup()
	{
		try {


			setupDone = false;

			if ((setupData.getImage1().length() == 0) ||
				(setupData.getImage2().length() == 0)) {
				setLog("Failed to save setup for labelit: Invalid image names.\n");
				return;
			}


			curSetupData.copy(setupData);

			saveSetup(getWorkDir() + "/" + definitionFile, setupData);

			top.setImageDir(curSetupData.getImageDir());

			// ready to run
			setupDone = true;

		} catch (Exception e) {
			appendLog("ERROR: failed to save setup for labelit: " + e.getMessage() + "\n");
		}


	}

	/**
	 */
	private void saveSetup(String file, LabelitSetupData data)
		throws Exception
	{
		StringBuffer buf = new StringBuffer();
		AutoindexSetupSerializer.save(buf, data);

		client.getImperson().saveFile(file, buf.toString(), "text/plain");
	}

	/**
	 */
	private ImageHeader getImageHeader(String img)
		throws Exception
	{
		String urlStr = "http://" + ServerConfig.getImgServerHost() + ":"
					+ String.valueOf(ServerConfig.getImgServerPort())
					+ "/getHeader?fileName=" + img
					+ "&userName=" + client.getUser()
					+ "&sessionId=" + client.getSessionId();



		URL url = new URL(urlStr);

		HttpURLConnection con = (HttpURLConnection)url.openConnection();

		con.setRequestMethod("GET");

		int response = con.getResponseCode();
		if (response != 200)
			throw new Exception("getHeaderString failed: imgsrv returns "
						+ String.valueOf(response) + " " + con.getResponseMessage()
						+ " (for " + urlStr + ")");

		BufferedReader reader = new BufferedReader(new InputStreamReader(con.getInputStream()));

		Vector lines = new Vector();
		String line = null;
		Hashtable tab = new Hashtable();
		while ((line=reader.readLine()) != null) {
			lines.add(line);
		}

		reader.close();
		con.disconnect();

		ImageHeader header = new ImageHeader();

		header.parse(lines);

		lines = null;

		return header;
	}

	/**
	 */
	private void checkDeltaPhi(	String im1,
								ImageHeader header1,
								String im2,
								ImageHeader header2)
		throws Exception
	{

		double deltaPhi = (double)(header1.phi-header2.phi);
		if (deltaPhi < 0.0)
			deltaPhi *= -1.0;

		if (deltaPhi < 5.0)
			throw new Exception("Delta phi between " + im1
							+ " and " + im2 + " is too small ("
							+ deltaPhi + " deg). At least 5 deg is required."
							+ " Oscillation range is " + header1.oscRange + " deg). ");

		header1 = null;
		header2 = null;

	}

	/**
	 * Detector center
	 * Q4 CCD: 94, 94
	 * Q315 CCD: 157.5, 157.5
	 * MAR345 1200 and 1800 : 90, 90
	 * MAR345 1600 and 2400 : 120, 120
	 * MAR345 2000 and 3000 : 150, 150
	 * MAR345 2300 and 3450 : 172.5, 172.5
	 *
	 * Mosflm center
	 * x = Cy
	 * y = detectorWidth - Cx
	 */
	private void correctBeamCenter(LabelitSetupData setupData,
									ImageHeader header)
		throws Exception
	{
		// Beam center used by labelit and mosflm scripts.
		setupData.setCenterX(header.detectorWidth - header.beamCenterY);
		setupData.setCenterY(header.beamCenterX);

	}

	private int getImageIndex(String im)
		throws Exception
	{


		int pos1 = im.lastIndexOf('_');

		if (pos1 < 0)
			throw new Exception("Failed to parse image file: " + im);

		int pos2 = im.indexOf('.', pos1+1);

		if (pos2 < 0)
			throw new Exception("Failed to parse image file: " + im);

		return Integer.parseInt(im.substring(pos1+1, pos2));

	}

	public boolean isShowFileBrowser()
	{
		return showFileBrowser;
	}

	public void setShowFileBrowser(boolean s)
	{
		showFileBrowser = s;
	}

	public String getImageDir()
	{
		return curSetupData.getImageDir();
	}

	public void setImageDir(String s)
	{

		setupData.setImageDir(s);

	}

	public void clearImages()
	{
		setupData.clearImages();
	}

	public void setImages(String im1, String im2)
	{
		try {

			ImageHeader header1 = getImageHeader(setupData.getImageDir() + "/" + im1);
			ImageHeader header2 = getImageHeader(setupData.getImageDir() + "/" + im2);

			// Will throw an exception if phi of image1 and image2
			// are not at least than 5 degrees.
			checkDeltaPhi(im1, header1, im2, header2);


			setupData.setImages(im1, im2);

			setupData.setBeamCenterX(header1.beamCenterX);
			setupData.setBeamCenterY(header1.beamCenterY);
			setupData.setDistance(header1.distance);
			setupData.setWavelength(header1.wavelength);
			setupData.setDetector(header1.detector);
			setupData.setDetectorFormat(header1.format);

			// Correct beam center for
			// labelit and mosflm scripts
			correctBeamCenter(setupData, header1);

		} catch (Exception e) {
			setLog("Failed to set images " + im1 + " and " + im2 + ": " + e.getMessage());
		}

	}

	public String getImage1()
	{
		return curSetupData.getImage1();
	}

	public String getImage2()
	{
		return curSetupData.getImage2();
	}

	public void setImageFilter(String s)
	{
		setupData.setImageFilter(s);
	}

	public String getIntegrate()
	{
		return setupData.getIntegrate();
	}

	public boolean isGenerateStrategy()
	{
		return setupData.isGenerateStrategy();
	}


	public String getWorkDir()
	{
		return top.getWorkDir() + getPath();
	}

	public String getLaueGroup()
	{
		return laueGroup;
	}

	/**
	 * Run con_autoindex.csh script
	 */
	public void run()
		throws Exception
	{
		try {

		aborted = false;

		setLog("Started running autoindex\n");

		// Check the control file to see if it's already running.

		// Check if the input.xml file is ready

		// Delete old results

		// Run the script via the impersonation server.

		String commandline = ServerConfig.getScriptDir() + "/con_autoindex.csh ";

		commandline +=   " " + getWorkDir() + "/input.xml";

		String urlStr = "http://" + ServerConfig.getSpotServerHost()
							+ ":" + String.valueOf(ServerConfig.getSpotServerPort())
							+ "/runScript";

		URL url = new URL(urlStr);

		HttpURLConnection con = (HttpURLConnection)url.openConnection();

		con.setRequestMethod("GET");
		con.setRequestProperty("impShell", "/bin/tcsh");
		con.setRequestProperty("impCommandLine", commandline);
		con.setRequestProperty("impUser", client.getUser());
		con.setRequestProperty("impEnv1", "HOME=/home/" + client.getUser());
		con.setRequestProperty("impSessionID", client.getSessionId());


		int response = con.getResponseCode();
		if (response != 200)
			throw new Exception("Failed to run labelit: impserson server returns "
						+ String.valueOf(response) + " " + con.getResponseMessage()
						+ " (for " + urlStr + ")");


		BufferedReader reader = new BufferedReader(new InputStreamReader(con.getInputStream()));

		String line = null;
		while ((line=reader.readLine()) != null) {
			if (line.length() > 0)
				appendLog(line + "\n");
		}

		reader.close();
		con.disconnect();

		// Assume that it's running
		// updateStatus should be called
		// to get the latest status.
		runStatus.setType("autoindex");
		runStatus.setStartTime("");

		// Start monitoring the run
		this.startMonitoring();


		} catch (Exception e) {
			appendLog("ERROR: " + e.getMessage() + "\n");
		}

	}


	/**
	 * Delete all output generated by this node.
	 */
	public void deleteResults()
		throws Exception
	{
		// Delete all files
		client.getImperson().deleteFiles(getWorkDir(), "*");

	}

	public String getSummary()
	{
		return summary;
	}

	public void setImage(String s)
	{
		image = s;
	}

	public String getImage()
	{
		return image;
	}

	public String getImageType()
	{
		return imageType;
	}

	public void setImageType(String s)
	{
		imageType = s;
	}

	private String getBaseName(String filename)
	{
		int pos = filename.lastIndexOf('.');
		if (pos < 0)
			return filename;

		return filename.substring(0, pos);
	}

	/**
	 * Return spot statistics
	 */
	public String getPredictionStats()
	{
		if ((image == null) || (image.length() == 0))
			return "";

		String file = getWorkDir() + "/" + getBaseName(image);

		if (imageType.equals(LabelitNode.IMAGE_LABELIT_SPOT)) {
			file += "_overlay_distl.stat";
		} else if (imageType.equals(LabelitNode.IMAGE_INDEX_SPOT)) {
			file += "_overlay_index.stat";
		} else if (imageType.equals(LabelitNode.IMAGE_MOSFLM_SPOT)) {
			file += "_overlay_mosflm.stat";
		} else {
			return "";
		}

		try {

		String content = client.getImperson().readFile(file);

			return content;

		} catch (Exception e) {
//			return "Could not get image statistics from file "
//					+ file + ": " + e.getMessage();
			return "";
		}
	}

	/**
	 * Return url location to image file generated by labelit
	 */
	public String getImageUrl()
	{
		if ((image == null) || (image.length() == 0))
			return "";

		String file = getWorkDir() + "/" + getBaseName(image);

		if (imageType.equals(LabelitNode.IMAGE_LABELIT_SPOT)) {
			file += "_overlay_distl.png";
		} else if (imageType.equals(LabelitNode.IMAGE_INDEX_SPOT)) {
			file += "_overlay_index.png";
		} else if (imageType.equals(LabelitNode.IMAGE_MOSFLM_SPOT)) {
			file += "_overlay_mosflm.png";
		} else {
			file += ".png";
		}

		String url = "servlet/loader/readPngFile?impUser=" + client.getUser()
						+ "&impSessionID=" + client.getSessionId()
						+ "&impFilePath=" + file;

		return url;
	}

	public void setImageWidth(int s)
	{
	   imageWidth = s;
	}

	public int getImageWidth()
	{
	   return imageWidth;
	}

	public void setImageHeight(int s)
	{
	   imageHeight = s;
	}

	public int getImageHeight()
	{
	   return imageHeight;
	}

	public String getLog()
	{
		return log;
	}

	public void setLog(String s)
	{
		log = s;
	}

	public String getRunLog()
	{
		return runLog;
	}

	public void resetLog()
	{
		log = "";
	}

	public void appendLog(String s)
	{
		log += s;
	}

	public LabelitResult getLabelitResult()
	{
		return labelitResult;
	}

	public void abortRun()
	{
		try {

		resetLog();

		String commandline = ServerConfig.getScriptDir() + "/kill_autoindex.csh "
						+ getWorkDir() + "/control.txt";

		String urlStr = "http://" + ServerConfig.getSpotServerHost()
							+ ":" + String.valueOf(ServerConfig.getSpotServerPort())
							+ "/runScript";

		URL url = new URL(urlStr);

		HttpURLConnection con = (HttpURLConnection)url.openConnection();

		con.setRequestMethod("GET");
		con.setRequestProperty("impShell", "/bin/tcsh");
		con.setRequestProperty("impCommandLine", commandline);
		con.setRequestProperty("impEnv1", "HOME=/home/" + client.getUser());
		con.setRequestProperty("impUser", client.getUser());
		con.setRequestProperty("impSessionID", client.getSessionId());


		int response = con.getResponseCode();
		if (response != 200)
			throw new Exception("Failed to run labelit: impserson server returns "
						+ String.valueOf(response) + " " + con.getResponseMessage()
						+ " (for " + urlStr + ")");


		BufferedReader reader = new BufferedReader(new InputStreamReader(con.getInputStream()));

		String line = "";
		String content = "";
		while ((line = reader.readLine()) != null) {
			if (line.length() > 0)
				content += line + "\n";
		}


		reader.close();
		con.disconnect();

		// make sure it's not running any more.
		this.stopMonitoring();
		while (runMonitor.isAlive()) { Thread.currentThread().sleep(50); }

		appendLog(content);


		} catch (Exception e) {
			appendLog("ERROR: " + e.getMessage() + "\n");
		}
	}

	public boolean isRunAborted()
	{
		return aborted;
	}

	public boolean isAdditionalIntegrationDone()
	{
		return additionalIntegrationDone;
	}

	/**
	 * Get the latest run status from the control file
 	 */
	public void updateRunStatus()
	{
		try {

		resetLog();

		hasAutoindexLog = false;

		boolean wasRunning = runStatus.isRunning();
		boolean inState1 = isIntegrationDone();
		boolean inState2 = isAdditionalIntegrationDone();
		boolean inState3 = isStrategyDone();
		boolean inState4 = isAutoindexDone();


		String commandline = ServerConfig.getScriptDir() + "/con_autoindex_updatestatus.csh " + getWorkDir();

		String urlStr = "http://" + ServerConfig.getSpotServerHost()
							+ ":" + String.valueOf(ServerConfig.getSpotServerPort())
							+ "/runScript";

		URL url = new URL(urlStr);

		HttpURLConnection con = (HttpURLConnection)url.openConnection();

		con.setRequestMethod("GET");
		con.setRequestProperty("impShell", "/bin/tcsh");
		con.setRequestProperty("impCommandLine", commandline);
		con.setRequestProperty("impEnv1", "HOME=/home/" + client.getUser());
		con.setRequestProperty("impUser", client.getUser());
		con.setRequestProperty("impSessionID", client.getSessionId());


		int response = con.getResponseCode();
		if (response != 200)
			throw new Exception("Failed to run labelit: impserson server returns "
						+ String.valueOf(response) + " " + con.getResponseMessage()
						+ " (for " + urlStr + ")");


		BufferedReader reader = new BufferedReader(new InputStreamReader(con.getInputStream()));

		String line = reader.readLine();
		runStatus.parseStatus(line);

		reader.close();
		con.disconnect();

		// Update the log displayed in setup tab
		updateRunLog();

		// It was running and now it's done
		boolean stateChanged = wasRunning && !runStatus.isRunning();

		// It was running autoindexing and now integration is done.
		// (But it may still be running).
		if (!stateChanged)
			stateChanged = (wasRunning && !inState1) && isIntegrationDone();

		// It was running
		if (!stateChanged)
			stateChanged = (wasRunning && !inState2) && isAdditionalIntegrationDone();

		if (!stateChanged)
			stateChanged = (wasRunning && !inState3) && isStrategyDone();

		if (!stateChanged)
			stateChanged = (wasRunning && !inState4) & isAutoindexDone();

//		if (!stateChanged)
//			stateChanged = (wasRunning && !runStatus.isRunning()) && aborted;


		// Finished integrating but may not have finished
		// generating predictions
		if (stateChanged) {
			loadSummary();
			loadSolutions();
			loadImageStats();
			loadChildren();
		}

		} catch (Exception e) {
			appendLog("ERROR: " + e.getMessage() + "\n");
		}

	}

	/**
	 */
	private boolean isLabelitDone()
	{
		return labelitDone;
	}

	/**
	 */
	private boolean isIntegrationDone()
	{
		return integrationDone;
	}

	/**
	 */
	private boolean isStrategyDone()
	{
		return strategyDone;
	}


	/**
	 */
	public RunStatus getRunStatus()
	{
		return runStatus;
	}

	/**
	 */
	public boolean hasAutoindexLog()
	{
		return hasAutoindexLog;
	}

	/**
	 * Check autoindex.out and look for "Finished running autoindex" line.
	 */
	private void updateRunLog()
	{
		try {

		int pos = 0;

		if (!hasAutoindexLog)
			hasAutoindexLog = client.getImperson().fileExists(getWorkDir() + "/autoindex.out");

		if (hasAutoindexLog) {
		    runLog = client.getImperson().readFile(getWorkDir() + "/autoindex.out");

			// Finished running labelit
		    pos = runLog.indexOf("Finished running labelit", pos);
		    if (pos > 0)
		    	labelitDone = true;

		    // Finished the first round of integration
		    pos = runLog.indexOf("Finished integrating solutions", pos);
		    if (pos > 0)
		    	integrationDone = true;

			if (integrationDone) {

				// Finished strategy
				if (!setupData.isGenerateStrategy()) {
					strategyDone = true;
					} else {
					int pos1 = runLog.indexOf("Finsihed generating strategies", pos);
					if (pos1 > 0) {
						strategyDone = true;
						pos = pos1;
					}
				}

				// Finished autoindexing

				pos = runLog.indexOf("Finished running autoindex", pos);
				if (pos > 0)
					autoindexDone = true;
			}

			if (autoindexDone) {
				// Default prediction image
				setImage(getImage1());

				// Finished additional integration
				// Find the last line. There is a matching "Started" and "Finished"
				// when a task is done.
				int pos1 = runLog.lastIndexOf("integrating additional solutions", pos);
				if ((pos1 > 0) && ((pos1-9) > 0) && (runLog.substring(pos1, pos1+8).equals("Finished"))) {
					additionalIntegrationDone = true;
				}
			}

			pos = runLog.indexOf("autoindex aborted");
			if (pos > 0)
				aborted = true;
		}

		} catch (Exception e) {
			appendLog("ERROR: " + e.getMessage() + "\n");
		}
	}

	/**
	 */
	public NavNode getChild(int solNum)
	{
		String childName = "solution";
		if (solNum < 10)
			childName += "0";

		childName += String.valueOf(solNum);

		return getChild(childName);
	}

	/**
	 */
	public void integrateAdditionalSolutions(Vector solVec)
		throws Exception
	{
		try {

		resetLog();

		if (this.isRunning())
			throw new Exception("Cannot start integrating additional solutions: other process is still running");

		if (!autoindexDone)
			throw new Exception("Cannot integrate additional solutions: autoindex must be run first");

		additionalIntegrationDone = false;

		aborted = false;

		setLog("Started integrating\n");

		String sol = "";
		String sols = "";
		for (int i = 0; i < solVec.size(); ++i) {
			Integer solInt = (Integer)solVec.elementAt(i);
			sol = solInt.toString();
			if (sols.length() > 0)
				sols += " ";
			if (solInt.doubleValue() < 10)
				sols += "0";
			sols += sol;
		}

		String commandline = ServerConfig.getScriptDir() + "/con_integrate_additional_solutions.csh ";

		commandline +=   " " + getWorkDir() + " " + sols;

		String urlStr = "http://" + ServerConfig.getSpotServerHost()
							+ ":" + String.valueOf(ServerConfig.getSpotServerPort())
							+ "/runScript";

		URL url = new URL(urlStr);

		HttpURLConnection con = (HttpURLConnection)url.openConnection();

		con.setRequestMethod("GET");
		con.setRequestProperty("impShell", "/bin/tcsh");
		con.setRequestProperty("impCommandLine", commandline);
		con.setRequestProperty("impUser", client.getUser());
		con.setRequestProperty("impEnv1", "HOME=/home/" + client.getUser());
		con.setRequestProperty("impSessionID", client.getSessionId());


		int response = con.getResponseCode();
		if (response != 200)
			throw new Exception("Failed to run labelit: impserson server returns "
						+ String.valueOf(response) + " " + con.getResponseMessage()
						+ " (for " + urlStr + ")");


		BufferedReader reader = new BufferedReader(new InputStreamReader(con.getInputStream()));

		String line = null;
		while ((line=reader.readLine()) != null) {
			if (line.length() > 0)
				appendLog(line + "\n");
		}

		reader.close();
		con.disconnect();


		// Assume that it's running
		// updateStatus should be called
		// to get the latest status.
		runStatus.setType("integrate");
		runStatus.setStartTime("");

		// Start monitoring the run
		this.startMonitoring();


		} catch (Exception e) {
			appendLog("ERROR: " + e.getMessage() + "\n");
		}

	}

	/**
	 */
	private void startMonitoring()
		throws Exception
	{
		if ((runMonitor != null) && runMonitor.isAlive())
			throw new Exception("Already monitoring the run");

		runMonitor = null;

		runMonitor = new MonitorThread();
		runMonitor.startMonitoring();
	}

	/**
	 */
	private void stopMonitoring()
	{
		if (runMonitor != null)
			runMonitor.stopMonitoring();
	}

	/**
	 */
	public void loadImageStats()
	{
		try {

		String str = client.getImperson().readFile(getWorkDir() + "/image_stats.out");

		ImageStats.parse(str, imageStats);

		} catch (Exception e) {
//			appendLog("ERROR: failed to load image_stats.out: " + e.getMessage());
		}
	}

	/**
	 */
	public ImageStats[] getImageStats()
	{
		return imageStats;
	}

	/**
	 */
	public boolean isUseApplet()
	{
		return useApplet;
	}

	/**
	 */
	public void setUseApplet(boolean b)
	{
		useApplet = b;
	}

	/**
	 * Thread to monitor the run
	 */
	private class MonitorThread extends Thread
	{
		private boolean stopped = false;
		private int interval = 5;

		synchronized public void startMonitoring()
		{
			if (isAlive())
				return;
			stopped = false;

			super.start();
		}

		synchronized public void stopMonitoring()
		{
			stopped = true;
		}

		public void run()
		{
			try {
				synchronized (this) {
					runStatus.setRunning(true);
					while (!stopped) {

						// Update run status
						updateRunStatus();

						if (!runStatus.isRunning())
							stopped = true;

						if (stopped)
							break;

						// sleep
						sleep(interval*1000);
					}

				}

			} catch (InterruptedException e) {
				System.out.println("LabelitNode: MonitorThread stopped: " + e);
				stopped = true;
			}
		}
	}

}

