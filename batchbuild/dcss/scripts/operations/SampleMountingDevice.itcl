package require Itcl

#DCS::String "table_property" stores data not changeable for table
#You should be able to get these data from drawings of table.

#field 0: level distance between V-pivot to top table downstream edge.
#         normally the distance from V-pivot to upstream edge of
#         the top table is measurable or can be calculated from drauwings.

#field 1: distance from H-pivot to top table downstream edge.
#         normally, you have to get it from drawings.

#field 2: level distance from goniometer head to downstream edge of
#         goniometer table (normally 4.5inch)

#fidle 3: height from sub-frame top plane to the V-pivot.
#         if they are linked by "SPB 32 ADJ", it is 2.125inch.

#field 4: neight from sub-frame top plane to goniometer height.

#field 5: distance from H2 displacement sensor to downstream edge of top table

#DCS::string "table_setup"
#These values need to be updated if table setup changed them.

#field 0: level distance from downstream edge of goniometer table
#         to downstreams edge of top table.

#field 1: safe sample Z value for mount/dismount:
#         The distance from cryojet should be enough for tong to move in +5mm

#field 2: the distance from goniometer head to center line of top table
#         (the center line is beamline) when the goniometer is at the
#         safe_Z position.

#field 3: detector_z value for mount/dismount. Make sure this
#         is big enough that the detector clears the robot
#         interlock IR beam.

#field 4: sample_z value after mount
#         This is for extra short or extra long pins.

#DCS::String "table_position"
#            Save the table position when you run the goniometer-calibration
#            You can move back to this position to mount/dismount
# fields:  H1, H2, V1, V2

#DCS::String "table_adjust"
#which table motors will be moved to access position
#if "table_vert1" is found, both table_vett1 and table_vert2 will be moved
#                           to "table_position"
#else if "table_vert2" is found, it will be moved to tanle_vert1, so no pitch
#else no movement in vertical aspect. 

#SAME goes to horizontal

#DCS::String "table_gonio_scale"
#from the above strings, we can calculate:
# length_V1_to_gonio
# height_V1_to_gonio
# length_H1_to_gonio
# offset_H1_to_gonio
#This string is to store the scales for these values from calibration

####################### table motor to robot goniometer position ###########333
#DCS::String "motor_to_robot_config"
#ORDER: V1, V2, H1, H2:
#(y=ax+b)
#FILED 0:   a for V1
#FIELD 1:   b for V1
#FIELD 2:   c for V1  dx=c*V1
#FIELD 3:   d for V1  dy=d*V1
#FILED 4:   a for V2
#FIELD 5:   b for V2
#FIELD 6:   a for H1
#FIELD 7:   c for H1 dx=c*H1
#field 8:   a for H2

# b is not needed for H1, we cannot check whether the table is in the center when H1=0
# b is not needed for H2, we cannot check whether the table is straight when H2=0

#DCS::String "motor_z_scale"
#currently, only 1 field: the scale for pitch (or the Z position for Vertical motors)
#the scalel for yaw is built into the FIELD 8 of "motor_to_robot_config"


######################################
#DCS::String: dsensor_to_motor_config
#(y=ax+b)
#FIELD 0:   a for V1
#FIELD 1:   b for V1
#FIELD 2:   a for V2
#FIELD 3:   b for V2
#FIELD 4:   a for H1
#FIELD 5:   b for H1
#FIELD 6:   a for H2
#FIELD 7:   b for H2
###############################
# to be backward comptable with old laser sensor setup:
# sensor H2 is measuring motor H1+H2.
# we use H2 = a * sensor_H2 +b + c * motor_H1
###########################################
#FILED 8:  c for H2 (should be close to 0 for new setup


itcl::class SampleMountingDevice {

    # private data members -- beamline component interactions
    private {
        variable safedistanceArray
        variable moveToAccessArray
        variable moveBackArray
        variable validcassetteList
        variable validcolumnList
        variable validrowList

        #static values
        variable camera_zoom_safe 0
        variable beamstop_z_safe 42.00
        variable gonio_phi_safe 90.00 
        variable gonio_kappa_safe 0.00 
        variable sample_x_safe 0.00 
        variable sample_y_safe 0.00 

        #will be overrided from table_setup
        variable detector_safe 300.00
        variable sample_z_safe 0.0
        variable sample_z_after 0.0

        #3 seconds
        variable AVERAGE_TIME 3000
        variable TURN_ON_LASER_MASK 255
        variable TURN_ON_LASER_BOARD 0
        variable READ_LASER_BOARD 0

        variable RESET_WAIT_TIME 2000

        #will be overrided from table_property
        variable length_vert1_gonio 890
        variable height_vert1_gonio 630
        variable length_horz1_gonio 100
        variable offset_horz1_gonio 30
        variable raw_length_vert1_gonio 890
        variable raw_height_vert1_gonio 630
        variable raw_length_horz1_gonio 100
        variable raw_offset_horz1_gonio 30
    }

    private variable need_goHome 0

    public method constructor

    #call after table_property or table_setup changes
    public method calculateTableSetup

    #should be private, put here to debug
    public method fillSafeDistanceArray { move_table_option }
    public method fillMoveList { move_table_option }
    public method getDeltaGonioPosFromMotor { }
    public method getDeltaGonioPosFromFutureMotor { }
    public method getDeltaGonioPosFromMotorArgument { V1 V2 H1 H2 }
    public method getLaserSensorReading { average_time }
    public method doGonioCALForTableCAL { result_index }

    # for reset
    public method skipReset
    public method delayReset
    public method resetProcedure
    public method goToNextResetStep
    public method getRobotState { }
    public method resetAllowed { }
    public method openGripper { }
    public method heatGripper { heatsecs }
    public method returnDumbbell { }
    public method moveToCheckPoint { }
    public method check { tool }
    public method performNextRobotResetStep
    public method stepUp { args }

    # for crystal
    public method mountCrystal { cassette row column wash_cycle }
    public method dismountCrystal { cassette row column }
    public method mountNextCrystal { cassette row column cassette_nxt row_nxt column_nxt wash_cycle }
    public method moveCrystal { args }
    public method washCrystal { times }

    # for calibration
    public method calibrateMagnet { { find_magnet 0 } {quick 0} } 
    public method calibrateCassette { cassettes { init 0 } } 
    public method calibrateGoniometer { { init 0 } }
    public method checkGoniometerReachable { }
    public method getGonioCALDATA { }
    public method calibrateBeamLineTool { { init 0 } }
    public method mountBeamLineTool {  }
    public method dismountBeamLineTool {  }
    public method newGonioCAL { }
    ###### one buttont start all calibration #######
    public method oneCalibrate { }

    # for user action
    public method portJamUserAction { args }

    ### for probing
    public method probe { }

    #special gonio cal for table CAL
    #it does not calculate dx, dy, dz and du
    #in short: no call to getDeltaGonioPos
    #to avoid operation readAnalog
    public method specialGonioCAL { dx dy dz du }
    public method newSpecialGonioCAL { dx dy dz du }
    
    #for table motors and displacement sensors calibration
    public method doTableHorzCAL { }
    public method doTableVertCAL { }
    public method doTableCALCalculation { {auto_save 0 } }
    
    #for manula goniometer cal
    public method moveToGoniometer { }
    public method teachGoniometer { }
    public method moveHome { }

    # for manual beamlineTool CAL
    public method moveToBeamlineTool { }
    public method teachBeamlineTool { }
    public method jumpHome { }

    #### barcode reader
    public method readSampleBarcode { deltaGonioPos index port time_wait {goHome 1}}
    public method readCassetteIdBarcode { {stay_in_dewar 0} }
    public method updateCassetteOwnerFromBarcode { }

    ### this is here because we want to trigger updateCassetteOwner
    public method addUsersToBarcode { barcode users }
    ### SETUP
    public method moveToBarcodeReader { }
    public method teachBarcodeReader { }
    #### rescue
    public method putSampleBackFromBarcodeReader { }

    #for Robot_Test
    public method prepareRobotTest { }

    ###### to do more parallel
    public method getMovingBackMotorList { } {
        return [array names moveBackArray]
    }

    public method syncLaserSensorToCurrentPosition { }

    # private methods
    private method checkTablePosition { }
    private method validPort { cassette row column }
    private method getDeltaGonioPos { }
    private method calculateDeltaGonioPos { V1 Pitch H1 Yaw XAdjust YAdjust }
    private method moveToAccessPosition { }
    private method moveBackToOriginalPosition { }
    private method saveCurrentTablePosition { }
    private method clearTableCALDATA { }
    private method checkIfRecoverableError { result_message }
    private method autoSampleCheck { {retr_cmd ""} }
    private method autoSampleCalibrate { }
    private method syncLaserSensorToMotor { data {warning 0} }

    private method readBarcodeWhileWaitForOperationToFinish { handle }

    private proc checkSensorReading { V1 V2 H1 H2 }

    private method warnDetectorZ { }

    private proc getDefaultBarcodePort { cas }
    private proc anyProbe { cas }

    public method sampleOnGoniometer { }
    public method sampleOffGoniometer { }
    public method sampleOnOffCalibrate { }
}

itcl::body SampleMountingDevice::constructor { } {
    global gLaserControl
    global gLaserRead

    calculateTableSetup 

    set validcassetteList [ list l m r ]
    set validcolumnList [ list A B C D E F G H I J K L ]
    set validrowList [ list 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ]

    loadLaserChannelConfig
    decideADCCard

    set TURN_ON_LASER_MASK [expr \
    1 << $gLaserControl(table_vert_1,CHANNEL) | \
    1 << $gLaserControl(table_vert_2,CHANNEL) | \
    1 << $gLaserControl(table_horz_1,CHANNEL) | \
    1 << $gLaserControl(table_horz_2,CHANNEL)]

    set TURN_ON_LASER_BOARD $gLaserControl(table_vert_1,BOARD)
    if {$TURN_ON_LASER_BOARD != $gLaserControl(table_vert_2,BOARD) || \
    $TURN_ON_LASER_BOARD != $gLaserControl(table_horz_1,BOARD) || \
    $TURN_ON_LASER_BOARD != $gLaserControl(table_horz_2,BOARD)} {
        log_severe need software change to support multiple boards for laser
    }

    set READ_LASER_BOARD $gLaserRead(table_vert_1,BOARD)
    if {$READ_LASER_BOARD != $gLaserRead(table_vert_2,BOARD) || \
    $READ_LASER_BOARD != $gLaserRead(table_horz_1,BOARD) || \
    $READ_LASER_BOARD != $gLaserRead(table_horz_2,BOARD)} {
        log_severe need software change to support multiple boards for laser read
    }

    puts "TURN_ON_LASER_MASK: $TURN_ON_LASER_MASK"
}
itcl::body SampleMountingDevice::saveCurrentTablePosition { } {
    variable ::nScripts::table_position

    set table_position [list \
        $::gDevice(table_vert_1,scaled) \
        $::gDevice(table_vert_2,scaled) \
        $::gDevice(table_horz_1,scaled) \
        $::gDevice(table_horz_2,scaled) \
    ]

    set sensor_result [getLaserSensorReading $AVERAGE_TIME]
    eval checkSensorReading $sensor_result
    eval lappend table_position $sensor_result
}
itcl::body SampleMountingDevice::moveToAccessPosition { } {
    foreach device [array names moveToAccessArray] {
        move $device to $moveToAccessArray($device)
    }
    eval wait_for_devices [array names moveToAccessArray]
}
itcl::body SampleMountingDevice::moveBackToOriginalPosition { } {
    foreach device [array names moveBackArray] {
        move $device to $moveBackArray($device)
    }
    
    ####comment out following line if you want to allow
    #### loop centering while detector_z is moving
    eval wait_for_devices [array names moveBackArray]
}
itcl::body SampleMountingDevice::fillSafeDistanceArray { move_table_option } {
    variable ::nScripts::table_setup
    variable ::nScripts::table_position
    variable ::nScripts::table_adjust
    variable ::nScripts::gonio_kappa

    # get safe values that are not hardcoded
    set z_safe_from_string [lindex $table_setup 1]
    if {[string is double -strict $z_safe_from_string]} {
        set sample_z_safe $z_safe_from_string
    } else {
        puts "no sample_z specificed for mount from table_setup default to $sample_z_safe"
    }
    set z_after_from_string [lindex $table_setup 4]
    if {[string is double -strict $z_after_from_string]} {
        set sample_z_after $z_after_from_string
    } else {
        puts "no sample_z specificed after mount from table_setup default to $sample_z_after"
    }
    set table_vert_1_safe [lindex $table_position 0]
    set table_vert_2_safe [lindex $table_position 1]
    set table_horz_1_safe [lindex $table_position 2]
    set table_horz_2_safe [lindex $table_position 3]
    if {$table_vert_1_safe == "" || $table_vert_2_safe == ""} {
        log_error "bad table_position field 0 and 1"
        return -code error "bad table_position field 0 and 1"
    }
    if {$table_horz_1_safe == "" || $table_horz_2_safe == ""} {
        log_error "bad table_position field 2 and 3"
        return -code error "bad table_position field 2 and 3"
    }

    set detector_z_from_string [lindex $table_setup 3]
    if {[string is double -strict $detector_z_from_string]} {
        set detector_safe $detector_z_from_string
    } else {
        puts "no detector_z specificed for mount from table_setup default to $detector_safe"
    }

    set distanceMotor [::nScripts::getDetectorDistanceMotorName]
    ##### these motors are always moved
    array unset safedistanceArray

    array set safedistanceArray [list $distanceMotor $detector_safe \
                    camera_zoom $camera_zoom_safe \
                    beamstop_z $beamstop_z_safe \
                    gonio_phi $gonio_phi_safe \
                    sample_x $sample_x_safe  \
                    sample_y $sample_y_safe \
                    sample_z $sample_z_safe ]

    if {!$::gDevice(gonio_kappa,lockOn)} {
        set safedistanceArray(gonio_kappa) $gonio_kappa_safe
    } else {
        if {abs($gonio_kappa) >= 0.001} {
            ::dcss2 sendMessage "htos_log severe hardware trying to use robot when kappa is at $gonio_kappa"
            return -code error "Robot will work only when kappa at 0.000"
        }
    }

    if {[isMotor microspec_z]} {
        foreach {lowLimit upperLimit} [getGoodLimits microspec_z] break
        set safedistanceArray(microspec_z) $upperLimit
    }

    #########check if we need to move table motors
    switch -exact -- $move_table_option {
        not_move_table {
        }
        forced_move_table {
            set safedistanceArray(table_horz_1) $table_horz_1_safe
            set safedistanceArray(table_horz_2) $table_horz_2_safe
            set safedistanceArray(table_vert_1) $table_vert_1_safe
            set safedistanceArray(table_vert_2) $table_vert_2_safe
        }
        depend_on_table_adjust -
        default {
            if {[lsearch -exact $table_adjust table_horz_1] >= 0} {
                set safedistanceArray(table_horz_1) $table_horz_1_safe
                set safedistanceArray(table_horz_2) $table_horz_2_safe
            } elseif {[lsearch -exact $table_adjust table_horz_2] >= 0} {
                set safedistanceArray(table_horz_2) 0
            }
            
            if {[lsearch -exact $table_adjust table_vert_1] >= 0} {
                set safedistanceArray(table_vert_1) $table_vert_1_safe
                set safedistanceArray(table_vert_2) $table_vert_2_safe
            } elseif {[lsearch -exact $table_adjust table_vert_2] >= 0} {
                set safedistanceArray(table_vert_2) $::gDevice(table_vert_1, scaled)
            }
        }
    }
    return "[array names safedistanceArray]"
}
############fill move and delta list
itcl::body SampleMountingDevice::fillMoveList { move_table_option } {
    #fill safe distance array first
    fillSafeDistanceArray $move_table_option

    ######### reset array to empty
    array unset moveToAccessArray
    array unset moveBackArray

    foreach device [array names safedistanceArray] {
        set add_to_move 0
        set add_to_back 0

        #must define back_position if add_to_back = 1
        switch -exact -- $device { 
            detector_z_corr -
            detector_z -
            beamstop_z {
                #add cases that only move if less than the safe position
                set current_position $::gDevice($device,scaled)
                set deltaDistance \
                [expr $safedistanceArray($device) - $current_position]
                #there is no abs in the following line
                if { $deltaDistance > 0.001 } {
                    set add_to_move 1
                    set add_to_back 1
                    set back_position $current_position
                }
            }
            sample_z {
                #### move to a specified position after mount
                set current_position $::gDevice($device,scaled)
                set deltaDistance \
                [expr $safedistanceArray($device) - $current_position]
                if { abs($deltaDistance) > 0.001 } {
                    set add_to_move 1
                }

                set back_position [set ${device}_after]

                set afterDelta \
                [expr $safedistanceArray($device) - $back_position]
                if { abs($afterDelta) > 0.001 } {
                    ### must have add_to_move for add_to_back
                    set add_to_move 1
                    set add_to_back 1
                }
            }
            camera_zoom -
            sample_x -
            sample_y -
            gonio_kappa -
            microspec_z -
            gonio_phi {
                #add cases that do not need move back
                set current_position $::gDevice($device,scaled)
                set deltaDistance \
                [expr $safedistanceArray($device) - $current_position]
                if { abs($deltaDistance) > 0.001 } {
                    set add_to_move 1
                    set add_to_back 0
                }
            }
            default {
                #move and back if not at the safe position
                set current_position $::gDevice($device,scaled)
                set deltaDistance \
                [expr $safedistanceArray($device) - $current_position]
                if { abs($deltaDistance) > 0.001 } {
                    set add_to_move 1
                    set add_to_back 1
                    set back_position $current_position
                }
            }
        }
        if {$add_to_move} {
            set moveToAccessArray($device) $safedistanceArray($device)
            if {$add_to_back} {
                set moveBackArray($device) $back_position
            }
        }
    }
    puts "fill move list: move: [array names moveToAccessArray]"
    puts "fill move list: back: [array names moveBackArray]"
    return "move: [array get moveToAccessArray] back: [array get moveBackArray]"
}

itcl::body SampleMountingDevice::calculateTableSetup { } {
    variable ::nScripts::table_property
    variable ::nScripts::table_setup
    variable ::nScripts::table_gonio_scale

    ##################length_vert1_gonio
    set l_vert1_to_top_edge [lindex $table_property 0]
    set l_gonio_edge_to_top_edge [lindex $table_setup 0]
    set l_gonio_to_edge [lindex $table_property 2]

    if {$l_vert1_to_top_edge == "" || $l_vert1_to_top_edge == 0} {
        return -code error "bad table_property field 0"
    }
    if {$l_gonio_edge_to_top_edge  == "" || $l_gonio_edge_to_top_edge  == 0} {
        return -code error "bad table_setup field 0"
    }
    if {$l_gonio_to_edge  == "" || $l_gonio_to_edge  == 0} {
        return -code error "bad table_property field 2"
    }

    set raw_length_vert1_gonio [expr "$l_vert1_to_top_edge - $l_gonio_edge_to_top_edge - $l_gonio_to_edge"]

    if {$raw_length_vert1_gonio <= 0} {
        return -code error "bad length_vert1_gonio=$length_vert1_gonio"
    }

    #################height_vert1_gonio
    set h_vert1_to_plane [lindex $table_property 3]
    set h_gonio_to_plane [lindex $table_property 4]
    
    if {$h_vert1_to_plane  == "" || $h_vert1_to_plane  == 0} {
        return -code error "bad table_property field 3"
    }
    if {$h_gonio_to_plane  == "" || $h_gonio_to_plane  == 0} {
        return -code error "bad table_property field 4"
    }

    set raw_height_vert1_gonio [expr "$h_gonio_to_plane - $h_vert1_to_plane"]
    if {$raw_height_vert1_gonio  <= 0} {
        return -code error "bad height_vert1_gonio=$height_vert1_gonio"
    }


    #################3 length_horz1_gonio
    set l_horz1_to_top_edge [lindex $table_property 1]
    if {$l_horz1_to_top_edge == "" || $l_horz1_to_top_edge  == 0} {
        return -code error "bad table_property field 1"
    }

    #this one maybe negative
    set raw_length_horz1_gonio [expr "$l_horz1_to_top_edge - $l_gonio_edge_to_top_edge - $l_gonio_to_edge"]

    #########offset_horz1_gonio
    set raw_offset_horz1_gonio [lindex $table_setup 2]
    if {$raw_offset_horz1_gonio == "" || $raw_offset_horz1_gonio == 0} {
        return -code error "bad table_setup field 2"
    }

    ############### SCALE THEM ####################
    set length_vert1_gonio [expr $raw_length_vert1_gonio * [lindex $table_gonio_scale 0]]
    set height_vert1_gonio [expr $raw_height_vert1_gonio * [lindex $table_gonio_scale 1]]
    set length_horz1_gonio [expr $raw_length_horz1_gonio * [lindex $table_gonio_scale 2]]
    set offset_horz1_gonio [expr $raw_offset_horz1_gonio * [lindex $table_gonio_scale 3]]

    set result [format "%2.4f %2.4f %2.4f %2.4f" \
            $length_vert1_gonio \
            $height_vert1_gonio \
            $length_horz1_gonio \
            $offset_horz1_gonio]
    puts "calculateTableSetup: $result"

    return $result
}

itcl::body SampleMountingDevice::getRobotState { } {

    if { [catch {
        set operationHandle [eval start_waitable_recovery_operation get_robotstate ]
        
        set result [wait_for_operation_to_finish $operationHandle]
        set status [lindex $result 0]
        set value [lindex $result 1]
    } e ] } {
        log_error $e
        if { [lindex $e 0] == "no_hw_host" } {
            return 1
        } else {
            return -code error $e
        }
    } else {
        return $value
    }
}

itcl::body SampleMountingDevice::resetAllowed { } {
        puts "resetAllowed called"

        if { [catch {
    
        fillMoveList depend_on_table_adjust
        moveToAccessPosition 

        set operationHandle [ start_waitable_operation robot_config reset_allowed ]
        set result [wait_for_operation_to_finish $operationHandle]

        set status [lindex $result 0]
        set value [lindex $result 1]

        if { $status == "normal" && $value == "1" } {
            set result "RobotDHSOK"
        }
        if { $status == "normal" && $value == "0" } {
            set result "RobotDHSError"
        }

    } e ] } {
        log_error $e
        return -code error $e
    } else {
        return $result 
    }
}


itcl::body SampleMountingDevice::moveToCheckPoint { } {

    if { [catch {
        
        set operationHandle [eval start_waitable_operation robot_config move_to_checkpoint [ getDeltaGonioPos ] ]
        wait_for_operation_to_finish $operationHandle

    } e ] } {
        log_error $e
        return -code error $e
    } else {
        return "RobotDHSOK"
    }
}

itcl::body SampleMountingDevice::check { tool } {

        if { [catch {

        fillMoveList depend_on_table_adjust
        moveToAccessPosition 
        
        set operationHandle [eval start_waitable_operation robot_config check_$tool ]
        wait_for_operation_to_finish $operationHandle
        
    } e ] } {
        log_error $e
        return -code error $e
    } else {
        return "RobotDHSOK"
    }
}

itcl::body SampleMountingDevice::openGripper { } {

        if { [catch {
    
        set operationHandle [ start_waitable_operation robot_config open_gripper ]
        wait_for_operation_to_finish $operationHandle
    
    } e ] } {
        log_error $e
        return -code error $e
    } else {
        return "RobotDHSOK"
    }
}

itcl::body SampleMountingDevice::heatGripper { heatsecs } {
        
    if { [catch {
    
        set operationHandle [ start_waitable_operation robot_config heat_gripper $heatsecs ]
        wait_for_operation_to_finish $operationHandle
    
    } e ] } {
        log_error $e
        return -code error $e
    } else {
        return "RobotDHSOK"
    }
}

itcl::body SampleMountingDevice::returnDumbbell { } {
        
    if { [catch {
    
        set operationHandle [start_waitable_operation robot_config return_dumbbell ]
        wait_for_operation_to_finish $operationHandle
        
        set operationHandle [ start_waitable_operation robot_config heat_gripper 20 done]
        wait_for_operation_to_finish $operationHandle
    
    } e ] } {
        log_error $e
        return -code error $e
    } else {
        return "RobotDHSOK"
    }
}

itcl::body SampleMountingDevice::portJamUserAction { args } {
    if {[catch {
        set operationHandle [eval start_waitable_operation robot_config port_jam_action $args]
        set result [wait_for_operation_to_finish $operationHandle]
    } e]} {
        log_error $e
        return -code error $e
    } else {
        return $result
    }
}

itcl::body SampleMountingDevice::calibrateMagnet { { find_magnet 0 } { quick 0 } } {
    if { [catch {
    
        set operationHandle [eval start_waitable_operation robot_calibrate magnet_post $find_magnet $quick]
        set result [wait_for_operation_to_finish $operationHandle]
        
    } e ] } {
        log_error $e
        return -code error $e
    } else { 
        return $result
    }
}
itcl::body SampleMountingDevice::calibrateCassette { cassettes { init 0 } } {
    set ll [string length $cassettes]
    if { $ll <= 0 || $ll > 3 } {
        return -code error "Cassettes should be any one or more of lmr."
    }
    for {set index 0} {$index < $ll} {incr index} {
        set one_cassette [string range $cassettes $index $index]
        if {[lsearch -exact $validcassetteList $one_cassette] < 0} {
            return -code error \
            "Cassettes should be any one or more of $validcassetteList."
        }
    }

    #set heatsecs 10
  
    if { [catch {
        set operationHandle [eval start_waitable_operation robot_calibrate cassette $cassettes $init  ]
        set result [wait_for_operation_to_finish $operationHandle]
    } e ] } {
        log_error $e
        return -code error $e
    } else { 
        return $result
    }
 }

itcl::body SampleMountingDevice::calibrateGoniometer { { init 0 } } {
    block_all_motors
    #set argument "0 0 5"
    if { [catch {
        # not include_move_table
        fillMoveList not_move_table
        moveToAccessPosition
    } e ] } {
        log_error $e
        return -code error $e
    }

    #check if need to do sample_xyz calibration
    autoSampleCalibrate
    sampleOnOffCalibrate
    
    #this function must NOT be called before moveToAccessPosition
    set argument "$init [getDeltaGonioPos]"
    if { [catch {
        variable ::nScripts::table_position

        set operationHandle [eval start_waitable_operation robot_calibrate goniometer $argument]
        set result [wait_for_operation_to_finish $operationHandle]

        saveCurrentTablePosition
        syncLaserSensorToMotor $table_position

    } e ] } {
        log_error $e
        return -code error $e
    }

    if { [catch {
        moveBackToOriginalPosition
    } e ] } {
        log_error $e
    }
    unblock_all_motors
    return $result
}


itcl::body SampleMountingDevice::checkGoniometerReachable { } {
    block_all_motors
    if { [catch {
        fillMoveList not_move_table
        moveToAccessPosition
    } e ] } {
        log_error $e
        return -code error $e
    }

    #this function must NOT be called before moveToAccessPosition
    set argument "0 [getDeltaGonioPos]"
    if { [catch {
        set operationHandle [eval start_waitable_operation robot_calibrate check_goniometer_reachable $argument]
        set result [wait_for_operation_to_finish $operationHandle]

    } e ] } {
        log_error $e
        return -code error $e
    }

    if { [catch {
        moveBackToOriginalPosition
    } e ] } {
        log_error $e
    }
    unblock_all_motors
    return $result
}


itcl::body SampleMountingDevice::newGonioCAL { } {
    block_all_motors
    if { [catch {
        # not include_move_table
        fillMoveList not_move_table
        moveToAccessPosition
    } e ] } {
        log_error $e
        return -code error $e
    }
    #this function must NOT be called before moveToAccessPosition
    set argument "[getDeltaGonioPos]"
    set need_goHome 0
    if { [catch {
        variable ::nScripts::table_position

        #cool the tong and move to goniometer
        set operationHandle [eval start_waitable_operation robot_calibrate prepare_goniometer $argument]
        set result [wait_for_operation_to_finish $operationHandle]
        set need_goHome 1

        #start goniometer cal with option "init"
        set operationHandle [eval start_waitable_operation robot_calibrate goniometer 1 $argument]
        set result [wait_for_operation_to_finish $operationHandle]

        #save table position and go home
        saveCurrentTablePosition
        syncLaserSensorToMotor $table_position

        set need_goHome 0
        start_recovery_operation robot_standby low_power
    } e ] } {
        log_error $e
        if {$need_goHome} {
            set need_goHome 0
            start_recovery_operation robot_standby low_power
        }
        return -code error $e
    }

    ### we ignore errors here
    if { [catch {
        moveBackToOriginalPosition
    } e ] } {
        log_error $e
    }
    unblock_all_motors
    return $result
}
itcl::body SampleMountingDevice::specialGonioCAL { dx dy dz du } {
    block_all_motors
    if { [catch {
        # not include_move_table
        fillMoveList not_move_table
        moveToAccessPosition
    } e ] } {
        log_error $e
        return -code error $e
    }
    if { [catch {
        set operationHandle [eval start_waitable_operation robot_calibrate goniometer 0 $dx $dy $dz $du]
        set result [wait_for_operation_to_finish $operationHandle]
    } e ] } {
        log_error $e
        return -code error $e
    }

    unblock_all_motors
    return $result
}
itcl::body SampleMountingDevice::newSpecialGonioCAL { dx dy dz du } {
    block_all_motors
    if { [catch {
        # not include_move_table
        fillMoveList not_move_table
        moveToAccessPosition
    } e ] } {
        log_error $e
        return -code error $e
    }
    set argument "$dx $dy $dz $du"
    set need_goHome 0
    if { [catch {
        #cool the tong and move to goniometer
        set operationHandle [eval start_waitable_operation robot_calibrate prepare_goniometer $argument]
        set result [wait_for_operation_to_finish $operationHandle]
        set need_goHome 1

        #start goniometer cal with option "init"
        set operationHandle [eval start_waitable_operation robot_calibrate goniometer 1 $argument]
        set result [wait_for_operation_to_finish $operationHandle]

        start_recovery_operation robot_standby low_power
        set need_goHome 0
    } e ] } {
        log_error $e
        if {$need_goHome} {
            set need_goHome 0
            start_recovery_operation robot_standby low_power
        }
        return -code error $e
    }
    unblock_all_motors
    return $result
}
itcl::body SampleMountingDevice::getGonioCALDATA { } {
    fillMoveList not_move_table
    return "$sample_z_safe [getDeltaGonioPos]"
}
itcl::body SampleMountingDevice::calibrateBeamLineTool { { init 0 } } {
    if { [catch {
        set operationHandle [eval start_waitable_operation robot_calibrate beamline_tool $init ]
        set result [wait_for_operation_to_finish $operationHandle]
    } e ] } {
        log_error $e
        return -code error $e
    } else { 
        return $result
    }
}
itcl::body SampleMountingDevice::oneCalibrate { } {
    variable ::nScripts::robot_cal_config

    foreach {mask_auto mask_tool mask_cas mask_gonio mask_find mask_quick mask_left mask_middle mask_right } $robot_cal_config break

    if {$mask_tool == "1"} {
        calibrateMagnet 1 0
    }
    ###call to allow change during run
    foreach {mask_auto mask_tool mask_cas mask_gonio mask_find mask_quick mask_left mask_middle mask_right } $robot_cal_config break
    if {$mask_cas} {
        set cas ""
        if {$mask_left == "1"} {
            append cas l
        }
        if {$mask_middle == "1"} {
            append cas m
        }
        if {$mask_right == "1"} {
            append cas r
        }
        if {$cas != ""} {
            calibrateCassette $cas 0
        }
    }
    ###call to allow change during run
    foreach {mask_auto mask_tool mask_cas mask_gonio mask_find mask_quick mask_left mask_middle mask_right } $robot_cal_config break
    if {$mask_gonio} {
        calibrateGoniometer 0
    }
}

itcl::body SampleMountingDevice::mountBeamLineTool { } {
    if { [catch {
        fillMoveList depend_on_table_adjust
        moveToAccessPosition
    } e ] } {
        log_error $e
        return -code error $e
    }
    #check if need to do sample_xyz calibration
    autoSampleCheck
    sampleOffGoniometer
    
    #this function must NOT be called before moveToAccessPosition
    set argument [getDeltaGonioPos]
    if { [catch {
        set operationHandle [eval start_waitable_operation robot_calibrate mount_beamline_tool $argument ]
        set result [wait_for_operation_to_finish $operationHandle]
    } e ] } {
        log_error $e
        return -code error $e
    }
    if { [catch {
        moveBackToOriginalPosition
    } e ] } {
        log_error $e
    }
    return $result
}
itcl::body SampleMountingDevice::dismountBeamLineTool { } {
    if {[isOperation scan3DSetup]} {
        if {[catch {
            ### now we need the scan3DSetup operation.  BluIce needs it.
            set h [start_waitable_operation scan3DSetup clear]
            wait_for_operation_to_finish $h
        } errMsg]} {
            puts "rastering clear failed: $errMsg"
        }
    }
    if {[isOperation rasterRunsConfig]} {
        if {[catch {
            set h [start_waitable_operation rasterRunsConfig deleteAllRasters]
            wait_for_operation_to_finish $h
        } errMsg]} {
            puts "rasterRun clear failed: $errMsg"
        }
    }
    if {[isOperation spectrometerWrap]} {
        if {[catch {
            set h [start_waitable_operation spectrometerWrap clear_result_files]
            wait_for_operation_to_finish $h
        } errMsg]} {
            puts "microspec clear failed: $errMsg"
        }
    }

    if { [catch {
        fillMoveList depend_on_table_adjust
        moveToAccessPosition
    } e ] } {
        log_error $e
        return -code error $e
    }
    #check if need to do sample_xyz calibration
    autoSampleCheck
    sampleOnGoniometer
    
    #this function must NOT be called before moveToAccessPosition
    set argument [getDeltaGonioPos]
    if { [catch {
    
        set operationHandle [eval start_waitable_operation robot_calibrate dismount_beamline_tool $argument]
        set result [wait_for_operation_to_finish $operationHandle]
    } e ] } {
        log_error $e
        return -code error $e
    }
    if { [catch {
        moveBackToOriginalPosition
    } e ] } {
        log_error $e
    }
    return $result
}
itcl::body SampleMountingDevice::moveToGoniometer { } {
    if { [catch {
        fillMoveList not_move_table
        moveToAccessPosition
    } e ] } {
        log_error $e
        return -code error $e
    }

    #this function must NOT be called before moveToAccessPosition
    set argument [getDeltaGonioPos]

    #move robot to goniometer standby position
    if { [catch { 
        set operationHandle [eval start_waitable_operation robot_calibrate move_to_goniometer $argument]
        set result [wait_for_operation_to_finish $operationHandle]
    } e ] } {
        log_error $e
        return -code error $e
    } else { 
        return $result
    }
}
itcl::body SampleMountingDevice::teachGoniometer { } {
    set argument [getDeltaGonioPos]

    #save current position to goniometer position
    if { [catch { 
        set operationHandle [eval start_waitable_operation robot_calibrate save_goniometer_position $argument]
        set result [wait_for_operation_to_finish $operationHandle]
    } e ] } {
        log_error $e
        return -code error $e
    } else { 
        return $result
    }
}
itcl::body SampleMountingDevice::moveHome { } {
    set argument [getDeltaGonioPos]

    if { [catch { 
        set operationHandle [eval start_waitable_operation robot_calibrate move_home $argument]
        set result [wait_for_operation_to_finish $operationHandle]
    } e ] } {
        log_error $e
        return -code error $e
    } else { 
        return $result
    }
}
itcl::body SampleMountingDevice::jumpHome { } {
    if { [catch { 
        set operationHandle [eval start_waitable_operation robot_calibrate jump_home]
        set result [wait_for_operation_to_finish $operationHandle]
    } e ] } {
        log_error $e
        return -code error $e
    } else { 
        return $result
    }
}
itcl::body SampleMountingDevice::moveToBeamlineTool { } {
    #move robot to beamlineTool standby position
    if { [catch { 
        set operationHandle [eval start_waitable_operation \
        robot_calibrate move_to_beamline_tool]
        set result [wait_for_operation_to_finish $operationHandle]
    } e ] } {
        log_error $e
        return -code error $e
    } else { 
        return $result
    }
}
itcl::body SampleMountingDevice::teachBeamlineTool { } {
    #save current position to beamline tool position
    if { [catch { 
        set operationHandle [eval start_waitable_operation \
        robot_calibrate save_beamline_tool_position]
        set result [wait_for_operation_to_finish $operationHandle]
    } e ] } {
        log_error $e
        return -code error $e
    } else { 
        return $result
    }
}
itcl::body SampleMountingDevice::moveCrystal { args } {
    set Nargs [ llength $args ]

    if { $Nargs == 0 } {
        return -code error "ERROR: Invalid number of ports specified"
    }

    for { set i 0 } {$i < $Nargs } { incr i } {
        set OnePair [lindex $args $i]
        if { [string length $OnePair] < 8 } {
            return -code error "Invalid pair length specified: $OnePair, should be something like lA8->rB1."
        }
        set indexArrow [string first "->" $OnePair]
        if { $indexArrow < 3 } {
            return -code error "Invalid pair format specified: $OnePair, should be something like lA8->rB1."
        }
        set S_Cassette [string index $OnePair 0]
        set S_Column [string index $OnePair 1]
        set end_row [expr $indexArrow - 1]
        set S_Row [string range $OnePair 2 $end_row]

        set targetIndex [expr $indexArrow + 2]

        set T_Cassette [string index $OnePair $targetIndex]
        incr targetIndex
        set T_Column [string index $OnePair $targetIndex]
        incr targetIndex
        set T_Row [string range $OnePair $targetIndex end]

        puts "one pair: $S_Cassette $S_Column $S_Row ---> $T_Cassette $T_Column $T_Row"


        if { ![ validPort $S_Cassette $S_Row $S_Column ] || ![ validPort $T_Cassette $T_Row $T_Column ] } {
            return -code error "Invalid port specified."
        }
    }

    set heatsecs 10

    set need_goHome 0

    if { [catch {

        set operationHandle [eval start_waitable_operation prepare_move_crystal $args]
        wait_for_operation_to_finish $operationHandle

        set need_goHome 1

        set operationHandle [eval start_waitable_operation move_crystal $args]
        set result [wait_for_operation_to_finish $operationHandle]

        set need_goHome 0

        start_recovery_operation robot_standby
        
    } e ] } {
        if {$need_goHome} {
            set need_goHome 0
            start_recovery_operation robot_standby
        }
        log_error $e
        return -code error $e
    } else { 
        return $result
    }

}
itcl::body SampleMountingDevice::mountCrystal { cassette row column wash_cycle } {
    variable ::nScripts::sil_config

    set fastMode [lindex $sil_config 4]

    block_all_motors
    
    if { ![ validPort $cassette $row $column ] } {
        return -code error "Invalid port specified."
    }

    set need_goHome 0

    if { [catch {
        fillMoveList depend_on_table_adjust

        set argument "$cassette $row $column [getDeltaGonioPosFromFutureMotor]"
        set operationHandle [eval start_waitable_operation prepare_mount_crystal $argument]
        set result [wait_for_operation $operationHandle]

        if {[checkIfRecoverableError $result]} {
            #the above call will also change fillMoveList
            #restart the operation
            set argument "$cassette $row $column [getDeltaGonioPosFromFutureMotor]"
            set operationHandle [eval start_waitable_operation prepare_mount_crystal $argument]
            set result [wait_for_operation $operationHandle]
        }

        set status [lindex $result 0]
    
        #first reply must be update or normal to continue
        if { $status != "update" && $status != "normal" } {
            return -code error "$result"
        }

        if { $status == "normal" && [llength $result] >=4 } {
            if {[lindex $result 1] == "n" && \
                [lindex $result 2] == "0" && \
                [lindex $result 3] == "N" } {
                #empty port
                return $result
            }
        }

        set need_goHome 1

        moveToAccessPosition
        #check if need to do sample_xyz calibration
        ### create command
        set prepare_cmd [list start_waitable_operation prepare_mount_crystal]
        lappend prepare_cmd $cassette $row $column
        set deltaGonioPos [getDeltaGonioPos]
        eval lappend prepare_cmd $deltaGonioPos
        autoSampleCheck $prepare_cmd
        sampleOffGoniometer

        #this function must NOT be called before moveToAccessPosition
        set argument "$cassette $row $column $deltaGonioPos $wash_cycle"

        if { $status == "update" } {
            wait_for_operation_to_finish $operationHandle
        }

        set operationHandle \
        [eval start_waitable_operation mount_crystal $argument]
        #set result [wait_for_operation_to_finish $operationHandle]
        set result [readBarcodeWhileWaitForOperationToFinish $operationHandle]

        set need_goHome 0

        if {([lindex $result 1] != "n" || \
        [lindex $result 2] != "0" || \
        [lindex $result 3] != "N") && 
        [catch sampleOnGoniometer errMsg]} {
            start_recovery_operation robot_standby rescue_sample
            set result "sample not on goniometer after mount"
            log_severe $result
            log_severe "Robot maybe failed to pull out the sample from cassette"
        } else {
            if {$fastMode == "1"} {
                start_recovery_operation robot_standby skip_heating
            } else {
                start_recovery_operation robot_standby
            }
        }
    } e ] } {
        if {[lindex $e 0] == "normal"} {
            #### this is the case no need to mount
            return $e
        }

        if {$need_goHome} {
            set need_goHome 0
            start_recovery_operation robot_standby
        }

        if {$e == "sample_still_on_goniometer"} {
            if { [catch {
                moveBackToOriginalPosition
            } e ] } {
                log_error $e
            }
        }
        log_error $e
        warnDetectorZ
        return -code error $e
    }

    ### we ignore errors here
    if { [catch {
        moveBackToOriginalPosition
    } e ] } {
        log_error $e
    }
    unblock_all_motors

    return $result
}

itcl::body SampleMountingDevice::dismountCrystal { cassette row column } {
    block_all_motors

    if { ![ validPort $cassette $row $column ] } {
        return -code error "Invalid port specified."
    }
    
    set need_goHome 0

    if { [catch {

        fillMoveList depend_on_table_adjust
        set operationHandle [eval start_waitable_operation prepare_dismount_crystal $cassette $row $column [ getDeltaGonioPosFromFutureMotor ] ]
        set result [wait_for_operation $operationHandle]

        if {[checkIfRecoverableError $result]} {
            set operationHandle [eval start_waitable_operation prepare_dismount_crystal $cassette $row $column [ getDeltaGonioPosFromFutureMotor ] ]
            set result [wait_for_operation $operationHandle]
        }
        set status [lindex $result 0]
    
        #first reply must be update to continue
        if { $status != "update" && $status != "normal" } {
            return -code error $result
        }
        if { $status == "normal" && [llength $result] >=4 } {
            if {[lindex $result 1] == "n" && \
                [lindex $result 2] == "0" && \
                [lindex $result 3] == "N" } {
                #nothing on goniometer
                return $result
            }
        }

        set need_goHome 1

        moveToAccessPosition
        #check if need to do sample_xyz calibration
        ### create command
        set prepare_cmd [list start_waitable_operation prepare_dismount_crystal]
        lappend prepare_cmd $cassette $row $column
        set deltaGonioPos [getDeltaGonioPos]
        eval lappend prepare_cmd $deltaGonioPos
        autoSampleCheck $prepare_cmd
        sampleOnGoniometer
        
        if { $status == "update"  } {
            wait_for_operation_to_finish $operationHandle
        }
        
        set operationHandle [eval start_waitable_operation dismount_crystal $cassette $row $column $deltaGonioPos]
        set result [wait_for_operation_to_finish $operationHandle]

        set need_goHome 0

        start_recovery_operation robot_standby
    } e ] } {
        if {[lindex $e 0] == "normal"} {
            return $e
        }
        log_error $e
        warnDetectorZ
        if {$need_goHome} {
            set need_goHome 0
            start_recovery_operation robot_standby
        }
        if {$e == "no_sample_on_goniometer"} {
            log_severe "no sample on goniometer before dismount."
            log_severe " Please call staff to clear mounted if really there is no sample"
        }
        return -code error $e
    }

    if {[catch sampleOffGoniometer errMsg]} {
        set result "maybe sample still on goniometer after dismount"
        log_warning $result
    }

    ### we ignore errors here
    if { [catch {
        moveBackToOriginalPosition
    } e ] } {
        log_error $e
    }

    unblock_all_motors
    return $result
}
itcl::body SampleMountingDevice::washCrystal { times } {
    block_all_motors

    #puts "wash crystal $times"

    set need_goHome 0

    if { [catch {
        fillMoveList depend_on_table_adjust
        #puts "start prepare operation"
        set operationHandle [eval start_waitable_operation prepare_wash_crystal $times [ getDeltaGonioPosFromFutureMotor ] ]
        set result [wait_for_operation $operationHandle]

        if {[checkIfRecoverableError $result]} {
            set operationHandle [eval start_waitable_operation prepare_wash_crystal $times [ getDeltaGonioPosFromFutureMotor ]]
            set result [wait_for_operation $operationHandle]
        }
        set status [lindex $result 0]
    
        #first reply must be update to continue
        if { $status != "update" && $status != "normal" } {
            return -code error $result
        }
        if { $status == "normal" && [lindex $result 1] == "nothing" } {
            return $result
        }
        #puts "move to access positoin"

        set need_goHome 1

        moveToAccessPosition
        #check if need to do sample_xyz calibration
        ### create command
        set prepare_cmd [list start_waitable_operation prepare_wash_crystal]
        lappend prepare_cmd $times
        set deltaGonioPos [getDeltaGonioPos]
        eval lappend prepare_cmd $deltaGonioPos
        autoSampleCheck $prepare_cmd
        sampleOnGoniometer
        
        if { $status == "update"  } {
            wait_for_operation_to_finish $operationHandle
        }
        
        #puts "start wash operation"
        set operationHandle [eval start_waitable_operation wash_crystal $times $deltaGonioPos]
        set result [wait_for_operation_to_finish $operationHandle]

        set need_goHome 0

        if {[catch sampleOnGoniometer errMsg]} {
            start_recovery_operation robot_standby rescue_sample
            set result "sample not on goniometer after wash"
            log_severe $result
        } else {
            start_recovery_operation robot_standby
        }
    } e ] } {
        if {[lindex $e 0] == "normal"} {
            return $e
        }

        log_error $e
        warnDetectorZ

        if {$need_goHome} {
            set need_goHome 0
            start_recovery_operation robot_standby
        }
        if {$e == "no_sample_on_goniometer"} {
            log_severe "no sample on goniometer before washing"
            log_severe " Please call staff to clear mounted if really there is no sample"
        }
        return -code error $e
    }

    ### we ignore errors here
    if { [catch {
        moveBackToOriginalPosition
    } e ] } {
        log_error $e
    }

    unblock_all_motors
    return $result
}

itcl::body SampleMountingDevice::mountNextCrystal { cassette row column cassette_nxt row_nxt column_nxt wash_cycle } {
    variable ::nScripts::sil_config

    set fastMode [lindex $sil_config 4]

    block_all_motors
    
    if { ![ validPort $cassette $row $column ] || ![ validPort $cassette_nxt $row_nxt $column_nxt ] } {
        return -code error "Invalid port specified."
    }
    
    set need_goHome 0

    if { [catch {

        fillMoveList depend_on_table_adjust
        set operationHandle [eval start_waitable_operation prepare_mount_next_crystal $cassette $row $column $cassette_nxt $row_nxt $column_nxt [ getDeltaGonioPosFromFutureMotor ] ]
        set result [wait_for_operation $operationHandle]

        if {[checkIfRecoverableError $result]} {
            set operationHandle [eval start_waitable_operation prepare_mount_next_crystal $cassette $row $column $cassette_nxt $row_nxt $column_nxt [ getDeltaGonioPosFromFutureMotor ] ]
            set result [wait_for_operation $operationHandle]
        }

        set status [lindex $result 0]
    
        if { $status != "update" && $status != "normal" } {
            return -code error $result
        }
        if { $status == "normal" && [llength $result] >=8 } {
            if {[lindex $result 1] == "n" && \
                [lindex $result 2] == "0" && \
                [lindex $result 3] == "N" && \
                [lindex $result 4] == "normal" && \
                [lindex $result 5] == "n" && \
                [lindex $result 6] == "0" && \
                [lindex $result 7] == "N" } {
                #nothing on goniometer with empty source port
                return $result
            }
        }

        set need_goHome 1

        moveToAccessPosition
        #check if need to do sample_xyz calibration
        ### create command
        set prepare_cmd [list start_waitable_operation prepare_mount_next_crystal]
        lappend prepare_cmd $cassette $row $column $cassette_nxt $row_nxt $column_nxt
        set deltaGonioPos [getDeltaGonioPos]
        eval lappend prepare_cmd $deltaGonioPos
        autoSampleCheck $prepare_cmd
        sampleOnGoniometer

        if { $status == "update" } {
            wait_for_operation_to_finish $operationHandle
        }

        set operationHandle [eval start_waitable_recovery_operation mount_next_crystal $cassette $row $column $cassette_nxt $row_nxt $column_nxt $deltaGonioPos $wash_cycle]
        #set result [wait_for_operation_to_finish $operationHandle]
        set result [readBarcodeWhileWaitForOperationToFinish $operationHandle]

        set need_goHome 0

        if {[llength $result] >=8 && \
        [lindex $result 4] == "normal" && \
        [lindex $result 5] != "n" && \
        [lindex $result 6] != "0" && \
        [lindex $result 7] != "N" && \
        [catch sampleOnGoniometer errMsg]} {
            start_recovery_operation robot_standby rescue_sample
            set result "sample not on goniometer after mount next"
            log_severe $result
        } else {
            if {$fastMode == "1"} {
                start_recovery_operation robot_standby skip_heating
            } else {
                start_recovery_operation robot_standby
            }
        }
    } e ] } {
        if {[lindex $e 0] == "normal"} {
            return $e
        }
        if {$need_goHome} {
            set need_goHome 0
            start_recovery_operation robot_standby
        }
        log_error $e
        warnDetectorZ
        return -code error $e
    }

    ### we ignore errors here
    if { [catch {
        moveBackToOriginalPosition
    } e ] } {
        log_error $e
    }
    unblock_all_motors

    return $result
}

itcl::body SampleMountingDevice::validPort { cassette row column } {

    set portOK 0

    set cassOK [ lsearch -exact $validcassetteList $cassette ]
    set colOK [ lsearch -exact $validcolumnList $column ]
    set rowOK [ lsearch -exact $validrowList $row ]

    if { $cassOK != -1 && $colOK != -1 && $rowOK != -1 } {
        set portOK 1
    }

    return $portOK
}

itcl::body SampleMountingDevice::calculateDeltaGonioPos { V1 Pitch H1 Yaw XAdjust YAdjust } {
    set length_adjust \
    [ expr $length_horz1_gonio*(1 - cos($Yaw)) + $offset_horz1_gonio*sin($Yaw)]
    
    set adjusted_length_vert1_gonio [expr $length_vert1_gonio - $length_adjust]

    set dx_robot [ expr $adjusted_length_vert1_gonio*(1- cos($Pitch)) + $height_vert1_gonio*sin($Pitch) + $length_adjust + $XAdjust ]
    set dz_robot [ expr $adjusted_length_vert1_gonio*sin($Pitch) + $height_vert1_gonio*(cos($Pitch) - 1) + $V1 ]

    set dy_robot [ expr $offset_horz1_gonio * (1-cos($Yaw)) - $length_horz1_gonio * sin($Yaw) - $H1 + $YAdjust ]

    #####3 DU is very small, you can ignore. anyway here is the formylar
    set du_robot [expr atan(sin($Yaw)/(cos($Pitch) * cos($Yaw)))]
    set du_robot [::nScripts::deg $du_robot]

    #### do not use du_robot until cavity toolset is put into all codes.
    set du_robot 0
    
    return [ format "%2.4f %2.4f %2.4f %2.4f" $dx_robot $dy_robot $dz_robot $du_robot] 

}
itcl::body SampleMountingDevice::getDeltaGonioPos { } {
    checkTablePosition
    return [getDeltaGonioPosFromMotor]
}
itcl::body SampleMountingDevice::getDeltaGonioPosFromMotor { } {
    set raw_V1 $::gDevice(table_vert_1,scaled)
    set raw_V2 $::gDevice(table_vert_2,scaled)
    set raw_H1 $::gDevice(table_horz_1,scaled)
    set raw_H2 $::gDevice(table_horz_2,scaled)

    return [getDeltaGonioPosFromMotorArgument $raw_V1 $raw_V2 $raw_H1 $raw_H2]
}
itcl::body SampleMountingDevice::getDeltaGonioPosFromFutureMotor { } {
    #get default value: current value
    set raw_V1 $::gDevice(table_vert_1,scaled)
    set raw_V2 $::gDevice(table_vert_2,scaled)
    set raw_H1 $::gDevice(table_horz_1,scaled)
    set raw_H2 $::gDevice(table_horz_2,scaled)

    #if the motor name exist in moveArray, then take the future value
    if {[info exists moveToAccessArray(table_vert_1)]} {
        set raw_V1 moveToAccessArray(table_vert_1)
    }
    if {[info exists moveToAccessArray(table_vert_2)]} {
        set raw_V2 moveToAccessArray(table_vert_2)
    }
    if {[info exists moveToAccessArray(table_horz_1)]} {
        set raw_H1 moveToAccessArray(table_horz_1)
    }
    if {[info exists moveToAccessArray(table_horz_2)]} {
        set raw_H2 moveToAccessArray(table_horz_2)
    }

    return [getDeltaGonioPosFromMotorArgument $raw_V1 $raw_V2 $raw_H1 $raw_H2]
}
itcl::body SampleMountingDevice::getDeltaGonioPosFromMotorArgument { raw_V1 raw_V2 raw_H1 raw_H2 } {
    variable ::nScripts::motor_to_robot_config
    variable ::nScripts::motor_z_scale

    #calculate V1, H1, pitch and yaw from the real motors.
    # 111111111 get raw data
    set raw_l_V2_V1 [expr $::gDevice(table_v2_z,scaled) \
                         -$::gDevice(table_v1_z,scaled)]

    set raw_l_H2_H1 $::gDevice(table_h2_z,scaled)

    puts "raw data: $raw_V1 $raw_V2 $raw_l_V2_V1 $raw_H1 $raw_H2 $raw_l_H2_H1"

    #222222222 transform according to calibration
    set V1_a [lindex $motor_to_robot_config 0]
    set V1_b [lindex $motor_to_robot_config 1]
    set V1_c [lindex $motor_to_robot_config 2]
    set V1_d [lindex $motor_to_robot_config 3]
    set V2_a [lindex $motor_to_robot_config 4]
    set V2_b [lindex $motor_to_robot_config 5]
    set H1_a [lindex $motor_to_robot_config 6]
    set H1_c [lindex $motor_to_robot_config 7]
    set H2_a [lindex $motor_to_robot_config 8]

    ## V1 and Pitch
    set V1 [expr $raw_V1 * $V1_a + $V1_b]
    set V2_tmp [expr $raw_V2 * $V2_a + $V2_b]
    set l_V2_V1_tmp [expr $raw_l_V2_V1 * $motor_z_scale]
    if {$l_V2_V1_tmp <= 0} {
        log_severe "bad distance between V1 and V2: $l_V2_V1_tmp"
        return -code error "bad distance between V1 and V2: $l_V2_V1_tmp" 
    }
    set Pitch [expr ($V2_tmp - $V1) / $l_V2_V1_tmp]
    set Pitch [expr atan($Pitch)]

    ##H1 and Yaw
    set H1 [expr $raw_H1 * $H1_a]
    set H2_tmp [expr $raw_H2 * $H2_a]
    if {$raw_l_H2_H1 <= 0} {
        log_severe "bad distance between H1 and H2: $raw_l_H2_H1"
        return -code error "bad distance between H1 and H2: $raw_l_H2_H1"
    }
    set Yaw [expr $H2_tmp / $raw_l_H2_H1]
    # atan here is not very accurate from theory, but small angle is OK
    set Yaw [expr atan($Yaw)]

    puts "cooked data: $V1 [::nScripts::deg $Pitch] $H1 [::nScripts::deg $Yaw]"

    ########## XAdjust: X move may be caused by V1 and H1 in real world #####
    set XAdjust [expr $raw_V1 * $V1_c + $raw_H1 * $H1_c]
    puts "x adjust in motors: $XAdjust"

    ########## YAdjust: Y move may be caused by V1 real world #####
    set YAdjust [expr $raw_V1 * $V1_d]
    puts "y adjust in motors: $YAdjust"


    return [calculateDeltaGonioPos $V1 $Pitch $H1 $Yaw $XAdjust $YAdjust]
}

itcl::body SampleMountingDevice::resetProcedure { } {
    variable ::nScripts::robotResetStep
    variable ::nScripts::screening_msg
   #gContinueResetProcedure set by the continueResetProcedure operation 
    global gContinueResetProcedure

    set screening_msg "Robot reset"

    block_all_motors
    
    set gContinueResetProcedure 0
    
    if { [catch {
        
        for { set step 1 } {$step < 22} {incr step} {
            
            performNextRobotResetStep $step
            
            set robotResetStep $step

            #loop until we get an abort or the continueResetProcedure is called
            set gContinueResetProcedure 0
            set screening_msg "waiting staff input"

            while { $gContinueResetProcedure == 0 } {
                wait_for_time 200
            }
            set screening_msg "doing robot reset step $step"
        }
        set screening_msg ""
    } errorResult ] } {
        set gContinueResetProcedure 0 
        set robotResetStep 0
        set screening_msg ""
        
        log_error $errorResult
        return -code error $errorResult
   }

    set gContinueResetProcedure 0 
    set robotResetStep 0
}
itcl::body SampleMountingDevice::delayReset { } {
    if { [catch {
        set operationHandle [eval start_waitable_operation robot_config delay_reset [getDeltaGonioPos]]
        wait_for_operation_to_finish $operationHandle

    } e ] } {
        log_error $e
        return -code error $e
    } else {
        return "RobotDHSOK"
    }
}
itcl::body SampleMountingDevice::skipReset { } {
    if { [catch {
        set operationHandle [eval start_waitable_operation robot_config sample_confirmed_on_goniometer]
        wait_for_operation_to_finish $operationHandle

    } e ] } {
        log_error $e
        return -code error $e
    } else {
        return "RobotDHSOK"
    }
}
#03/16/04: P20 stores goniometer position when MOTOR V1=V2=H1=H2=0
itcl::body SampleMountingDevice::performNextRobotResetStep { step_ } {
    
    switch $step_ {
      1 {
            # do not use robot for Screening
            set handle [start_waitable_operation sequenceSetConfig setConfig useRobot "0"]
            wait_for_operation $handle
            
            # send dismount message to dcss to reset the crystal
            #state to "no crystal mounted"
            #set handle [start_waitable_operation sequenceSetConfig setConfig dismount 1]
            #wait_for_operation $handle

            wait_for_time $RESET_WAIT_TIME

       }
       2 {
            #Press the green hutch reset button.
            wait_for_time $RESET_WAIT_TIME
      }
      3 {
        #The robot server now performs a check to see if a Reset is allowed.
            wait_for_time $RESET_WAIT_TIME
      }
      4 {
            resetAllowed
            
            #The robot will now move the gripper arm to an accessible location
      }
      5 {
            moveToCheckPoint
            #Manually remove any crystal from the goniometer.
      }
      6 {
            #If the gripper is closed use a heat gun to melt any excess ice
            #on the gripper.
            wait_for_time $RESET_WAIT_TIME
      }
      7 {
            #The robot will now open the grippers
            wait_for_time $RESET_WAIT_TIME
      }
      8 {
            openGripper
            #Please remove the dumbbell magnet and any crystal on it.
            wait_for_time $RESET_WAIT_TIME
        }
        9 {
        #Please remove any crystal from inside the gripper cavity.
            wait_for_time $RESET_WAIT_TIME
        }
        10 {
            #The robot will now move the gripper to the heating chamber and
            #dry the gripper arms.
            wait_for_time $RESET_WAIT_TIME
        }
        11 {
            heatGripper 10
         #The robot gripper will now try to retrieve a dumbbell magnet.
        }
        12 {
            check dumbbell
            #The robot will now move the gripper arm to an accessible location
        }
        13 {
            moveToCheckPoint
            
          openGripper

            #Remove the dumbbell magnet and any crystal on it.
        }
        14 {
            #The robot will now move the gripper to the heating chamber and
            #dry the gripper arms
            wait_for_time $RESET_WAIT_TIME
    }
        15 {
            heatGripper 0
            #The robot will now move the gripper arm to an accessible location
            #above the dispensing Dewar, with the lid closed.
        }
        16 {
            moveToCheckPoint
            #Use a heat gun to make sure the dumbbell magnet is free
            #from ice and dry
        }
        17 {
            #Please replace the dumbbell magnet
            wait_for_time $RESET_WAIT_TIME
        }
        18 {
            #The robot will now return the dumbbell magnet to the dispensing
            wait_for_time $RESET_WAIT_TIME
        }
        19 {
            returnDumbbell
            #Please verify that the cassettes inside the Dewar correspond to
            #the ones loaded into the Screening Web Interface.
        }
        20 {
            # enable robot mode
            set handle [start_waitable_operation sequenceSetConfig setConfig useRobot "1"]
            wait_for_operation $handle
            # sync with robot if it can
            set handle [start_waitable_operation sequenceSetConfig syncWithRobot 1]
            wait_for_operation $handle
            
            #Please use the Search / Reset key to interlock the hutch and close the hutch door.
            wait_for_time $RESET_WAIT_TIME
        }
        21 {
            #Enable Safeguard and press the Safeguard release button.
            wait_for_time $RESET_WAIT_TIME
        }
        default {
            return -code error "Unknown robot reset step."
        }
    }
}

itcl::body SampleMountingDevice::clearTableCALDATA { } {
    variable ::nScripts::table_calibration0
    variable ::nScripts::table_calibration1
    variable ::nScripts::table_calibration2
    variable ::nScripts::table_calibration3
    variable ::nScripts::table_calibration4

    set timeStamp [clock format [clock seconds] -format "%D-%T"]
    set table_calibration0 [lreplace table_calibration0 0 1 0 $timeStamp]
    set table_calibration1 [lreplace table_calibration1 0 1 0 $timeStamp]
    set table_calibration2 [lreplace table_calibration2 0 1 0 $timeStamp]
    set table_calibration3 [lreplace table_calibration3 0 1 0 $timeStamp]
    set table_calibration4 [lreplace table_calibration4 0 1 0 $timeStamp]
    return "all data cleared"
}
itcl::body SampleMountingDevice::doTableHorzCAL { } {
    ############################################
    # 1: move motor H1 and H2 to lower limit
    # 2: do goniometer calibration (save to table_calibration0)
    # 3: move H2 to 0 (H1 no change)
    # 4: do goniometer calibration (save to table_calibration1)
    # 5: move H1 to 0 (H2 = 0)
    # 6: do goniometer calibration (save to table_calibration2)
    #############################################

    # step 1
    log_note "doTableHorzCAL step 1: move horz 1 and 2 to lower limits"
	set lowerLimit1 $::gDevice(table_horz_1,scaledLowerLimit)
	if {$::gDevice(table_horz_1,backlashOn) && $::gDevice(table_horz_1,scaledBacklash) > 0 } {
		set lowerLimit1 [expr $lowerLimit1 + $::gDevice(table_horz_1,scaledBacklash)]
	}
	set lowerLimit2 $::gDevice(table_horz_2,scaledLowerLimit)
	if {$::gDevice(table_horz_2,backlashOn) && $::gDevice(table_horz_2,scaledBacklash) > 0 } {
		set lowerLimit2 [expr $lowerLimit2 + $::gDevice(table_horz_2,scaledBacklash)]
	}

    move table_horz_1 to $lowerLimit1
    wait_for_devices table_horz_1
    move table_horz_2 to $lowerLimit2
    wait_for_devices table_horz_2

    # step 2
    log_note "doTableHorzCAL step 2: do gonioCAL and save result"
    doGonioCALForTableCAL 0

    # step 3
    log_note "doTableHorzCAL step 3: move h2 to 0"
    move table_horz_2 to 0
    wait_for_devices table_horz_2

    # step 4
    log_note "doTableHorzCAL step 4: do gonioCAL and save result"
    doGonioCALForTableCAL 1

    # step 5
    log_note "doTableHorzCAL step 5: move h1 to 0"
    move table_horz_1 to 0
    wait_for_devices table_horz_1

    # step 6
    log_note "doTableHorzCAL step 6: do gonioCAL and save result"
    doGonioCALForTableCAL 2

    return "OK"
}

itcl::body SampleMountingDevice::doTableVertCAL { } {
    ############################################
    # 0. ask user to raise table to the highest leveled position
    # 1. do gonio for vert
    # 2: move table_vert_2 to 0
    # 3: do gonio for pitch
    # 4: (option) move table back to 1 position
    #############################################

    # step 1:
    doGonioCALForTableCAL 3

    # step 2:
    #ignore errors like hit hardware or software limit
    if { [catch { 
        move table_vert_2 to 0
        wait_for_devices table_vert_2
    } e ] } {
        log_error $e
    }

    # step 3:
    doGonioCALForTableCAL 4
}
itcl::body SampleMountingDevice::doGonioCALForTableCAL { result_index } {
    global gLaserRead
    global gOldADCCardExists
    variable ::nScripts::table_calibration0
    variable ::nScripts::table_calibration1
    variable ::nScripts::table_calibration2
    variable ::nScripts::table_calibration3
    variable ::nScripts::table_calibration4

    log_note "doGonioCALForTableCAL $result_index"

    if {$result_index < 0 || $result_index > 4} {
        retun -code error "result_index $result_index should be 0-4"
    }

    set argument [getDeltaGonioPos]

    #read analog average time 20 seconds while doing gonio CAL
    if {$gOldADCCardExists} {
        set adc_op_handle [start_waitable_operation readAnalog 20000]
    } else {
        set adc_op_handle [start_waitable_operation readDaq $READ_LASER_BOARD 10000 median]
    }

    set gonio_result [eval newSpecialGonioCAL $argument]
    if {[lindex $gonio_result 0] != "normal"} {
        return -code error "gonioCAL failed for table_calibration$result_index" 
    }
    #### save result
    set timeStamp [clock format [clock seconds] -format "%D-%T"]
    set adc_result [wait_for_operation_to_finish $adc_op_handle]

    if {$gOldADCCardExists} {
        set table_laser_result [lrange $adc_result 3 6]
    } else {
        set dataOnly [lrange $adc_result 1 end]
        set table_laser_result [list \
        [lindex $dataOnly $gLaserRead(table_vert_1,CHANNEL)] \
        [lindex $dataOnly $gLaserRead(table_vert_2,CHANNEL)] \
        [lindex $dataOnly $gLaserRead(table_horz_1,CHANNEL)] \
        [lindex $dataOnly $gLaserRead(table_horz_2,CHANNEL)]]
    }


    eval checkSensorReading $table_laser_result
    log_note "read analog result=$adc_result"
    
    set table_calibration$result_index [list 1 $timeStamp \
    $::gDevice(table_vert_1,scaled) $::gDevice(table_vert_2,scaled) \
    $::gDevice(table_horz_1,scaled) $::gDevice(table_horz_2,scaled)]
    eval lappend table_calibration$result_index $table_laser_result
    eval lappend table_calibration$result_index [lrange $gonio_result 1 4]
    return "normal OK"
}
itcl::body SampleMountingDevice::doTableCALCalculation { {auto_save 0 } } {
    variable ::nScripts::table_property

    variable ::nScripts::dsensor_to_motor_config
    variable ::nScripts::motor_to_robot_config
    variable ::nScripts::motor_z_scale
    variable ::nScripts::table_gonio_scale

    variable ::nScripts::table_calibration0
    variable ::nScripts::table_calibration1
    variable ::nScripts::table_calibration2
    variable ::nScripts::table_calibration3
    variable ::nScripts::table_calibration4

    set l_scale 1
    set h_scale 1
    set r_scale 1
    set t_scale 1
    ######## Validate Data #############
    # valid indicator
    set valid0 [lindex $table_calibration0 0]
    set valid1 [lindex $table_calibration1 0]
    set valid2 [lindex $table_calibration2 0]
    set valid3 [lindex $table_calibration3 0]
    set valid4 [lindex $table_calibration4 0]
    if {!$valid0 || !$valid1 || !$valid2 || !$valid3 || !$valid4 } {
        log_error "not all data valid yet"
        return -code error "not all data valid yet"
    }
    # table motor positions
    set V10 [lindex $table_calibration0 2]
    set V11 [lindex $table_calibration1 2]
    set V12 [lindex $table_calibration2 2]
    set V13 [lindex $table_calibration3 2]
    set V14 [lindex $table_calibration4 2]

    set V20 [lindex $table_calibration0 3]
    set V21 [lindex $table_calibration1 3]
    set V22 [lindex $table_calibration2 3]
    set V23 [lindex $table_calibration3 3]
    set V24 [lindex $table_calibration4 3]

    set H10 [lindex $table_calibration0 4]
    set H11 [lindex $table_calibration1 4]
    set H12 [lindex $table_calibration2 4]
    set H13 [lindex $table_calibration3 4]
    set H14 [lindex $table_calibration4 4]

    set H20 [lindex $table_calibration0 5]
    set H21 [lindex $table_calibration1 5]
    set H22 [lindex $table_calibration2 5]
    set H23 [lindex $table_calibration3 5]
    set H24 [lindex $table_calibration4 5]


    #displacement sensor readings
    set SV10 [lindex $table_calibration0 6]
    set SV11 [lindex $table_calibration1 6]
    set SV12 [lindex $table_calibration2 6]
    set SV13 [lindex $table_calibration3 6]
    set SV14 [lindex $table_calibration4 6]

    set SV20 [lindex $table_calibration0 7]
    set SV21 [lindex $table_calibration1 7]
    set SV22 [lindex $table_calibration2 7]
    set SV23 [lindex $table_calibration3 7]
    set SV24 [lindex $table_calibration4 7]

    set SH10 [lindex $table_calibration0 8]
    set SH11 [lindex $table_calibration1 8]
    set SH12 [lindex $table_calibration2 8]
    set SH13 [lindex $table_calibration3 8]
    set SH14 [lindex $table_calibration4 8]

    set SH20 [lindex $table_calibration0 9]
    set SH21 [lindex $table_calibration1 9]
    set SH22 [lindex $table_calibration2 9]
    set SH23 [lindex $table_calibration3 9]
    set SH24 [lindex $table_calibration4 9]
    
    if {abs( $V11 - $V10 ) > 0.01 || \
        abs( $V21 - $V20 ) > 0.01 || \
        abs( $H11 - $H10 ) > 0.01 } {
        log_error "0-1 bad table position"
        return -code error "horz 0-1 bad table position"
    }
    if {abs( $V12 - $V11 ) > 0.01 || \
        abs( $V22 - $V21 ) > 0.01 || \
        abs( $H22 - $H21 ) > 0.01 } {
        log_error "1-2 bad table position"
        return -code error "1-2 bad table position"
    }
    if {abs( $H13 - $H12 ) > 0.01 || \
        abs( $H23 - $H22 ) > 0.01 } {
        log_error "2-3 bad table position"
        return -code error "2-3 bad table position"
    }
    if {abs( $V14 - $V13 ) > 0.01 || \
        abs( $H14 - $H13 ) > 0.01 || \
        abs( $H24 - $H23 ) > 0.01 } {
        log_error "3-4 bad table position"
        log_error "V13=$V13 V14=$V14"
        log_error "H13=$H13 H14=$H14"
        log_error "H23=$H23 H14=$H14"
        return -code error "3-4 bad table position"
    }

    ######### from HORZ ############

    log_note "calculate form horz"
    
    set dy_h [expr [lindex $table_calibration2 11] - [lindex $table_calibration1 11]]
    set dx_h [expr [lindex $table_calibration2 10] - [lindex $table_calibration1 10]]

    log_note "dy=$dy_h dx=$dx_h"

    set dH1 [expr $H12 - $H11]
    if {abs($dH1) < 5} {
        log_error "table move too little in horz"
        return -code error "table move too little in horz"
    } else {
        set H1_a [expr -$dy_h / $dH1]
        set H1_c [expr $dx_h / $dH1]
    }

    
    set SH2IncludeH1Move 0

    set dSH1      [expr $SH12 - $SH11]
    set dSH2Maybe [expr $SH22 - $SH21]
    
    if {abs($dSH1) < 0.5} {
        log_error "bad or no displacement sensor for table horizontal movement"
        set H1_SH1_rate   0
        set H1_SH1_offset 0
    } else {
        set H1_SH1_rate   [expr $dH1 / $dSH1]
        set H1_SH1_offset [expr $H11 - $H1_SH1_rate * $SH11]

        if {abs($dSH2Maybe) > 0.5 * abs($dSH1)} {
            set SH2IncludeH1Move 1
        }
    }

    ########### from YAW #################
    log_note "calculate from yaw"
    if {abs($H20 - $H21) < 5} {
        log_error "table move too little in yaw"
        return -code error "table move too little in yaw"
    }
    set dy_y [expr [lindex $table_calibration0 11] - \
    [lindex $table_calibration1 11]]
    set dx_y [expr [lindex $table_calibration0 10] - \
    [lindex $table_calibration1 10]]

    log_note "dy=$dy_y dx=$dx_y"
    
    set yaw [expr $dy_y / $raw_length_horz1_gonio]
    log_note "yaw=$yaw =[::nScripts::deg $yaw] degree"

    set dSH2 [expr $SH20 - $SH21]
    if {abs($dSH2) < 0.5} {
        log_error "bad or no displacement sensor for table yaw movement"
        set H2_SH2_rate   0
        set H2_SH2_offset 0
    } else {
        set H2_SH2_rate   [expr ($H20 - $H21) / $dSH2]
        set H2_SH2_offset [expr $H20 - $H2_SH2_rate * $SH20]
    }

    set H2_H1_rate 0
    if {$SH2IncludeH1Move} {
        set H2_SH2_rate [expr \
        (($H12 - $H10) * ($H21  -  $H20) - ($H11 - $H10) * ($H22  -  $H20)) / \
        (($H12 - $H10) * ($SH21 - $SH20) - ($H11 - $H10) * ($SH22 - $SH20)) \
        ]

        set H2_H1_rate [expr \
        (($SH22 - $SH20) * ($H21 - $H20) - ($SH21 - $SH20) * ($H22 - $H20)) / \
        (($SH22 - $SH20) * ($H11 - $H10) - ($SH21 - $SH20) * ($H12 - $H10))
        ]

        set H2_SH2_offset [expr $H20 - $H2_SH2_rate * $SH20 - \
        $H2_H1_rate * $H10]
        log_note including H1 induced SH2 change:
        log_note H2_SH2 rate and offset: $H2_SH2_rate $H2_SH2_offset $H2_H1_rate
    }

    ###### here -1 is because yaw is against Y of robot ####
    set H2_a [expr -1.0 * $::gDevice(table_h2_z,scaled) * $yaw / ($H20 - $H21)]

    #################################### VERT ########################
    log_note "calculate from vert"
    set dz_v [expr [lindex $table_calibration3 12] - [lindex $table_calibration2 12]]
    set dy_v [expr [lindex $table_calibration3 11] - [lindex $table_calibration2 11]]
    set dx_v [expr [lindex $table_calibration3 10] - [lindex $table_calibration2 10]]

    log_note "dz=$dz_v dy=$dy_v dx=$dx_v"

    set dV1 [expr $V13 - $V12]
    set dV2 [expr $V23 - $V22]
    if {abs($dV1) < 2 || abs($dV2) < 2} {
        log_error "table move too little in vert"
        return -code error "table move too little in vert"
    } else {
        set V1_a [expr $dz_v / $dV1]
        set V2_a [expr $dz_v / $dV2]
        set V1_c [expr $dx_v / $dV1]
        set V1_d [expr $dy_v / $dV1]
    }
    
    set dSV1 [expr $SV13 - $SV12]
    set dSV2 [expr $SV23 - $SV22]
    if {abs($dSV1) < 0.2 || abs($dSV2) < 0.2} {
        log_error "bad or no displacement sensor for table vertical movement"
        log_error "dSV1=$dSV1 dSV2=$dSV2"
        set V1_SV1_rate   0
        set V1_SV1_offset 0
        set V2_SV2_rate   0
        set V2_SV2_offset 0
    } else {
        set V1_SV1_rate   [expr $dV1 /$dSV1]
        set V1_SV1_offset [expr $V13 - $V1_SV1_rate * $SV13]
        set V2_SV2_rate   [expr $dV2 /$dSV2]
        set V2_SV2_offset [expr $V23 - $V2_SV2_rate * $SV23]
    }

    ################# PITCH #################
    log_note "calculate from pitch"
    set raw_l_V2_V1 [expr $::gDevice(table_v2_z,scaled) \
                         - $::gDevice(table_v1_z,scaled)]

    if {abs($V24 - $V23) < 2} {
        log_error "table move too little in pitch"
        return -code error "table move too little in pitch"
    }
    set dz_p [expr [lindex $table_calibration4 12] - \
    [lindex $table_calibration3 12]]
    set dx_p [expr [lindex $table_calibration4 10] - \
    [lindex $table_calibration3 10]]

    log_note "dz=$dz_p dx=$dx_p"
    
    set pitch [expr $dz_p / $raw_length_vert1_gonio]
        
    if {abs($dx_p) >= 0.1} {
        set h_scale [expr $dx_p / $pitch / $raw_height_vert1_gonio ]
    } else {
        log_note "dx <0.1 in pitch skip h_scale"
    }
    set V_motor_z_scale [expr ($V24 - $V23) / $pitch / $raw_l_V2_V1]

    ######################### result ########################
    log_note "motors: V1_a=$V1_a V1_c=$V1_c V1_d=$V1_d V2_a=$V2_a"
    log_note "motors: H1_a=$H1_a H1_c=$H1_c H2_a=$H2_a"
    log_note "l_scale=$l_scale h_scale=$h_scale r_scale=$r_scale t_scale=$t_scale"
    log_note "motor_z scale V=$V_motor_z_scale"

    set new_motor_to_robot_config [format "%f %f %f %f %f %f %f %f %f" $V1_a 0 $V1_c $V1_d $V2_a 0 $H1_a $H1_c $H2_a]
    set new_table_gonio_scale [format "%f %f %f %f" $l_scale $h_scale $r_scale $t_scale]
    set new_motor_z_scale [format "%f" $V_motor_z_scale]

    set new_dsensor_to_motor_config [format "%f %f %f %f %f %f %f %f %f" \
    $V1_SV1_rate $V1_SV1_offset \
    $V2_SV2_rate $V2_SV2_offset \
    $H1_SH1_rate $H1_SH1_offset \
    $H2_SH2_rate $H2_SH2_offset $H2_H1_rate]

    log_note "old motor_to_robot_config: $motor_to_robot_config"
    log_note "new motor_to_robot_config: $new_motor_to_robot_config"

    log_note "old table_gonio_scale: $table_gonio_scale"
    log_note "new table_gonio_scale: $new_table_gonio_scale"

    log_note "old motor_z_scale: $motor_z_scale"
    log_note "new motor_z_scale: $new_motor_z_scale"

    log_note "old dsensor_to_motor_config $dsensor_to_motor_config"
    log_note "new dsensor_to_motor_config $new_dsensor_to_motor_config"
    if {$auto_save} {
        set motor_to_robot_config $new_motor_to_robot_config 
        set table_gonio_scale $new_table_gonio_scale 
        set motor_z_scale $new_motor_z_scale 
        set dsensor_to_motor_config $new_dsensor_to_motor_config

        #re calculate l h r t
        calculateTableSetup
    }

    return "normal OK"
}
itcl::body SampleMountingDevice::getLaserSensorReading { average_time } {
    global gOldADCCardExists

    if {!$gOldADCCardExists} {
        global gLaserRead
        if { [catch { 
            #make sure the lasers are turn on
            set operationHandle [eval start_waitable_operation \
            setDigOut \
            $TURN_ON_LASER_BOARD $TURN_ON_LASER_MASK $TURN_ON_LASER_MASK]
            set result [wait_for_operation_to_finish $operationHandle]

            wait_for_time 1000

            set operationHandle [eval start_waitable_operation \
            readDaq $READ_LASER_BOARD $average_time median]
            set result [wait_for_operation_to_finish $operationHandle]

            set dataOnly [lrange $result 1 end]
            set result_v1 [lindex $dataOnly $gLaserRead(table_vert_1,CHANNEL)]
            set result_v2 [lindex $dataOnly $gLaserRead(table_vert_2,CHANNEL)]
            set result_h1 [lindex $dataOnly $gLaserRead(table_horz_1,CHANNEL)]
            set result_h2 [lindex $dataOnly $gLaserRead(table_horz_2,CHANNEL)]
        } e ] } {
            log_error $e
            return "0 0 0 0"
        }
        set result [list $result_v1 $result_v2 $result_h1 $result_h2]
        puts "laser sensor reading for table: $result"
        return $result
    }

    if { [catch { 
        #make sure the lasers are turn on
        set operationHandle [eval start_waitable_operation setDigitalOutput 1 255 252]
        set result [wait_for_operation_to_finish $operationHandle]

        wait_for_time 1000

        set N_SAMPLE 9
        set V1List [list]
        set V2List [list]
        set H1List [list]
        set H2List [list]
        set avrg_time [expr $average_time / $N_SAMPLE]
        for {set i 0} {$i < $N_SAMPLE} {incr i} {
            set operationHandle \
            [eval start_waitable_operation readAnalog $avrg_time]
            set result [wait_for_operation_to_finish $operationHandle]

            ####workaround for ADAC5500 abort-> "normal abort ok"
            if {[string first abort $result] >= 0} {
                return -code error "aborted"
            }

            if {[llength $result] < 9} {
                return -code error "bad readAnalog: $result"
            }
            foreach {status dummy1 dummy2 v1 v2 h1 h2 dummy3 dummy4} \
            $result break

            lappend V1List $v1
            lappend V2List $v2
            lappend H1List $h1
            lappend H2List $h2
        }
        set V1List [lsort -real $V1List]
        set V2List [lsort -real $V2List]
        set H1List [lsort -real $H1List]
        set H2List [lsort -real $H2List]
        ################# retrieve results ##########
        set mid_index [expr ($N_SAMPLE + 1) / 2]
        set result_v1 [lindex $V1List $mid_index]
        set result_v2 [lindex $V2List $mid_index]
        set result_h1 [lindex $H1List $mid_index]
        set result_h2 [lindex $H2List $mid_index]
        ################# check condition ################
        ##### this is about 0.2mm
        set TOLERANCE 0.02
        if {abs([lindex $V1List 0] - [lindex $V1List end]) > $TOLERANCE} {
            #log_warning laser sensor V1 not stable $V1List
            puts "laser sensor V1 not stable $V1List"
        }
        if {abs([lindex $V2List 0] - [lindex $V2List end]) > $TOLERANCE} {
            #log_warning laser sensor V2 not stable $V2List
            puts "laser sensor V2 not stable $V2List"
        }
        if {abs([lindex $H1List 0] - [lindex $H1List end]) > $TOLERANCE} {
            #log_warning laser sensor H1 not stable $H1List
            puts "laser sensor H1 not stable $H1List"
        }
        if {abs([lindex $H2List 0] - [lindex $H2List end]) > $TOLERANCE} {
            #log_warning laser sensor H2 not stable $H2List
            puts "laser sensor H2 not stable $H2List"
        }
    } e ] } {
        log_error $e
        return "0 0 0 0"
    }
    set result [list $result_v1 $result_v2 $result_h1 $result_h2]
    puts "laser sensor reading for table: $result"
    return $result
}
itcl::body SampleMountingDevice::checkIfRecoverableError { result_message } {
    variable ::nScripts::robot_attribute
    #currently only deal with goniometer unreachable error

    if {[lindex $result_message 0] != "out"} {
        return 0
    }
    if {[llength $result_message] < 4} {
        return 0
    }
    if {[lindex $result_message 1] != "of" || \
        [lindex $result_message 2] != "robot" || \
        [lindex $result_message 3] != "range"} {
        return 0
    }

    #check to see if robot_attribute for "move table in case of goniometer unreachable is turned on"
    set move_table_if_need [lindex $robot_attribute 10]
    if {$move_table_if_need != "1"} {
        return 0
    }

    #re-fill the list with forced_move_table
    fillMoveList forced_move_table
    return 1
}

itcl::body SampleMountingDevice::prepareRobotTest { } {
    #set argument "0 0 5"
    if { [catch {
        # not include_move_table
        fillMoveList not_move_table
        moveToAccessPosition
    } e ] } {
        log_error $e
        return -code error $e
    }
    #this function must NOT be called before moveToAccessPosition
    return [getDeltaGonioPos]
}
itcl::body SampleMountingDevice::autoSampleCheck { {retry_cmd ""}} {
    variable ::nScripts::auto_sample_const
    #check if need to do sample_xyz calibration
    set system_on [lindex $auto_sample_const 29]

    if {$system_on != "1"} return

    #if {$retry_cmd != ""} {
    #    log_warning "retry command: $retry_cmd"
    #}
    
    set auto_center 0
    log_note "perform automatic sample_xyz checking...."
    if {[catch {
        set result [::nScripts::auto_sample_cal_start check_xyz]
    } e ] } {
        log_error $e
        set e1 [lindex $e 0]
        if {$e1 != "check_xyz_failed"} {
            return -code error $e
        }
        ###### auto calibration if check failed
        set auto_center 1
    }
    if {$auto_center} {
        log_warning "auto calibrate the goniomemter position....."
        if {$retry_cmd != ""} {
            set need_goHome 0
            start_recovery_operation robot_standby
        }
        if {[catch autoSampleCalibrate e]} {
            if {$e != "aborted"} {
                log_severe $e
            }
            return -code error $e
        }
        log_note "auto center goniometer succeeded: $e"
        if {$retry_cmd != ""} {
            set handle [eval $retry_cmd]
            wait_for_operation_to_finish $handle
            set need_goHome 1
        }
    }
}
itcl::body SampleMountingDevice::autoSampleCalibrate { } {
    variable ::nScripts::auto_sample_const
    #check if need to do sample_xyz calibration
    set system_on [lindex $auto_sample_const 29]

    if {$system_on != "1"} return
    
    log_note "perform automatic sample_xyz calibration...."
    if {[catch {
        set result [::nScripts::auto_sample_cal_start full_calibrate]
    } e ] } {
        log_error $e
        return -code error $e
    }
    return $result
}
itcl::body SampleMountingDevice::sampleOnGoniometer { } {
    variable ::nScripts::robot_attribute

    ### if auto sample position is not on, skip this also
    variable ::nScripts::auto_sample_const
    #check if need to do sample_xyz calibration
    set system_on [lindex $auto_sample_const 29]
    if {$system_on != "1"} return

    if {![::nScripts::CSO_get_constant system_on]} {
        return
    }

    #if probe port is turned off, we will skip sample gonio check
    if {![lindex $robot_attribute 2]} {
        log_warning sampleOnGoniometer skipped because port probing is turned off
        return
    }

    log_note "auto check sample on goniometer"
    if {[catch {::nScripts::check_sample_on_start sample_on} e] && \
    $e == "no_sample_on_goniometer"} {
        return -code error $e
    }
}
itcl::body SampleMountingDevice::sampleOffGoniometer { } {
    variable ::nScripts::robot_attribute

    ### if auto sample position is not on, skip this also
    variable ::nScripts::auto_sample_const
    #check if need to do sample_xyz calibration
    set system_on [lindex $auto_sample_const 29]
    if {$system_on != "1"} return

    if {![::nScripts::CSO_get_constant system_on]} {
        return
    }
    log_note sample check is on

    #if probe port is turned off, we will skip sample gonio check
    if {![lindex $robot_attribute 2]} {
        log_warning sampleOffGoniometer skipped because port probing is turned off
        return
    }

    log_note "auto check sample off goniometer"
    if {[catch {::nScripts::check_sample_on_start sample_off} e] && \
    $e == "sample_still_on_goniometer"} {
        log_severe Sample on Goniometer
        return -code error $e
    }
}
itcl::body SampleMountingDevice::sampleOnOffCalibrate { } {

    ### if auto sample position is not on, skip this also
    variable ::nScripts::auto_sample_const
    #check if need to do sample_xyz calibration
    set system_on [lindex $auto_sample_const 29]
    if {$system_on != "1"} return

    if {![::nScripts::CSO_get_constant system_on]} {
        return
    }

    log_note "calibrate sample on off goniometer"
    if {[catch {
        set result [::nScripts::check_sample_on_start self_calibration]
    } e ] } {
        log_error $e
        return -code error $e
    }
}
itcl::body SampleMountingDevice::stepUp { args } {
    if { [catch {
        set operationHandle [eval start_waitable_operation robot_config raise_robot $args]
        wait_for_operation_to_finish $operationHandle

    } e ] } {
        log_error $e
        return -code error $e
    } else {
        return "RobotDHSOK"
    }
}
itcl::body SampleMountingDevice::checkSensorReading { V1 V2 H1 H2 } {
    set vList [list $V1 $V2 $H1 $H2]
    set nList [list vert1 vert2 horz1 horz2]
    for {set i 0} {$i < 4} {incr i} {
        set value [lindex $vList $i]
        if {$value < -4.0 || $value > 4.0} {
            set name [lindex $nList $i]
            log_error laser sensor $name out of range
            return -code error "laser sensor $name out of range"
        }
    }
}
itcl::body SampleMountingDevice::warnDetectorZ { } {
    variable ::nScripts::screening_msg
    set distanceMotor [::nScripts::getDetectorDistanceMotorName]

    if {[info exists moveBackArray($distanceMotor)]} {
        log_warning please notice that old $distanceMotor was $moveBackArray($distanceMotor)
        set screening_msg "WARNING: old $distanceMotor=$moveBackArray($distanceMotor)"
    }

}
itcl::body SampleMountingDevice::checkTablePosition { } {
    variable ::nScripts::dsensor_to_motor_config

    foreach {v1_a v1_b v2_a v2_b h1_a h1_b h2_a h2_b h2_c} \
    $dsensor_to_motor_config break

    if {$v1_a == 0 || $v2_a == 0 || $h1_a == 0 || $h2_a == 0} {
        #### not fully calibrated, skip
        return
    }

    if {$h2_c == ""} {
        set h2_c 0
    }

    set sensor_result [getLaserSensorReading $AVERAGE_TIME]
    foreach {v1_x v2_x h1_x h2_x} $sensor_result break

    set encoder_V1 [expr $v1_a * $v1_x + $v1_b]
    set encoder_V2 [expr $v2_a * $v2_x + $v2_b]
    set encoder_H1 [expr $h1_a * $h1_x + $h1_b]
    set encoder_H2 [expr $h2_a * $h2_x + $h2_b + $h2_c * $encoder_H1]

    set raw_V1 $::gDevice(table_vert_1,scaled)
    set raw_V2 $::gDevice(table_vert_2,scaled)
    set raw_H1 $::gDevice(table_horz_1,scaled)
    set raw_H2 $::gDevice(table_horz_2,scaled)

    set DV1 [expr $encoder_V1 - $raw_V1]
    set DV2 [expr $encoder_V2 - $raw_V2]
    set DH1 [expr $encoder_H1 - $raw_H1]
    set DH2 [expr $encoder_H2 - $raw_H2]

    if {![catch {open diff_sensor_motor a} handle]} {
        set timeStamp [clock format [clock seconds] -format "%D-%T"]
        puts $handle "$timeStamp (V1 V2 H1 H2)) $DV1 $DV2 $DH1 $DH2"
        close $handle
    }
    set DV1 [expr abs($DV1)]
    set DV2 [expr abs($DV2)]
    set DH1 [expr abs($DH1)]
    set DH2 [expr abs($DH2)]

    if {$DV1 > 2.0 || $DV2 > 2.0 || $DH1 > 2.0 || $DH2 > 10.0} {
        log_severe difference between motor and laser sensor is too big: \
        $DV1 $DV2 $DH1 $DH2
        return -code error \
        "difference between motor and laser sensor is too big"
    }
}
itcl::body SampleMountingDevice::syncLaserSensorToMotor { data {warning 0} } {
    variable ::nScripts::dsensor_to_motor_config

    foreach {v1_a v1_b v2_a v2_b h1_a h1_b h2_a h2_b h2_c} \
    $dsensor_to_motor_config break
    if {$v1_a == 0 || $v2_a == 0 || $h1_a == 0 || $h2_a == 0} {
        if {$warning} {
            log_warning sensor to motor not fully calibrated, skip
        }
        return 
    }

    if {$h2_c == ""} {
        set h2_c 0
    }

    ####check contents
    set ll [llength $data]
    if {$ll < 8} {
        log_warning not enough data.  Data should be {mV1 mV2 mH1 mH2 sV1 sV2 sH1 sH2}
        return
    }
    foreach {mV1 mV2 mH1 mH2 sV1 sV2 sH1 sH2} $data break

    set v1_b [expr $mV1 - $v1_a * $sV1]
    set v2_b [expr $mV2 - $v2_a * $sV2]
    set h1_b [expr $mH1 - $h1_a * $sH1]
    set h2_b [expr $mH2 - $h2_a * $sH2 - $h2_c * $mH1]

    if {$warning} {
        log_warning old_config: $dsensor_to_motor_config
    }

    set dsensor_to_motor_config [lreplace $dsensor_to_motor_config 0 8 \
    $v1_a $v1_b $v2_a $v2_b $h1_a $h1_b $h2_a $h2_b $h2_c]
    if {$warning} {
        log_warning new_config: $dsensor_to_motor_config
    }
}
itcl::body SampleMountingDevice::syncLaserSensorToCurrentPosition { } {
    set data [list \
        $::gDevice(table_vert_1,scaled) \
        $::gDevice(table_vert_2,scaled) \
        $::gDevice(table_horz_1,scaled) \
        $::gDevice(table_horz_2,scaled) \
    ]

    set sensor_result [getLaserSensorReading $AVERAGE_TIME]
    eval checkSensorReading $sensor_result
    eval lappend data $sensor_result

    syncLaserSensorToMotor $data 1
}

itcl::body SampleMountingDevice::readSampleBarcode { deltaGonioPos index port wait_time {goHome 1}} {
    variable ::nScripts::cassette_barcode

    puts "readSampleBarcode port=$port index=$index"

    set cassette [string index $port 0]
    set column   [string index $port 1]
    set row      [string range $port 2 end]

    if { ![ validPort $cassette $row $column ] } {
        return -code error "Invalid port specified."
    }

    set need_goHome 0
    set readResult "failed"

    if { [catch {
        if {$deltaGonioPos == ""} {
            set deltaGonioPos [getDeltaGonioPos]
        }
        set argument "$cassette $row $column $deltaGonioPos"
        set operationHandle [eval start_waitable_operation prepare_mount_crystal $argument]
        set result [wait_for_operation $operationHandle]
        set status [lindex $result 0]
    
        #first reply must be update or normal to continue
        if { $status != "update" && $status != "normal" } {
            return -code error "$result"
        }

        if { $status == "normal" && [llength $result] >=4 } {
            if {[lindex $result 1] == "n" && \
                [lindex $result 2] == "0" && \
                [lindex $result 3] == "N" } {
                #empty port
                return -code error "empty port"
            }
        }

        set need_goHome 1
        ### move to barcode reader position
        set argument "$cassette $row $column $deltaGonioPos -1"
        set operationHandle \
        [eval start_waitable_operation flash_barcode $argument]
        set result [wait_for_operation_to_finish $operationHandle]
        if {[lindex $result 1] == "n" && \
        [lindex $result 2] == "0" && \
        [lindex $result 3] == "N"} {
            return -code error "empty port"
        }

        #### read barcode: need to put sample back even it failed or aborted
        if {[catch {
            set time_second [expr $wait_time / 1000.0]
            set time_to_wait [expr int($wait_time + 2000)]
            set readHandle [start_waitable_operation readBarCode $time_second]
            set readResult [wait_for_operation_to_finish $readHandle $time_to_wait]
            if {$index >= 0} {
                set barcode [lindex $readResult 1]
                set cassette_barcode \
                [setStringFieldWithPadding $cassette_barcode $index $barcode]

                updateCassetteOwnerFromBarcode
            }
        } barcodeError]} {
            set readResult "ERROR $barcodeError"
        }

        #### put back sample (ignore abort command)
        set argument "$cassette $row $column $deltaGonioPos -2"
        set operationHandle \
        [eval start_waitable_recovery_operation flash_barcode $argument]
        set result [wait_for_operation_to_finish $operationHandle]

        if {$goHome} {
            set need_goHome 0
            start_recovery_operation robot_standby
        }

    } e ] } {
        if {$goHome} {
            if {$need_goHome} {
                start_recovery_operation robot_standby
            }
        }
        return -code error $e
    }

    if {[lindex $readResult 0] != "normal"} {
        return -code error $readResult
    }

    return [lrange $readResult 1 end]
}
itcl::body SampleMountingDevice::moveToBarcodeReader { } {
    if { [catch {
        fillMoveList not_move_table
        moveToAccessPosition
    } e ] } {
        log_error $e
        return -code error $e
    }

    set argument [getDeltaGonioPos]

    if { [catch { 
        set operationHandle [eval start_waitable_operation robot_calibrate move_to_barcode_reader $argument]
        set result [wait_for_operation_to_finish $operationHandle]
    } e ] } {
        log_error $e
        return -code error $e
    } else { 
        return $result
    }
}
itcl::body SampleMountingDevice::teachBarcodeReader { } {
    set argument [getDeltaGonioPos]

    #save current position to goniometer position
    if { [catch { 
        set operationHandle [eval start_waitable_operation robot_calibrate save_barcode_reader $argument]
        set result [wait_for_operation_to_finish $operationHandle]
    } e ] } {
        log_error $e
        return -code error $e
    } else { 
        return $result
    }
}
itcl::body SampleMountingDevice::putSampleBackFromBarcodeReader { } {
    set argument [getDeltaGonioPos]

    if { [catch { 
        set operationHandle [eval start_waitable_operation robot_config put_sample_back_from_barcode $argument]
        set result [wait_for_operation_to_finish $operationHandle]
    } e ] } {
        log_error $e
        return -code error $e
    } else { 
        return $result
    }
}
### here probe includes scan barcode
itcl::body SampleMountingDevice::probe { } {
    variable ::nScripts::scanId_config

    ### do we need to scan barcode?
    set needScanBarcode 0
    for {set i 0} {$i < 3} {incr i} {
        set need [lindex $scanId_config $i]
        if {$need == "1"} {
            set needScanBarcode 1
            break
        }
    }

    if {$needScanBarcode} {
        readCassetteIdBarcode 1
    }

    if {[anyProbe l] || [anyProbe m] || [anyProbe r]} {
        set operationHandle [eval start_waitable_operation robot_config probe]
        set result [wait_for_operation_to_finish $operationHandle]
    } else {
        start_recovery_operation robot_standby
        set result OK
    }

    return $result
}
itcl::body SampleMountingDevice::readCassetteIdBarcode { {stay_in_dewar 0} } {
    variable ::nScripts::scanId_config
    variable ::nScripts::cassette_barcode
    variable ::nScripts::barcode_port

    block_all_motors
    if { [catch {
        fillMoveList not_move_table
        moveToAccessPosition
    } e ] } {
        log_error $e
        return -code error $e
    }

    set deltaGonioPos [getDeltaGonioPos]
    set casList [list l m r]

    for {set i 0} {$i < 3} {incr i} {
        set offset [expr $i + 1]
        set enabled [lindex $scanId_config $i]
        if {!$enabled} {
            continue
        }
        set cas      [lindex $casList $i]
        set portList [lindex $barcode_port  $i]
        if {$portList == ""} {
            set portList [getDefaultBarcodePort $cas]
        }
        set gotBarcode 0
        set barcode no_barcode
        foreach colRow $portList {
            set port $cas$colRow
            if {[catch {
                set barcode [readSampleBarcode $deltaGonioPos $offset $port 2000.0 0]
                puts "got barcode=$barcode for $port"
                set gotBarcode 1
            } errMsg] == 1} {
                puts "readBarcode $port failed: $errMsg"
            }
            if {$gotBarcode} {
                break
            }
        }
        if {!$gotBarcode} {
            set barcode no_barcode
            set cassette_barcode \
            [setStringFieldWithPadding $cassette_barcode $offset $barcode]
        }
    }
    updateCassetteOwnerFromBarcode
    if {!$stay_in_dewar} {
        start_recovery_operation robot_standby
    }

    if { [catch {
        moveBackToOriginalPosition
    } e ] } {
        log_error $e
    }
    unblock_all_motors
}
itcl::body SampleMountingDevice::updateCassetteOwnerFromBarcode { } {
    variable ::nScripts::cassette_barcode
    variable ::nScripts::cassette_owner

    set ll [llength $cassette_barcode]
    if {$ll < 4} {
        set lNeed [expr 4 - $ll]
        for {set i 0} {$i < $lNeed} {incr i} {
            lappend cassette_barcode ""
        }
    }

    set ulList [eval ::nScripts::barcodeData_start get_multiple_user_list $cassette_barcode]
    set cassette_owner $ulList
}
itcl::body SampleMountingDevice::addUsersToBarcode { barcode users } {
    variable ::nScripts::cassette_barcode
    variable ::nScripts::cassette_owner

    if {$barcode == "" || $barcode == "unknown" || $barcode == "no_barcode" || $users == ""} {
        return NO_NEED
    }
    eval ::nScripts::barcodeData_start add_user $barcode $users

    if {[lsearch -exact $cassette_barcode $barcode] >= 0} {
        updateCassetteOwnerFromBarcode
    }
}
itcl::body SampleMountingDevice::getDefaultBarcodePort { cas } {
    variable ::nScripts::robot_cassette
    switch -exact -- $cas {
        l {
            set index 0
        }
        m {
            set index 97
        }
        r {
            set index 194
        }
        default {
            log_error wrong cassette $cas. Only l m r
            return -code error wrong_cassette
        }
    }
    set casStatus [lindex $robot_cassette $index]
    if {$casStatus == 3} {
        # puck adaptor
        return [list A1 B1 C1 D1]
    } else {
        return A1
    }
}
itcl::body SampleMountingDevice::anyProbe { cas } {
    variable ::nScripts::robot_probe

    switch -exact -- $cas {
        l {
            set start 0
        }
        m {
            set start 97
        }
        r {
            set start 194
        }
        default {
            return -code error UNKNOWN_CASSETTE
        }
    }
    set end [expr $start + 97]
    for {set i $start} {$i < $end} {incr i} {
        set p [lindex $robot_probe $i]
        if {$p == "1"} {
            return 1
        }
    }
    return 0
}
itcl::body SampleMountingDevice::readBarcodeWhileWaitForOperationToFinish { \
handle } {
    set barcodeStarted 0
    set barcodeResult "not_started"
    set status "update"

    while { $status == "update" } {
        set result [wait_for_operation $handle]
        set status [lindex $result 0]
        if {$status == "update"} {
            set tag [lindex $result 1]
            if {!$barcodeStarted && $tag == "START_BARCODE" } {
                set hBarcode [start_waitable_operation readBarCode 30]
                set barcodeStarted 1
            } elseif {$barcodeStarted && $tag == "END_BARCODE" } {
                start_recovery_operation stopBarCode
                puts "waiting barcode result"
                catch {wait_for_operation_to_finish $hBarcode 2000} \
                barcodeResult

                puts "barcode result=$barcodeResult"
            }
        } elseif {$status == "normal"} {
            puts "END of operation"
            if {[lindex $barcodeResult 0] == "normal"} {
                puts "append barcode to result"
                set barcodeData [lindex $barcodeResult 1]
                puts "append barcode $barcodeData to result"
                lappend result $barcodeData
            } else {
                puts "no or bad barcode $barcodeResult"
            }
        }
    }
    return $result
}
