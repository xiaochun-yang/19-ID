Script started on Thu Sep 26 13:14:13 2002
[ccdsys@6accd ccd_dc_api_mad_x8c]$ telnet 154.   64.54.152.287   80
Trying 164.54.152.80...

[ccdsys@6accd ccd_dc_api_mad_x8c]$ telnet chem.ucd sd.edu
Trying 132.239.68.1...
Connected to chem.ucsd.edu.
Escape character is '^]'.


SunOS 5.8

login: cn
Password: 
Last login: Wed Sep 25 20:45:32 from 130.87.176.110
>[1;3;4;5;6l[?7h[m[r[2J[H@[H[2JSun Microsystems Inc.      SunOS 5.8       Generic February 2000
cn sun1:1>ssh -l capel [13D[Kssh capel@164.54.152.80
Host key not found from database.
Key fingerprint:
xofih-kazip-pudeh-mumuf-mipas-kysup-pugec-rogop-rysyl-pevev-rexyx
You can get a public key's fingerprint by running
% ssh-keygen -F publickey.pub
on the keyfile.
Are you sure you want to continue connecting (yes/no)? [?1h=[@y[2@es[?1l>
Host key saved to /home/research/xuong/cn/.ssh2/hostkeys/key_22_164.54.152.80.pub
host key for 164.54.152.80, accepted by cn Wed Sep 25 2002 20:01:18 -0800
capel's password: 
capel's password: 
Authentication successful.
Last login: Tue Aug 20 14:40:16 2002 from exec2bm
]0;capel@8bmserver1:~[capel@8bmserver1 capel]$ cd /usr/local/ccd_dist
]0;capel@8bmserver1:/usr/local/ccd_dist[capel@8bmserver1 ccd_dist]$ ls
[00m[01;34mbin[00m                                     [00mdiagnostic.log[00m  [01;34mLOGIN_files[00m  [01;34msrc_bls[00m      [01;31msrc.tar[00m             [01;34mtmp[00m
[00mccd_xform.log[00m                           [00mENVIRON[00m         [00mRUN_315[00m      [01;31msrc_bls.tar[00m  [01;34mtables_904_swbin[00m
[00mdet_api_8bmserver1.imm.aps.anl.gov.log[00m  [01;34mlib[00m             [01;34msaved_tars[00m   [01;34msrc_std[00m      [01;34mtables_api_904[00m
[00mdet_api_8bmserver2.imm.aps.anl.gov.log[00m  [01;31mlib.tar[00m         [01;34msrc[00m          [01;31msrc_std.tar[00m  [01;34mtables_api_904_sim[00m
[m]0;capel@8bmserver1:/usr/local/ccd_dist[capel@8bmserver1 ccd_dist]$ ls -l
[00mtotal 147536
drwxr-xr-x    8 8bmuser  8bmuser      4096 Dec  6  2001 [01;34mbin[00m
-rw-r--r--    1 8bmuser  8bmuser         0 Aug 22 11:03 [00mccd_xform.log[00m
-rw-r--r--    1 root     root          867 Aug 22 11:02 [00mdet_api_8bmserver1.imm.aps.anl.gov.log[00m
-rw-r--r--    1 8bmuser  8bmuser       867 Apr 24 19:22 [00mdet_api_8bmserver2.imm.aps.anl.gov.log[00m
-rw-r--r--    1 8bmuser  8bmuser         0 Aug 22 11:02 [00mdiagnostic.log[00m
-rw-r--r--    1 8bmuser  8bmuser       100 Feb 15  2002 [00mENVIRON[00m
drwx------    6 8bmuser  8bmuser      4096 Feb  7  1998 [01;34mlib[00m
-rw-r--r--    1 root     root     13035520 Jul 24 18:40 [01;31mlib.tar[00m
drwxr-xr-x    3 8bmuser  8bmuser      4096 Jul 16 18:56 [01;34mLOGIN_files[00m
-rw-r--r--    1 8bmuser  8bmuser       672 Feb 15  2002 [00mRUN_315[00m
drwx------    4 8bmuser  8bmuser      4096 Feb 14  2002 [01;34msaved_tars[00m
drwxr-xr-x    5 root     root         4096 May 20 16:38 [01;34msrc[00m
drwx------   53 8bmuser  8bmuser      4096 Apr 25 16:24 [01;34msrc_bls[00m
-rw-r--r--    1 root     root     19609600 Jul 24 18:21 [01;31msrc_bls.tar[00m
drwx------  159 8bmuser  8bmuser      4096 Jun 13 15:22 [01;34msrc_std[00m
-rw-r--r--    1 root     root     106096640 Jul 24 18:32 [01;31msrc_std.tar[00m
-rw-r--r--    1 root     root     12093440 Jul 24 18:40 [01;31msrc.tar[00m
drwxrwxrwx    3 8bmuser  8bmuser      4096 Feb 27  2002 [01;34mtables_904_swbin[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Aug 13 09:15 [01;34mtables_api_904[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Feb 27  2002 [01;34mtables_api_904_sim[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Apr  9  1998 [01;34mtmp[00m
[m]0;capel@8bmserver1:/usr/local/ccd_dist[capel@8bmserver1 ccd_dist]$ su
Password: 
]0;capel@8bmserver1:/usr/local/ccd_dist[root@8bmserver1 ccd_dist]# rm *.tar
rm: remove `lib.tar'? y
rm: remove `src_bls.tar'? y
rm: remove `src_std.tar'? y
rm: remove `src.tar'? y
]0;capel@8bmserver1:/usr/local/ccd_dist[root@8bmserver1 ccd_dist]# ls
[00m[01;34mbin[00m                                     [00mdiagnostic.log[00m  [00mRUN_315[00m     [01;34msrc_std[00m             [01;34mtmp[00m
[00mccd_xform.log[00m                           [00mENVIRON[00m         [01;34msaved_tars[00m  [01;34mtables_904_swbin[00m
[00mdet_api_8bmserver1.imm.aps.anl.gov.log[00m  [01;34mlib[00m             [01;34msrc[00m         [01;34mtables_api_904[00m
[00mdet_api_8bmserver2.imm.aps.anl.gov.log[00m  [01;34mLOGIN_files[00m     [01;34msrc_bls[00m     [01;34mtables_api_904_sim[00m
[m]0;capel@8bmserver1:/usr/local/ccd_dist[root@8bmserver1 ccd_dist]# ls -l
[00mtotal 60
drwxr-xr-x    8 8bmuser  8bmuser      4096 Dec  6  2001 [01;34mbin[00m
-rw-r--r--    1 8bmuser  8bmuser         0 Aug 22 11:03 [00mccd_xform.log[00m
-rw-r--r--    1 root     root          867 Aug 22 11:02 [00mdet_api_8bmserver1.imm.aps.anl.gov.log[00m
-rw-r--r--    1 8bmuser  8bmuser       867 Apr 24 19:22 [00mdet_api_8bmserver2.imm.aps.anl.gov.log[00m
-rw-r--r--    1 8bmuser  8bmuser         0 Aug 22 11:02 [00mdiagnostic.log[00m
-rw-r--r--    1 8bmuser  8bmuser       100 Feb 15  2002 [00mENVIRON[00m
drwx------    6 8bmuser  8bmuser      4096 Feb  7  1998 [01;34mlib[00m
drwxr-xr-x    3 8bmuser  8bmuser      4096 Jul 16 18:56 [01;34mLOGIN_files[00m
-rw-r--r--    1 8bmuser  8bmuser       672 Feb 15  2002 [00mRUN_315[00m
drwx------    4 8bmuser  8bmuser      4096 Feb 14  2002 [01;34msaved_tars[00m
drwxr-xr-x    5 root     root         4096 May 20 16:38 [01;34msrc[00m
drwx------   53 8bmuser  8bmuser      4096 Apr 25 16:24 [01;34msrc_bls[00m
drwx------  159 8bmuser  8bmuser      4096 Jun 13 15:22 [01;34msrc_std[00m
drwxrwxrwx    3 8bmuser  8bmuser      4096 Feb 27  2002 [01;34mtables_904_swbin[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Aug 13 09:15 [01;34mtables_api_904[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Feb 27  2002 [01;34mtables_api_904_sim[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Apr  9  1998 [01;34mtmp[00m
[m]0;capel@8bmserver1:/usr/local/ccd_dist[root@8bmserver1 ccd_dist]# cd src_std
]0;capel@8bmserver1:/usr/local/ccd_dist/src_std[root@8bmserver1 src_std]# ls -lrt
[00mtotal 5436
drwxr-xr-x    2 8bmuser  8bmuser      4096 Feb  7  1998 [01;34mmdchw_dslib[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Apr 23  1998 [01;34mmod_stab[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 May 17  1998 [01;34mdark_stat[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Aug 21  1998 [01;34mincl_backup[00m
drwxr-xr-x    3 8bmuser  8bmuser      4096 Aug 21  1998 [01;34mdet_dev[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Nov 24  1998 [01;34msmv_to_mar[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Dec  1  1998 [01;34mdet_emulator[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Dec  7  1998 [01;34mccd_xform_mult_api[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Dec  7  1998 [01;34mccd_dc_mult_api[00m
drwxr-xr-x    4 8bmuser  8bmuser      4096 Dec 29  1998 [01;34mfor_kinder[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Jan 27  1999 [01;34mcheck_for_beam[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Feb  1  1999 [01;34mcombine_smv_raw[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Feb 15  1999 [01;34mccd_dc_t2k_api[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Feb 24  1999 [01;34mtile_check[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 May 18  1999 [01;34mccd_dc_calib[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Jun 15  1999 [01;34mfix98[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Aug 13  1999 [01;34mccdhwlib[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Sep 14  1999 [01;34mccd_noise[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Sep 15  1999 [01;34mccd_xform_check[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Sep 19  1999 [01;34mccd_daemon_pc[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Oct  3  1999 [01;34mccdsys_autopc[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Dec 14  1999 [01;34mcombine_smv[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Dec 27  1999 [01;34mccd_dc_api[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Jan  9  2000 [01;34mpck2smv[00m
drwxr-xr-x    3 8bmuser  8bmuser      4096 Jan 21  2000 [01;34msmv2pck[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Feb 22  2000 [01;34mderive_flood[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Feb 22  2000 [01;34mderive_aux_flood[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Feb 24  2000 [01;34mdet_emulator_q4[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Feb 24  2000 [01;34mfileio_for_nt[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Feb 28  2000 [01;34mxmitrecv[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Mar  1  2000 [01;34mccd_dc_api_mad_chip[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Mar  2  2000 [01;34mrot_fill_t2k[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Mar 30  2000 [01;34mdet_sim_q4_full[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Jun 22  2000 [01;34mstat_corners[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Jun 29  2000 [01;34mccd_xform_calib[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Jul 11  2000 [01;34mdet_sim_q4[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Jul 12  2000 [01;34mstat_corners_special[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Jul 12  2000 [01;34mrecalc_nonunf[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Jul 18  2000 [01;34mfsplit[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Jul 29  2000 [01;34mwave_server[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Jul 31  2000 [01;34mmakefullimage[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Aug  1  2000 [01;34mfan_out[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Aug  5  2000 [01;34mccd_bl_gen_blsim[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Aug  5  2000 [01;34mblsim_server[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Aug  6  2000 [01;34mprep_q210_sim_input[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Aug  6  2000 [01;34mimage_seq[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Sep 12  2000 [01;34mmarty_calibint[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Sep 22  2000 [01;34mccd_dc_esrf[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Sep 22  2000 [01;34mccd_dc_api_lib[00m
drwxr-xr-x    3 8bmuser  8bmuser      4096 Sep 23  2000 [01;34mnew_detcon_lib[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Sep 26  2000 [01;34mdet_sim_t2k[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Nov 13  2000 [01;34mt2k_ldtest[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Nov 13  2000 [01;34mt2k_imt[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Dec  1  2000 [01;34mt2k_libdet[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Dec  5  2000 [01;34mmask_spots[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Feb 12  2001 [01;34mtest_xform[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Feb 19  2001 [01;34msub_smv[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Feb 19  2001 [01;34mref_210[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Mar  7  2001 [01;34mmarian_xformlib[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Mar  7  2001 [01;34mlibxform_cn_chess[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Mar 15  2001 [01;34mccd_status[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Mar 20  2001 [01;34mgain_adj_441[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Mar 22  2001 [01;34mfix_pc_fmt[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Mar 31  2001 [01;34mtempcon_server[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Mar 31  2001 [01;34mtempcon_client[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Apr  5  2001 [01;34mped_adj[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Apr 13  2001 [01;34mlibdet_update[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Apr 14  2001 [01;34mlibxf_mod_test[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Apr 18  2001 [01;34mccd_bl_gen_t2k[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Apr 18  2001 [01;34mccd_bl_flood[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Apr 20  2001 [01;34mccd_bl_gen_fast[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Apr 26  2001 [01;34mped_adj_442[00m
drwxr-xr-x    3 8bmuser  8bmuser      4096 May  8  2001 [01;34mccd_image_gather_single[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 May 12  2001 [01;34mlibdetmod_ms_test[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 May 12  2001 [01;34mlibdet_module_ms[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 May 14  2001 [01;34mlibdet[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 May 21  2001 [01;34mped_adj_443[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 May 27  2001 [01;34mccd_dc_api_plus[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 May 27  2001 [01;34mccd_xform_t2k_plus[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 May 28  2001 [01;34mlibdetmod_test[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Jun 18  2001 [01;34mlibdet_module[00m
drwxr-xr-x    3 8bmuser  8bmuser      4096 Jun 21  2001 [01;34mlibxform_module_marian[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Jun 25  2001 [01;34mserver_test[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Jun 28  2001 [01;34mmodify_int_files[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Jul  4  2001 [01;34mssrl_bin[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Jul  6  2001 [01;34mlibxform[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Jul  9  2001 [01;34mflood_inv_test[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Jul 25  2001 [01;34mccd_xform_t2k[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Jul 26  2001 [01;34mcrop_bin_2k[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Aug  4  2001 [01;34mflood_runs[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Aug  5  2001 [01;34mmodify_flood1_443[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Aug  9  2001 [01;34mdet_api_module[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Aug  9  2001 [01;34mderive_flood_210[00m
drwxr-xr-x    3 8bmuser  8bmuser      4096 Aug 16  2001 [01;34mdezinger[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Aug 25  2001 [01;34mdetcon_test_mp[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Aug 26  2001 [01;34mnonsuch[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Aug 26  2001 [01;34mdummy_pc_process[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Aug 26  2001 [01;34mclient_test[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Aug 26  2001 [01;34msend_exit_to_remote[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Aug 27  2001 [01;34mdetcon_lib_mp[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Sep  4  2001 [01;34mgraduated_flood[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Sep  8  2001 [01;34mlibxform_2x2[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Sep  8  2001 [01;34mccd_xform_2x2[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Sep  8  2001 [01;34mpc_remote_start[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Sep  8  2001 [01;34mdet_module_remote[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Sep  8  2001 [01;34mmodify_flood_443[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Sep  8  2001 [01;34mlibxform_3x3[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Sep  8  2001 [01;34mccd_xform_3x3[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Sep  9  2001 [01;34msignal_pc_remote.0[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Sep 11  2001 [01;34mmodify_flood_901[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Sep 17  2001 [01;34msw_bin[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Sep 17  2001 [01;34mbin_ccd[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Sep 19  2001 [01;34mmodify_floodfield[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Oct  2  2001 [01;34madjust_interp_origin[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Oct  8  2001 [01;34mstat_areas.0[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Oct  9  2001 [01;34mped_modify[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Oct 16  2001 [01;34mmodify_nonunf[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Oct 16  2001 [01;34mgains_443[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Oct 16  2001 [01;34mmodify_flood1_443_bin[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Oct 17  2001 [01;34mccd_dc_api_pf[00m
drwxr-xr-x    3 8bmuser  8bmuser      4096 Oct 17  2001 [01;34mccd_bl_gen_pf[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Nov  6  2001 [01;34mregion_solve[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Nov 13  2001 [01;34mdet_api[00m
drwxr-xr-x    4 8bmuser  8bmuser      4096 Nov 20  2001 [01;34mals_updates[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Nov 28  2001 [01;34mmake_gain_regions[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Nov 28  2001 [01;34mstat_regions[00m
-rw-r--r--    1 8bmuser  8bmuser   1280000 Nov 29  2001 [01;31madx_slit.tar[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Dec  4  2001 [01;34mdetcon_lib[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Dec  4  2001 [01;34mdetcon_test[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Dec  5  2001 [01;34mtestthread[00m
-rw-r--r--    1 8bmuser  8bmuser    194261 Dec  7  2001 [01;31mccd_dc_api_mad.tar.Z[00m
drwxr-xr-x    3 8bmuser  8bmuser      4096 Dec 13  2001 [01;34mccd_image_gather.0[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Dec 18  2001 [01;34mssrl_to_adsc_names[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Dec 19  2001 [01;34mretransform[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Jan 27  2002 [01;34mmake_q4_gain_regions[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Feb 11  2002 [01;34mpatch_header[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Feb 11  2002 [01;34mmake_gain_objects[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Feb 11  2002 [01;34mtemp_tweak[00m
drwxrwxr-x    2 8bmuser  8bmuser      4096 Feb 14  2002 [01;34mulib_ccd[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Feb 14  2002 [01;34mccd_bl_gen[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Feb 26  2002 [01;34mlibxform_module[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Feb 26  2002 [01;34mdet_module_plus[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Feb 26  2002 [01;34mccd_xform_new_api[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Feb 26  2002 [01;34mdet_api_workstation[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Feb 28  2002 [01;34mlibdet_module_plus[00m
-rw-r--r--    1 root     root        61440 May 17 15:11 [01;31msignal_pc_remote.tar[00m
-rw-r--r--    1 root     root       419840 May 17 15:12 [01;31mccd_image_gather.tar[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 May 17 15:18 [01;34mccdsys[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 May 20 10:59 [01;34mincl[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 May 20 11:00 [01;34mauxlib[00m
drwxr-xr-x    8 8bmuser  8bmuser      4096 May 20 16:32 [01;34madx_ccd[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 May 20 16:53 [01;34mccd_daemon[00m
drwxr-xr-x    2 1120     games        4096 May 20 16:57 [01;34msignal_pc_remote[00m
drwxr-xr-x    2 1115     103          4096 May 20 17:33 [01;34madx_ccd_control_pf[00m
drwxr-xr-x    3 8bmuser  8bmuser      4096 May 21 13:00 [01;34mlibwincompat[00m
-rw-r--r--    1 root     root       883023 May 21 13:33 [01;31m8bm_updates.tar.Z[00m
-rw-r--r--    1 root     root       460800 May 21 13:38 [01;31mqc_315.tar[00m
drwxr-xr-x    3 1120     games        4096 Jun 12 18:45 [01;34mccd_image_gather[00m
-rw-r--r--    1 root     root       573440 Jun 13 14:47 [01;31mstat_areas_ssrl.tar[00m
drwx------    2 1166     users        4096 Jun 13 14:48 [01;34mstat_areas[00m
-rw-r--r--    1 root     root       573440 Jun 13 15:10 [01;31mstat_spots.tar[00m
drwx------    2 1120     games        4096 Jun 13 15:10 [01;34mstat_spots[00m
-rw-r--r--    1 root     root       430080 Jun 13 15:22 [01;31mxgraph-11.tar[00m
drwx------    4 1166     users        4096 Jun 13 15:24 [01;34mxgraph-11[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Jul 16 18:51 [01;34mccd_dc_api_mad[00m
drwxr-xr-x    2 1115     103          4096 Aug 14 13:11 [01;34mccd_dc_api_mad_x8c[00m
[m]0;capel@8bmserver1:/usr/local/ccd_dist/src_std[root@8bmserver1 src_std]# cd ccd_dc_api_mad_x8c
]0;capel@8bmserver1:/usr/local/ccd_dist/src_std/ccd_dc_api_mad_x8c[root@8bmserver1 ccd_dc_api_mad_x8c]# lks -l[Klks -l[Kls -l
[00mtotal 1608
-rw-r--r--    1 1115     103           438 Apr 26  1999 [00madded_commands[00m
-rw-r--r--    1 1115     103            84 Apr 26  1999 [00mbzero.c[00m
-rw-r--r--    1 1115     103          1559 Jun 19  2001 [00mccd_dc_args.c[00m
-rw-r--r--    1 1115     103          1559 Apr 26  1999 [00mccd_dc_args.c~[00m
-rw-r--r--    1 root     root        37996 Aug 13 09:16 [00mccd_dc_args.o[00m
-rw-r--r--    1 1115     103          4604 Apr 18 18:40 [00mccd_dc_bl.c[00m
-rw-r--r--    1 1115     103          4576 Apr 11  2001 [00mccd_dc_bl.c~[00m
-rw-r--r--    1 root     root        40692 Aug 13 09:16 [00mccd_dc_bl.o[00m
-rw-r--r--    1 1115     103          9357 Aug 13 09:08 [00mccd_dc_defs.h[00m
-rw-r--r--    1 1115     103          4587 Jun 19  2001 [00mccd_dc_det.c[00m
-rw-r--r--    1 1115     103          4578 Jun 19  2001 [00mccd_dc_det.c~[00m
-rw-r--r--    1 root     root        41192 Aug 13 09:16 [00mccd_dc_det.o[00m
-rw-r--r--    1 1115     103          9785 Aug 13 09:09 [00mccd_dc_ext.h[00m
-rw-r--r--    1 1115     103         17755 Aug 13 09:08 [00mccd_dc_glob.c[00m
-rw-r--r--    1 root     root        55936 Aug 13 09:16 [00mccd_dc_glob.o[00m
-rw-r--r--    1 1115     103          3451 Jul  5  1999 [00mccd_dc_heartbeat.c[00m
-rw-r--r--    1 root     root        38760 Aug 13 09:16 [00mccd_dc_heartbeat.o[00m
-rw-r--r--    1 1115     103         51448 Aug 14 13:11 [00mccd_dc_hw.c[00m
-rw-r--r--    1 1115     103         51287 Aug 13 12:24 [00mccd_dc_hw.c~[00m
-rw-r--r--    1 1115     103         43207 Jun  5  2001 [00mccd_dc_hw.c.0[00m
-rw-r--r--    1 1115     103         43644 Jun 14  2001 [00mccd_dc_hw.c.1[00m
-rw-r--r--    1 1115     103         35364 Apr 26  1999 [00mccd_dc_hw.c.old[00m
-rw-r--r--    1 root     root        93652 Aug 14 13:11 [00mccd_dc_hw.o[00m
-rw-r--r--    1 1115     103         10815 Apr 26  1999 [00mccd_dc_hwsim.c[00m
-rw-r--r--    1 root     root        52280 Aug 13 09:16 [00mccd_dc_hwsim.o[00m
-rw-r--r--    1 1115     103         22959 Apr 18 20:43 [00mccd_dc_input.c[00m
-rw-r--r--    1 1115     103         20752 Jun  6  1999 [00mccd_dc_input.c~[00m
-rw-r--r--    1 1115     103         17802 Apr 26  1999 [00mccd_dc_input.c.0[00m
-rw-r--r--    1 root     root        61852 Aug 13 09:16 [00mccd_dc_input.o[00m
-rw-r--r--    1 1115     103         16876 Apr 26  1999 [00mccd_dc_input_orig.c[00m
-rw-r--r--    1 1115     103          1056 Jun 19  2001 [00mccd_dc_main.c[00m
-rw-r--r--    1 1115     103          1011 Jun 19  2001 [00mccd_dc_main.c~[00m
-rw-r--r--    1 root     root        37472 Aug 13 09:16 [00mccd_dc_main.o[00m
-rw-r--r--    1 1115     103         42943 Aug 13 09:12 [00mccd_dc_misc.c[00m
-rw-r--r--    1 1115     103         38647 Jun 19  2001 [00mccd_dc_misc.c~[00m
-rw-r--r--    1 1115     103         33426 Apr 26  1999 [00mccd_dc_misc.c.0[00m
-rw-r--r--    1 root     root        84188 Aug 13 09:16 [00mccd_dc_misc.o[00m
-rw-r--r--    1 1115     103          8100 Apr 24 18:51 [00mccd_dc_seq.c[00m
-rw-r--r--    1 1115     103          9732 Apr 26  1999 [00mccd_dc_seq.c.0[00m
-rw-r--r--    1 1115     103          9363 Apr 24 18:52 [00mccd_dc_seq_nowork.c[00m
-rw-r--r--    1 root     root        47324 Aug 13 09:16 [00mccd_dc_seq.o[00m
-rw-r--r--    1 1115     103          3274 Apr 26  1999 [00mccd_dc_sio.c[00m
-rw-r--r--    1 root     root        40400 Aug 13 09:16 [00mccd_dc_sio.o[00m
-rw-r--r--    1 1115     103         23181 May 20 23:55 [00mccd_dc_strstat.c[00m
-rw-r--r--    1 root     root        58004 Aug 13 09:16 [00mccd_dc_strstat.o[00m
-rw-r--r--    1 1115     103         19780 Apr 18 18:21 [00mccd_server.c[00m
-rw-r--r--    1 1115     103         19327 Jun 19  2001 [00mccd_server.c~[00m
-rw-r--r--    1 root     root        61760 Aug 13 09:16 [00mccd_server.o[00m
-rw-r--r--    1 root     root            0 Aug 13 10:59 [00mccd_xform.log[00m
-rw-r--r--    1 root     root          867 Aug 13 10:59 [00mdet_api_8bmserver1.imm.aps.anl.gov.log[00m
-rw-r--r--    1 root     root            0 Aug 13 10:59 [00mdiagnostic.log[00m
-rw-r--r--    1 1115     103          1315 Apr 18 19:22 [00mget_attenuator.c[00m
-rw-r--r--    1 root     root        12356 Aug 13 09:16 [00mget_attenuator.o[00m
lrwxrwxrwx    1 1115     103            18 May 20 10:46 [01;36mMakefile[00m -> [00mMakefile_x8c.alpha[00m
-rw-r--r--    1 1115     103            83 Apr 26  1999 [00mMakefile.alpha[00m
-rw-r--r--    1 1115     103            92 Apr 23 09:17 [00mMakefile.linux[00m
-rw-r--r--    1 1115     103            74 Apr 26  1999 [00mMakefile.sgi[00m
-rw-r--r--    1 1115     103            89 Apr 26  1999 [00mMakefile.sun[00m
-rw-r--r--    1 1115     103            89 Apr 23 13:26 [00mMakefile_x8c.alpha[00m
-rw-r--r--    1 1115     103            98 Apr 18 17:23 [00mMakefile_x8c.linux[00m
-rw-r--r--    1 1115     103            80 Apr 18 17:24 [00mMakefile_x8c.sgi[00m
-rw-r--r--    1 1115     103            95 Apr 18 17:24 [00mMakefile_x8c.sun[00m
-rw-r--r--    1 1115     103           639 Aug 13 11:13 [00mMkfile[00m
-rw-r--r--    1 1115     103           821 Apr 26  1999 [00mmult_commands[00m
-rw-r--r--    1 1115     103          2003 Apr 26  1999 [00mnet_client.c[00m
-rw-r--r--    1 root     root        23544 Aug 13 09:16 [00mnet_client.o[00m
-rw-r--r--    1 1115     103         13348 Apr 26  1999 [00mparse_file_name[00m
-rw-r--r--    1 1115     103           629 Apr 26  1999 [00mparse_file_name.c[00m
-rw-r--r--    1 1115     103          9949 Apr 26  1999 [00mtest_seq.c[00m
-rw-r--r--    1 1115     103          8331 Apr 26  1999 [00mtest_seq_first.c[00m
-rw-r--r--    1 1115     103           784 Apr 26  1999 [00mutil_misc.c[00m
-rw-r--r--    1 root     root        11396 Aug 13 09:16 [00mutil_misc.o[00m
-rw-r--r--    1 1115     103          2082 Apr 26  1999 [00mvms_select.h[00m
[m]0;capel@8bmserver1:/usr/local/ccd_dist/src_std/ccd_dc_api_mad_x8c[root@8bmserver1 ccd_dc_api_mad_x8c]# ls -lrt *, .[ch]
[00m-rw-r--r--    1 1115     103            84 Apr 26  1999 [00mbzero.c[00m
-rw-r--r--    1 1115     103         10815 Apr 26  1999 [00mccd_dc_hwsim.c[00m
-rw-r--r--    1 1115     103          3274 Apr 26  1999 [00mccd_dc_sio.c[00m
-rw-r--r--    1 1115     103         16876 Apr 26  1999 [00mccd_dc_input_orig.c[00m
-rw-r--r--    1 1115     103           784 Apr 26  1999 [00mutil_misc.c[00m
-rw-r--r--    1 1115     103          8331 Apr 26  1999 [00mtest_seq_first.c[00m
-rw-r--r--    1 1115     103          9949 Apr 26  1999 [00mtest_seq.c[00m
-rw-r--r--    1 1115     103           629 Apr 26  1999 [00mparse_file_name.c[00m
-rw-r--r--    1 1115     103          2003 Apr 26  1999 [00mnet_client.c[00m
-rw-r--r--    1 1115     103          2082 Apr 26  1999 [00mvms_select.h[00m
-rw-r--r--    1 1115     103          3451 Jul  5  1999 [00mccd_dc_heartbeat.c[00m
-rw-r--r--    1 1115     103          1559 Jun 19  2001 [00mccd_dc_args.c[00m
-rw-r--r--    1 1115     103          4587 Jun 19  2001 [00mccd_dc_det.c[00m
-rw-r--r--    1 1115     103          1056 Jun 19  2001 [00mccd_dc_main.c[00m
-rw-r--r--    1 1115     103         19780 Apr 18 18:21 [00mccd_server.c[00m
-rw-r--r--    1 1115     103          4604 Apr 18 18:40 [00mccd_dc_bl.c[00m
-rw-r--r--    1 1115     103          1315 Apr 18 19:22 [00mget_attenuator.c[00m
-rw-r--r--    1 1115     103         22959 Apr 18 20:43 [00mccd_dc_input.c[00m
-rw-r--r--    1 1115     103          8100 Apr 24 18:51 [00mccd_dc_seq.c[00m
-rw-r--r--    1 1115     103          9363 Apr 24 18:52 [00mccd_dc_seq_nowork.c[00m
-rw-r--r--    1 1115     103         23181 May 20 23:55 [00mccd_dc_strstat.c[00m
-rw-r--r--    1 1115     103          9357 Aug 13 09:08 [00mccd_dc_defs.h[00m
-rw-r--r--    1 1115     103         17755 Aug 13 09:08 [00mccd_dc_glob.c[00m
-rw-r--r--    1 1115     103          9785 Aug 13 09:09 [00mccd_dc_ext.h[00m
-rw-r--r--    1 1115     103         42943 Aug 13 09:12 [00mccd_dc_misc.c[00m
-rw-r--r--    1 1115     103         51448 Aug 14 13:11 [00mccd_dc_hw.c[00m
[m]0;capel@8bmserver1:/usr/local/ccd_dist/src_std/ccd_dc_api_mad_x8c[root@8bmserver1 ccd_dc_api_mad_x8c]# cat [Km[Kcat ccd_dc_defs.h
#include	<stdio.h>
#include	"../incl/ccdconv.h"
#include	"../incl/esd.h"
#include	"../incl/esd_com.h"
#include	"../incl/ccddefs.h"
#include	"../incl/ccdsys.h"
#include	<errno.h>
#include	<signal.h>
#include	<math.h>

#ifndef VMS
#include	<sys/types.h>
#include	<sys/time.h>
#include	<sys/socket.h>
#include	<netinet/in.h>
#else
#include	<types.h>
#include	<time.h>
#include	<socket.h>
#include	<in.h>
#include	"../incl/vms_select.h"
#endif /* VMS */

#ifdef VMS
#define	GOOD_STATUS	1
#define	BAD_STATUS	2
#else
#define	GOOD_STATUS	0
#define	BAD_STATUS	1
#endif /* VMS */

#define	CCD_N_CTRL		"CCD_N_CTRL"

#define	CCD_DET_OK		0
#define	CCD_DET_RETRY		1
#define	CCD_DET_FATAL		2
#define	CCD_DET_NOTCONNECTED	3
#define	CCD_DET_DISCONNECTED	4

#define	CCD_BL_OK		10
#define	CCD_BL_RETRY		11
#define	CCD_BL_FATAL		12
#define	CCD_BL_NOTCONNECTED	13
#define	CCD_BL_DISCONNECTED	14

#define	MAXREMARK	100
#define	BLCMDMAX	256

struct mdc_command {
		int	cmd_used;	/* 0 if this queue entry unused */
		struct mdc_command *cmd_next;	/* next command in queue */
		int	cmd_no;		/* the command number/this command */
		int	cmd_err;	/* 1 if there is an error */
		float	cmd_value;	/* a value field, if appropriate */
		float	cmd_col_dist;	/* distance for data collection */
		float	cmd_col_lift;	/* lift value for data collection */
		float	cmd_col_phis;	/* phi start for data collection */
		float	cmd_col_omegas;	/* omega start for data collection */
		float	cmd_col_kappas;	/* kappa start for data collection */
		float	cmd_col_osc_width;  /* oscillation width/image */
		int	cmd_col_axis;	/* 1 for phi, 0 for omega */
		int	cmd_col_newdark;    /* 1 for a new dark current image, else 0 */
		int	cmd_col_anom;	    /* 1 for anomalous data */
		int	cmd_col_wedge;	    /* wedge (#frames per batch) size for anom data */
		int	cmd_col_n_images;   /* number of images to collect */
		int	cmd_col_n_passes;   /* number of osc passes/image */
		float	cmd_col_time;	    /* data collection time/image */
		int	cmd_col_mode;	    /* 0 = collect time, 1 dose */
		int	cmd_col_image_number; /* start image number */
		char	cmd_col_dir[132];   /* directory for output images */
		char	cmd_col_prefix[30]; /* image name prefix */
		char	cmd_col_suffix[30]; /* image name suffix */
		int	cmd_col_adc;	    /* adc select */
		int	cmd_col_bin;	    /* bin select */
		float	cmd_col_xcen;	    /* x detector center in mm for oblique correction */
		float	cmd_col_ycen;	    /* y detector center in mm for oblique correction */
		int	cmd_col_compress;   /* 0 for none, 1 for .Z, 2 for .pck */
		float	cmd_col_dzratio;    /* ratio of 2nd picture expos time to 1st */
		int	cmd_col_dkinterval; /* interval between darks */
		int	cmd_col_rep_dark;   /* 1 to repeat darks every darkinterval seconds */
		int	cmd_col_dk_before;  /* 1 to repeat darks before each run */
		int	cmd_col_outfile_type;	/* 0 for 16 bit, 1 for 32 bit, 2 for 16 + overflow records */
		int	cmd_col_no_transform;	/* 1 to not transform data */
		int	cmd_col_output_raws;	/* 1 to output raws */
		float	cmd_col_step_size;	/* size of step for step/dose mode */
		float	cmd_col_dose_step;	/* dose per step, step/dose mode */
		float	cmd_col_atten_run;	/* attenuator amount for this run */
		float	cmd_col_hslit_run;	/* horiz slit amount for this run */
		float	cmd_col_vslit_run;	/* vertical slit amount for this run */
		float	cmd_col_autoal_run;	/* autoalign every run */
		float	cmd_col_run_wave;
		int	cmd_col_mad_mode;	/* 0 never, 1 per run, 2 per wedge, 3 per nframes */
		int	cmd_col_mad_nframes;	/* for mode = 3, number of frames between wavelength changes */
		int	cmd_col_mad_nwave;	/* number of wavelengths */
		float	cmd_col_mad_wavelengths[10];	/* wavelengths */
		float	cmd_col_do_wavelength;	/* used after runs are expanded in the queue */
		int	cmd_col_remarkc;    	/* number of remark records */
		int	cmd_col_restart_run;		/* run number for restart */
		int	cmd_col_restart_image;		/* image number for restart */
		char	*cmd_col_remarkv[MAXREMARK];  /* pointers to remarks */
		char	cmd_col_blcmd[BLCMDMAX];
	       };

typedef struct mdc_command mdc_command;

enum {
	MDC_COM_EOC = 0,
	MDC_COM_EXIT,
	MDC_COM_CONFIG,
	MDC_COM_STARTUP,
	MDC_COM_ERASE,
	MDC_COM_INIT,
	MDC_COM_STOP,
	MDC_COM_ABORT,
	MDC_COM_DMOVE,
	MDC_COM_PMOVE,
	MDC_COM_PMOVEREL,
	MDC_COM_DSET,
	MDC_COM_PSET,
	MDC_COM_LMOVE,
	MDC_COM_LSET,
	MDC_COM_WMOVE,
	MDC_COM_WSET,
	MDC_COM_SHUT,
	MDC_COM_SCAN,
	MDC_COM_OMOVE,
	MDC_COM_OSET,
	MDC_COM_KMOVE,
	MDC_COM_KSET,
	MDC_COM_COLL,
	MDC_COM_SNAP,
	MDC_COM_GONMAN,
	MDC_COM_HOME,
	MDC_COM_AMOVE,
	MDC_COM_AUTOALIGN,
	MDC_COM_XL_HS_MOVE,
	MDC_COM_XL_VS_MOVE,
	MDC_COM_XL_UP_HHS_MOVE,
	MDC_COM_XL_UP_VHS_MOVE,
	MDC_COM_XL_DN_HHS_MOVE,
	MDC_COM_XL_DN_VHS_MOVE,
	MDC_COM_QLIST,
	MDC_COM_QFLUSH,
	MDC_COL_DIST,
	MDC_COL_PHIS,
	MDC_COL_OSCW,
	MDC_COL_NIM,
	MDC_COL_DEZING,
	MDC_COL_TIME,
	MDC_COL_IMNO,
	MDC_COL_DIR,
	MDC_COL_PRE,
	MDC_COL_SUF,
	MDC_COL_MODE,
	MDC_COL_WAVE,
	MDC_COL_REMARK,
	MDC_COL_LIFT,
	MDC_COL_ADC,
	MDC_COL_BIN,
	MDC_COL_CENTER,
	MDC_COL_KSTART,
	MDC_COL_OSTART,
	MDC_COL_AXIS,
	MDC_COL_NDARK,
	MDC_COL_ANOM,
	MDC_COL_WEDGE,
	MDC_COL_COMPRESS,
	MDC_COL_BLCMD,
	MDC_COL_DZRATIO,
	MDC_COL_DKIVAL,
	MDC_COL_DKREP,
	MDC_COL_DKBEF,
	MDC_COL_OFILE,
	MDC_COL_NO_TRANSFORM,
	MDC_COL_OUTPUT_RAWS,	
	MDC_COL_STEP_SIZE,
	MDC_COL_DOSE_STEP,
	MDC_COL_MAD,
	MDC_COL_MAD_WAVE,
	MDC_COL_RESTART_RUN,
	MDC_COL_RESTART_IMAGE,
	MDC_COL_ATTEN_RUN,
	MDC_COL_AUTOAL_RUN,
	MDC_COL_HSLIT_RUN,
	MDC_COL_VSLIT_RUN
	};

#define	MAXQUEUE	100

#define	MAX_CMD		16

/*
 *	These are defines which are common to all
 *	scanners.  They form the first level
 *	initialization to the programs specific
 *	scanner variables.  These values may be
 *	overridden by a user supplied configuration
 *	table.
 */

#define	SPECIFIC_PHI_STEPS_DEG	(500)
#define	SPECIFIC_DIST_STEPS_MM	(100)
#define	SPECIFIC_PHI_TOP_SPEED	(2000)
#define	SPECIFIC_DIST_TOP_SPEED	(1000)
#define	SPECIFIC_DIST_MAX_POINT	(42500)
#define	SPECIFIC_DIST_MIN_POINT	(6500)
#define	SPECIFIC_UNITS_PER_SEC	(1000)
#define	SPECIFIC_UNITS_PER_DOSE	(1000)
#define	SPECIFIC_WAVELENGTH	(1.5418)
#define	SPECIFIC_IS_DIST	(1)
#define	SPECIFIC_IS_PHI		(1)
#define	SPECIFIC_MULTIPLIER	(4.)
#define	SPECIFIC_FLAGS		(0)
#define	SPECIFIC_LIFT_STEPS_MM	(100)
#define	SPECIFIC_LIFT_TOP_SPEED (1000)
#define	SPECIFIC_LIFT_MAX_POINT	(15000)
#define	SPECIFIC_LIFT_MIN_POINT	(0)
#define	SPECIFIC_IS_LIFT	(0)

#define	SPECIFIC_NC_POINTER	(0)
#define	SPECIFIC_NC_INDEX	(0)
#define	SPECIFIC_NC_X		(0)
#define	SPECIFIC_NC_Y		(0)
#define	SPECIFIC_NC_REC		(0)
#define	SPECIFIC_NC_POFF	(0)

#define	SPECIFIC_SCSI_ID	(2)
#define	SPECIFIC_SCSI_CONTROLLER	(0)
#define	SPECIFIC_SPIRAL_CHECK	(1)

#define	SPECIFIC_READ_FAST	(2.2)
#define	SPECIFIC_READ_SLOW	(8.7)
#define	SPECIFIC_READ_OVERHEAD	(1.0)
#define	SPECIFIC_BIN_FACTOR	(2.7)
#define	SPECIFIC_IS_KAPPA	(0)
#define	SPECIFIC_IS_OMEGA	(0)
#define	SPECIFIC_DEF_DEZINGER	(0)
#define	SPECIFIC_IS_2THETA	(0)
#define	SPECIFIC_PCSHUTTER	(0)
#define	SPECIFIC_DARK_INTERVAL	(0)
#define	SPECIFIC_PIXEL_SIZE	(0.085)
#define	SPECIFIC_DK_BEFORE_RUN	(1)
#define	SPECIFIC_OUTFILE_TYPE	(0)
#define	SPECIFIC_DETECTOR_SN	(-1)
#define	SPECIFIC_NO_TRANSFORM	(0)
#define	SPECIFIC_OUTPUT_RAWS	(0)
#define	SPECIFIC_J5_TRIGGER	(0)
#define	SPECIFIC_TIMECHECK	(0)
#define	SPECIFIC_CONSTRAIN_OMEGA	(360)
#define	SPECIFIC_CONSTRAIN_PHI		(360)
#define	SPECIFIC_CONSTRAIN_KAPPA	(360)
#define	SPECIFIC_STRIP_AVE	(0)
#define SPECIFIC_BCHK_TIME      (2.)
#define SPECIFIC_BCHK_DELTAPHI  (0.1)
#define SPECIFIC_IS_WAVELENGTH  (0)
#define SPECIFIC_APPROACH_START (0.0)
#define SPECIFIC_CHIP_SIZE_X      (1152)
#define SPECIFIC_CHIP_SIZE_Y      (1152)
#define SPECIFIC_KAPPA_CONST    (50.0)
#define SPECIFIC_MADRUN_NAMING  (0)
#define SPECIFIC_RETRYSHORT  	(0)
#define	SPECIFIC_CCD_MODULAR	(0)
#define SPECIFIC_PF_MOD         (0)
#define	SPECIFIC_MIN_VELOCITY	(.0001)
#define	SPECIFIC_MAX_VELOCITY	(100.0)
#define	SPECIFIC_ALLOW_STILLS	(0)
#define	SPECIFIC_PITCH_TUNE_DELTA (0)
#define SPECIFIC_BM8_MOD	(0)

/*
 *	These are scanner specific values, in the
 *	sense that they differ from TYPE of scanner.
 *
 *	They form the first level initialization to
 *	the programs specific scanner variables.
 *	These values may be overridden by a user
 *	supplied configration file.
 *
 *	Possible defines: (ONLY one may be defined)
 *
 *	#define	SCANNER_TYPE_BIG_BIG	1
 *	#define	SCANNER_TYPE_SMALL_HOLE	1
 */

#define	SCANNER_TYPE_SMALL_HOLE	1

#ifdef SCANNER_TYPE_BIG_BIG

#define	SPECIFIC_ERASE_TIME		(40.)
#define	SPECIFIC_SCAN_TIME		(136.)
#define	SPECIFIC_DC_ERASE_TIME		(70.)
#define	SPECIFIC_TOTAL_VALID_BLOCKS	(11952)
#define	SPECIFIC_TOTAL_PIXELS_X		(2000)
#define	SPECIFIC_TOTAL_PIXELS_Y		(2000)

#endif /* SCANNER_TYPE_BIG_BIG */

#ifdef SCANNER_TYPE_SMALL_HOLE

#define	SPECIFIC_ERASE_TIME		(34.)
#define	SPECIFIC_SCAN_TIME		(100.)
#define	SPECIFIC_DC_ERASE_TIME		(39.)
#define SPECIFIC_TOTAL_VALID_BLOCKS	(4224)
#define	SPECIFIC_TOTAL_PIXELS_X		(1200)
#define	SPECIFIC_TOTAL_PIXELS_Y		(1200)

#endif /* SCANNER_TYPE_SMALL_HOLE */

#ifdef SCANNER_TYPE_SMALL

#define	SPECIFIC_ERASE_TIME		(34.)
#define	SPECIFIC_SCAN_TIME		(75.)
#define	SPECIFIC_DC_ERASE_TIME		(54.)
#define SPECIFIC_TOTAL_VALID_BLOCKS	(4352)
#define	SPECIFIC_TOTAL_PIXELS_X		(1200)
#define	SPECIFIC_TOTAL_PIXELS_Y		(1200)
#define	SPECIFIC_MULTIPLIER		(4.)

#endif /* SCANNER_TYPE_SMALL */
]0;capel@8bmserver1:/usr/local/ccd_dist/src_std/ccd_dc_api_mad_x8c[root@8bmserver1 ccd_dc_api_mad_x8c]# cat ccd_dc_glob.c
#include	"ccd_dc_defs.h"

char ifname[256];	/* translated command file name */
char ofname[256];	/* translated output file name */
char sfname[256];	/* translated status file name */
char simdir[256];	/* translated directory name for fake images */
char xfcmdn[256];	/* ip_xform command name */
char lfname[256];	/* for logging important hardware messages */
char confname[256];	/* configuration file name */
char profname[256];	/* profile file name */

char fname_lead[256];	/* leading part of output images */
char fname_dir[256];	/* the directory part */
char scan_dir[256];	/* used to store the spiral files */
char scan_dir_export[256];	/* used to store the spiral files with exported NFS directory name of scan_dir */
char spiralfilename[512];	/* used to contain spiral file name */
char spiralfilename_export[512];	/* exported spiral file name */
char cartimagename[512];	/* what the spiral file will transform to */

int	fdcom;		/* file (socket) desc for command */
int	fdout;		/* file (socket) desc for output */
FILE	*fpout;		/* file pointer for output */
int	fdstat;		/* file (socket) desc for status */
int	fdxfcm;		/* file (socket) desc for transform */
FILE	*fplog;		/* log file for useful info */
FILE	*fpconfig;	/* file pointer for config file */
FILE	*fprun;		/* used in run file generation */
int	fddetcmd;	/* detector process command socket */
int	fddetstatus;	/* detector process status socket */
int	fdblcmd;	/* beamline process command socket */
int	fdblstatus;	/* beamline process status socket */

int	fposcom;	/* current file position for command */
int	fposout;	/* current file position for output */
int	fposstat;	/* current file position for status */
int	detector_sn;	/* serial number of the detector, if known */
int	output_raws;	/* 1 to output raws */
int	no_transform;	/* 1 to do no transform on line */
int	constrain_omega;	/* 0 for don't care, 180 for -180:180, 360 (def) for 0-360 */
int	constrain_phi;		/* 0 for don't care, 180 for -180:180, 360 (def) for 0-360 */
int	constrain_kappa;	/* 0 for don't care, 180 for -180:180, 360 (def) for 0-360 */

FILE	*fpnull;	/* /dev/null */
int	dc_in_progress;	/* Set when data collection is in progress */

char *trntable = LOGICAL_NAME_TABLE;	/* Essentially for VMS */

mdc_command	mdc_queue[MAXQUEUE];	/* queue of scanner commands */
mdc_command	*mdc_head;		/* points to first queue member */
mdc_command	mdc_current;		/* current command being executed */

/*
 *	Scanner status information.
 */

float	stat_dist;		/* current distance */
float	stat_phi;		/* current phi */
float	stat_lift;		/* current lift */
float	stat_omega;		/* current omega */
float	stat_kappa;		/* current kappa */
float	stat_start_phi;		/* starting phi value for this scan */
float	stat_start_omega;	/* starting omega */
float	stat_start_kappa;	/* strting kappa */
float	stat_osc_width;		/* oscillation range */
float	stat_time;		/* exposure time */
float	stat_intensity;		/* intensity reading from mar */
float	stat_wavelength;	/* wavelength */
float	stat_multiplier;	/* scanner specific multiplier factor */
int	stat_axis;		/* 1 for phi, 0 for omega */
int	stat_mode;		/* 0 for time mode, 1 for dose mode */
int	stat_max_count;		/* maximum counts in an exposure */
int	stat_n_images;		/* number of images in this collection */
int	stat_n_passes;		/* number of passes per image */
int	stat_n_mdc_updates;	/* number of times mdc has update stat file */
int	stat_n_ccd_updates;	/* number of times ccd_dc has updated its OWN status file */
int	stat_image_number;	/* used to keep track of the current image number */
int	stat_adc;		/* adc value (slow=0, fast = 1) */
int	stat_bin = 0;		/* 1 for 1x1, 2 for 2x2 binning */
char	stat_dir[80];		/* directory for collecting data */
char	stat_prefix[890];	/* code name + encoded run number */
char	stat_fname[80];		/* current file name */
char	stat_scanner_op[80];	/* scanner operation in progress */
char	stat_scanner_msg[80];	/* any useful scanner message */
char	stat_scanner_control[80];  /* control state */
char	stat_scanner_shutter[80];  /* state of the shutter */
char	stat_mode_msg[80];	/* collection mode: dose or time */
float	stat_xcen;		/* x beam center in mm for oblique correction */
float	stat_ycen;		/* y beam center in mm for oblique correction */
float	stat_2theta;		/* two theta of the detector */
int	stat_compress;		/* 0 for none, 1 for .Z 2 for .pck */
int	stat_anom;		/* 1 for anomalous, else 0 */
int	stat_wedge;		/* number of frames per anom mini-run */
float	stat_dzratio = 1.0;	/* ratio of 2nd/1st image expos time/dezingering */
float 	stat_step_size;         /* step size for step/dose mode */
float 	stat_dose_step;         /* dose per step for step/dose mode */
float	stat_attenuator;	/* attenuator amount */
float	stat_hslit;		/* horiz slit amount */
float	stat_vslit;		/* vertical slit amount */
float	min_velocity;		/* min data collection velocity */
float	max_velocity;		/* max data collection velocity */
int	allow_stills;

/*
 *	Simulation timing and control.
 */

int	use_pc_shutter;
int	use_j5_trigger;
int	use_timecheck;
int	sim_cmd_ticks;		/* when goes to zero, the command is done */

int	tick;		/* used for clock counting */
int	units;		/* used for calculating percentage completion */
int	decrement;	/* used for pseudo-timing of things */
int	dcop;		/* software state used for collect & scan */
int	retrycnt;	/* retry count for hardware faults */
int	msign;		/* used in calculations */
float	start_val;	/* used in calculations */
float	delta;		/* ditto */
int	totimg;		/* used for deciding when data collection done */
int	totpass;	/* same, only for multiple passes in a single osc */
int	dc_abort;	/* signals a data collection abort */
int	dc_stop;	/* signals a stop after current exposure */
int	command_rejected;	/* 1 if the command was rejected by ccd_hw_start */
int	dc_abort_ctr;	/* used during the abort procedure */
int	dc_error_rec;	/* used during data collection error recovery */
char	mdc_alert[80];	/* used to signal a hardware alert */

char	*mdc_comlit[] = {
			"eoc",
			"exit",
			"config",
			"startup",
			"erase",
			"initialize",
			"stop",
			"abort",
			"distance_move",
			"phi_move",
			"phi_move_rel",
			"distance_set",
			"phi_set",
			"lift_move",
			"lift_set",
			"wavelength_move",
			"wavelength_set",
			"shutter",
			"scan",
			"omega_move",
			"omega_set",
			"kappa_move",
			"kappa_set",
			"collect",
			"snap",
			"gon_manual",
			"home",
			"attenuate",
			"autoalign",
			"xl_hs_move",
			"xl_vs_move",
			"xl_up_hhs_move",
			"xl_up_vhs_move",
			"xl_dn_hhs_move",
			"xl_dn_vhs_move",
			"queue_list",
			"queue_flush",
			"distance",
			"phi_start",
			"osc_width",
			"n_images",
			"de_zinger",
			"time",
			"image_number",
			"directory",
			"image_prefix",
			"image_suffix",
			"mode",
			"wavelength",
			"remark",
			"lift",
			"adc",
			"bin",
			"center",
			"kappa_start",
			"omega_start",
			"axis",
			"newdark",
			"anomalous",
			"wedge",
			"compress",
			"blcmd",
			"dzratio",
			"darkinterval",
			"repeat_dark",
			"dk_before_run",
			"outfile_type",
			"no_transform",
			"output_raw",
			"step_size",
			"dose_per_step",
			"mad",
			"mad_wave",
			"restart_run",
			"restart_image",
			"atten_run",
			"autoal_run",
			"hslit_run",
			"vslit_run",
			NULL
			};

/*
 *	Variables which apply to both simulated and actual
 *	hardware operation.
 */

int	mdc_cmd_active;			/* 1 if we have an active command */
int	mdc_simulation;			/* 1 if simulation, 0 if actual hardware */
int	raw_ccd_image = 0;		/* 1 if doing calibration, else 0 */
int	repeat_dark_current = 0;	/* 1 if doing repeated dark currents, else 0 */
int	dark_current_interval = 0;	/* interval in sec for recollect dark currents */
int	dark_current_time = 0;		/* time function value for last dark current */
int	pixel_size;
int	dk_before_run;			/* 1 for dark current repeat before a run */
int	strip_ave;			/* 1 to use strip averages for dark pedistal renorm in xform */

int	n_ctrl;				/* number of controllers */
int	n_strip_ave;			/* number of returned strip_ave values */
float	strip_ave_vals[4];		/* their values */

int	(*mdc_cmd_start)();		/* function which starts commands */
int	(*mdc_cmd_progress)();		/* function checking progress */

int	fdmar;			/* file descriptor for mar */
struct	esd_status_block rs;	/* raw sataus block */
float	dt_stat;		/* number of seconds per status update */
float	kappa_const;		/* kappa goniostat constant, usually about 50 degrees */

/*
 *	Hardware scanner status.
 */

int	active[MAX_CMD];
int	started[MAX_CMD];
int	queued[MAX_CMD];
int	all_done[MAX_CMD];
int	aborted[MAX_CMD];
int	c_error[MAX_CMD];
short	last_valid_data;
short	last_command;
int	mains_active;
int	hv_on;
int	open_xray_shutter;
int	xray_shutter_open;
int	lock_ip;
int	ip_locked;
int	open_laser_shutter;
int	laser_shutter_open;
int	erase_lamp_on_out;
int	erase_lamp_on_ok;
int	ion_chamber;
int	ion_chamber_select_enab;
int	distance_steps;
int	phi_steps;
int	lift_steps;
int	omega_steps;
int	waiting_for_command[MAX_CMD];
int	readpointer;
int	writepointer;

/*
 *	Some timing variables useful to have.
 */

float	erase_time;	/* number of seconds it takes to erase plate */
float	scan_time;	/* number of seconds it takes to scan plate */
float	dc_erase_time;	/* slightly longer than normal erase */
int	phi_steps_deg;	/* number of steps per degree in phi */
int	dist_steps_mm;	/* number of steps per mm for the distance */
int	lift_steps_mm;	/* number of steps per mm for the lift mechanism */
int	phi_top_speed;	/* Top speed in steps/sec for phi motor */
int	phi_speed_used;	/* The actual speed for a particular operation */
int	dist_top_speed;	/* Top speed for distance in steps/mm */
int	dist_max_ref_point;	/* Number of steps for ending limit switch */
int	dist_min_ref_point;	/* Number of steps for dist at near limit switch */
int	lift_top_speed; /* Top speed for lift mechanism in steps/sec */
int	lift_max_point;		/* Number of steps for lift at the UPPER limit switch */
int	lift_min_point;		/* Number of steps for lift at the LOWER limit switch */
int	is_lift;		/* 1 if there is a lift mechanism on this machine */
int	units_per_second;	/* number of units per second/data coll */
int	units_per_dose;		/* same thing, only for dose */
int	magic_flags;		/* may need for a special purpose */
int	is_distance;		/* 1 if there is operable distance */
int	is_phi;			/* 1 if there is operable phi */
int	radius_mode;		/* 0 (default) 180 or 300 */
float	read_fast;		/* read time/FAST ADC */
float	read_slow;		/* read time/SLOW ADC */
float	read_overhead;		/* general overhead per picture */
float	bin_factor;		/* factor to apply for time if bin 2x2 */
int	is_kappa;		/* 1 if we have a kappa axis */
int	is_omega;		/* 1 if we have an omega axis */
int	def_dezinger;		/* 1 if default is to dezinger images */
int	is_2theta;		/* 1 if we have a two theta.  This is exclusive of is_lift */
int     is_wavelength;          /* 1 if we have wavelength control */
float   approach_start;         /* non-zero to move this far from start position, then to start position */
int     chip_size_x;            /* size of the basic chip element in the detector, in pixels */
int     chip_size_y;            /* size of the basic chip element in the detector, in pixels */
float   bchk_time;                      /* beamstop check time */
float   bchk_deltaphi;                  /* beamstop check deltaphi */
int     perform_beamstop_check;         /* 1 to perform beamstop check, else 0 */
int     checking_direct_beam;           /* 1 while this is in progress */
char    bchk_semiphore_file[256];       /* beamstop check semiphore file name */
int	madrun_naming;
int	retryshort;			/* 1 to retry short exposures (mar base) */
int	ccd_modular;			/* 1 if using modular (multiple) framegrabbers, else 0 */
int	pf_mod;			/* 1 if using modular (multiple) framegrabbers, else 0 */
int     pitch_tune_delta;
time_t  pitch_tune_last = 0;
int	bm8_mod;

int	nc_pointer;	/* neighbor code start pointer */
int	nc_index;	/* neighbor code start index */
int	nc_x;		/* neighbor code start x value */
int	nc_y;		/* neighbor code start y value */
int	nc_rec;		/* neighbor code start record value */
int	nc_poff;	/* neighbor code start pixel offset value */

int	scsi_id;	/* SCSI unit number of the MAR controller */
int	scsi_controller;	/* SCSI controller number (VMS: a = 0, b = 1, etc.) */
int	spiral_check;	/* 1 to check spiral records */

float	beam_xcen;		/* x beam center in mm for oblique correction */
float	beam_ycen;		/* y beam center in mm for oblique correction */
int	outfile_type;		/* 0 or ushort, 1 for int */

/*
 *	These are lower case assigned versions of
 *	the default #defines in the mdcdefs.h file.
 *
 *	They are given the initial values by the .h file
 *	but may be overridden either by the program
 * 	or by the user's configuration file.
 */


float	specific_erase_time;	/* how many sec. a simple erase command takes */
float	specific_scan_time;	/* how many seconds the scan part of the GOIPS takes */
float	specific_dc_erase_time;	/* how many seconds the erase and lock parts of GOIPS takes */
int	specific_total_valid_blocks;	/* how many blocks makes a spiral scan */
int	specific_total_pixels_x;	/* number of pixels in x */
int	specific_total_pixels_y;	/* number of pixels in y */
float	specific_multiplier;	/* This is scanner specific and should ALWAYS user specified */
int	specific_phi_steps_deg;	/* number of steps per degree for phi motor */
int	specific_dist_steps_mm;	/* number of steps per mm for the distance */
int	specific_lift_steps_mm;	/* number of steps per mm for tower lift mechanism */
int	specific_lift_top_speed; /* top speed for the lift motor (masquerading as "omega") */
int	specific_lift_max_point; /* value of lift in STEPS at the upper limit */
int	specific_lift_min_point; /* value of lift in STEPS at the lower limit */
int	specific_is_lift;	/* is there a lift mechanism on this machine? */
int	specific_phi_top_speed;	/* top speed of phi motor in steps per second */
int	specific_dist_top_speed; /* top speed of distance motor in steps per second */
int	specific_dist_max_point; /* value of distance in STEPS at the FAR distance limit */
int	specific_dist_min_point; /* value of distance in STEPS at the NEAR distance limit */
int	specific_units_per_sec;	/* units for timing exposures */
int	specific_units_per_dose; /* units for measuring exposures by dose */
float	specific_wavelength; 	/* wavelength default */
int	specific_is_distance;	/* is there a distance on this machine? */
int	specific_is_phi;	/* is there a phi motor on this machine? */
int	specific_flags;		/* sometime we may need override values */
int	specific_nc_pointer;	/* neighbor code start pointer */
int	specific_nc_index;	/* neighbor code start index */
int	specific_nc_x;		/* neighbor code start x value */
int	specific_nc_y;		/* neighbor code start y value */
int	specific_nc_rec;	/* neighbor code start record value */
int	specific_nc_poff;	/* neighbor code start pixel offset value */
int	specific_scsi_id;	/* SCSI unit number of the controller */
int	specific_scsi_controller;	/* controller number */
int	specific_spiral_check;		/* 1 to check for bad spiral records */
float	specific_read_fast;		/* read time/FAST ADC */
float	specific_read_slow;		/* read time/SLOW ADC */
float	specific_read_overhead;		/* general overhead per picture */
float	specific_bin_factor;		/* factor to apply for time if bin 2x2 */
int	specific_is_kappa;		/* 1 if we have a kappa axis */
int	specific_is_omega;		/* 1 if we have an omega axis */
int	specific_def_dezinger;		/* 1 if default is to dezinger images */
int	specific_is_2theta;		/* 1 if we have 2theta */
int     specific_is_wavelength;         /* 1 if we have 2theta */
float   specific_approach_start;        /* non-zero to move this far from start position, then to start position */
int     specific_chip_size_x;           /* size of the basic chip element in the detector, in pixels */
int     specific_chip_size_y;           /* size of the basic chip element in the detector, in pixels */
int	specific_pcshutter;		/* 1 if default is to dezinger images */
int	specific_dark_interval;		/* time in sec in between dark current recollects */
float	specific_pixel_size;		/* pixel size */
int	specific_compress;		/* 0 for none, 1 for .Z 2 for .pck */
int	specific_dk_before_run;		/* 1 for dark current repeat before a run */
int	specific_repeat_dark;		/* 1 for repeat dark current */
int	specific_outfile_type;		/* 0 or ushort, 1 for int */
int	specific_detector_sn;		/* detector serial number, if specified */
int	specific_no_transform;		/* 1 for no on-line transform */
int	specific_output_raws;		/* 1 for output raws */
int	specific_j5_trigger;		/* 1 to use j5 trigger for ext_sync */
int	specific_timecheck;		/* 1 to use j5 trigger for ext_sync */
int	specific_constrain_omega;	/* 0 for don't care, 180 for -180:180, 360 (def) for 0-360 */
int	specific_constrain_phi;		/* 0 for don't care, 180 for -180:180, 360 (def) for 0-360 */
int	specific_constrain_kappa;	/* 0 for don't care, 180 for -180:180, 360 (def) for 0-360 */
int	specific_strip_ave;		/* 1 to use strip averages for dk pedistal renorm */
float   specific_bchk_time;             /* time for beamstop check */
float   specific_bchk_deltaphi;         /* delta phi for beamstop check */
float   specific_kappa_const;           /* kappa constant */
int     specific_madrun_naming;         /* 1 for Henry's convention, 0 for cn's */
int	specific_retryshort;		/* 1 to retry short exposures (mar bases) */
int	specific_ccd_modular;		/* 1 if we are using modular (multiple) framegrabbers */
int	specific_pf_mod;		/* 1 if we are running under PF mods */
float	specific_min_velocity;
float	specific_max_velocity;
int	specific_allow_stills;
int	specific_pitch_tune_delta;
int	specific_bm8_mod;
]0;capel@8bmserver1:/usr/local/ccd_dist/src_std/ccd_dc_api_mad_x8c[root@8bmserver1 ccd_dc_api_mad_x8c]# !ls
ls -lrt *.[ch]
[00m-rw-r--r--    1 1115     103            84 Apr 26  1999 [00mbzero.c[00m
-rw-r--r--    1 1115     103         10815 Apr 26  1999 [00mccd_dc_hwsim.c[00m
-rw-r--r--    1 1115     103          3274 Apr 26  1999 [00mccd_dc_sio.c[00m
-rw-r--r--    1 1115     103         16876 Apr 26  1999 [00mccd_dc_input_orig.c[00m
-rw-r--r--    1 1115     103           784 Apr 26  1999 [00mutil_misc.c[00m
-rw-r--r--    1 1115     103          8331 Apr 26  1999 [00mtest_seq_first.c[00m
-rw-r--r--    1 1115     103          9949 Apr 26  1999 [00mtest_seq.c[00m
-rw-r--r--    1 1115     103           629 Apr 26  1999 [00mparse_file_name.c[00m
-rw-r--r--    1 1115     103          2003 Apr 26  1999 [00mnet_client.c[00m
-rw-r--r--    1 1115     103          2082 Apr 26  1999 [00mvms_select.h[00m
-rw-r--r--    1 1115     103          3451 Jul  5  1999 [00mccd_dc_heartbeat.c[00m
-rw-r--r--    1 1115     103          1559 Jun 19  2001 [00mccd_dc_args.c[00m
-rw-r--r--    1 1115     103          4587 Jun 19  2001 [00mccd_dc_det.c[00m
-rw-r--r--    1 1115     103          1056 Jun 19  2001 [00mccd_dc_main.c[00m
-rw-r--r--    1 1115     103         19780 Apr 18 18:21 [00mccd_server.c[00m
-rw-r--r--    1 1115     103          4604 Apr 18 18:40 [00mccd_dc_bl.c[00m
-rw-r--r--    1 1115     103          1315 Apr 18 19:22 [00mget_attenuator.c[00m
-rw-r--r--    1 1115     103         22959 Apr 18 20:43 [00mccd_dc_input.c[00m
-rw-r--r--    1 1115     103          8100 Apr 24 18:51 [00mccd_dc_seq.c[00m
-rw-r--r--    1 1115     103          9363 Apr 24 18:52 [00mccd_dc_seq_nowork.c[00m
-rw-r--r--    1 1115     103         23181 May 20 23:55 [00mccd_dc_strstat.c[00m
-rw-r--r--    1 1115     103          9357 Aug 13 09:08 [00mccd_dc_defs.h[00m
-rw-r--r--    1 1115     103         17755 Aug 13 09:08 [00mccd_dc_glob.c[00m
-rw-r--r--    1 1115     103          9785 Aug 13 09:09 [00mccd_dc_ext.h[00m
-rw-r--r--    1 1115     103         42943 Aug 13 09:12 [00mccd_dc_misc.c[00m
-rw-r--r--    1 1115     103         51448 Aug 14 13:11 [00mccd_dc_hw.c[00m
[m]0;capel@8bmserver1:/usr/local/ccd_dist/src_std/ccd_dc_api_mad_x8c[root@8bmserver1 ccd_dc_api_mad_x8c]# cat ccd_dc_misc.c
#include	"ccd_dc_ext.h"

/*
 *-------------------------------------------
 *
 *	Miscellaneous routines in this module.
 *
 *-------------------------------------------
 */

/*
 *	ccd_initialize
 *
 *	ccd_initialize translates logical names
 *	into actual file names (environment for
 *	UNIX, logical name table for VMS) and
 *	opens them in their appropriate states.
 *
 *	Next, ccd_initialize assigns default values
 *	of scanner times or attributes to the
 *	variables labled "specific...".
 *
 *	Then ccd_initialize reads the user's
 *	configuration file and alters the
 *	"specific..." variables based on that
 *	file's contents.
 *
 *	Finally, the "specific..." variables are
 *	used to assign values to variables which
 *	the scanner actually uses.
 *
 *	So the order of precedence:
 *
 *	  1)	mardefs.h	(lowest)
 *	  2)	user config	(next)
 *	  3)	values from profile (highest)
 */

ccd_initialize()
  {
	long	clock;
	char	*cptr;

	fpout = NULL;
	fplog = NULL;
	fpconfig = NULL;
	fdcom = fdout = fdstat = fdxfcm = -1;
	fddetcmd = fddetstatus = fdblcmd = fdblstatus = -1;
	if(NULL == (fpnull = fopen("/dev/null","r+")))
	  {
	    fprintf(stderr,"ccd_dc: ccd_initialize: cannot open /dev/null\n");
	    exit(0);
	  }

	ccd_init_files();
/*
 *	Log the time to the errorlog for startup
 */
	time(&clock);
	cptr = (char *) ctime(&clock);
	fprintf(fplog,"=============================\n");
	fprintf(fplog,"ccd_dc: started %s\n",cptr);
	fprintf(fplog,"=============================\n");

	ccd_init_defaults();
	ccd_init_config(fpnull);
	ccd_init_vars();
	strcpy(mdc_alert,"");
	dc_in_progress = 0;
	perform_beamstop_check = 0;
	checking_direct_beam = 0;
	if(NULL != (cptr = (char *) getenv("CCD_BCHK_SEMIPHORE_FILE")))
	  {
		perform_beamstop_check = 1;
		strcpy(bchk_semiphore_file,cptr);
	  }  
  }

/*
 *	This routine assigns the first round of
 *	values to the "specific..." variables.
 *
 *	The defaults come from this programs
 * 	ccd_dc_defs.h file.  Variables which change
 *	from scanner to scanner or from some
 *	other reason will be altered in the next
 *	phase of initialization.
 */

ccd_init_defaults()
  {
	specific_erase_time = SPECIFIC_ERASE_TIME;
	specific_scan_time = SPECIFIC_SCAN_TIME;
	specific_dc_erase_time = SPECIFIC_DC_ERASE_TIME;	
	specific_total_valid_blocks = SPECIFIC_TOTAL_VALID_BLOCKS;
	specific_total_pixels_x = SPECIFIC_TOTAL_PIXELS_X;
	specific_total_pixels_y = SPECIFIC_TOTAL_PIXELS_Y;
	specific_multiplier = SPECIFIC_MULTIPLIER;
	specific_phi_steps_deg = SPECIFIC_PHI_STEPS_DEG;
	specific_dist_steps_mm = SPECIFIC_DIST_STEPS_MM;
	specific_lift_steps_mm = SPECIFIC_LIFT_STEPS_MM;
	specific_phi_top_speed = SPECIFIC_PHI_TOP_SPEED;
	specific_dist_top_speed = SPECIFIC_DIST_TOP_SPEED;
	specific_lift_top_speed = SPECIFIC_LIFT_TOP_SPEED;
	specific_dist_max_point = SPECIFIC_DIST_MAX_POINT;
	specific_dist_min_point = SPECIFIC_DIST_MIN_POINT;
	specific_lift_max_point = SPECIFIC_LIFT_MAX_POINT;
	specific_lift_min_point = SPECIFIC_LIFT_MIN_POINT;
	specific_units_per_sec = SPECIFIC_UNITS_PER_SEC;
	specific_units_per_dose = SPECIFIC_UNITS_PER_DOSE;
	specific_wavelength = SPECIFIC_WAVELENGTH;
	specific_is_distance = SPECIFIC_IS_DIST;
	specific_is_phi = SPECIFIC_IS_PHI;
	specific_is_lift = SPECIFIC_IS_LIFT;
	specific_flags = SPECIFIC_FLAGS;
	specific_nc_pointer = SPECIFIC_NC_POINTER;
	specific_nc_index = SPECIFIC_NC_INDEX;
	specific_nc_x = SPECIFIC_NC_X;	
	specific_nc_y = SPECIFIC_NC_Y;
	specific_nc_rec = SPECIFIC_NC_REC;
	specific_nc_poff = SPECIFIC_NC_POFF;
	specific_scsi_id = SPECIFIC_SCSI_ID;
	specific_scsi_controller = SPECIFIC_SCSI_CONTROLLER;
	specific_spiral_check = SPECIFIC_SPIRAL_CHECK;
	specific_read_fast = SPECIFIC_READ_FAST;
	specific_read_slow = SPECIFIC_READ_SLOW;
	specific_read_overhead = SPECIFIC_READ_OVERHEAD;
	specific_bin_factor = SPECIFIC_BIN_FACTOR;
	specific_is_kappa = SPECIFIC_IS_KAPPA;
	specific_is_omega = SPECIFIC_IS_OMEGA;
	specific_def_dezinger = SPECIFIC_DEF_DEZINGER;
	specific_is_2theta = SPECIFIC_IS_2THETA;
	specific_pcshutter = SPECIFIC_PCSHUTTER;
	specific_dark_interval = SPECIFIC_DARK_INTERVAL;
	specific_pixel_size = SPECIFIC_PIXEL_SIZE;
	specific_dk_before_run = SPECIFIC_DK_BEFORE_RUN;
	specific_repeat_dark = repeat_dark_current; 
	specific_outfile_type = SPECIFIC_OUTFILE_TYPE;
	specific_detector_sn = SPECIFIC_DETECTOR_SN;
	specific_no_transform = SPECIFIC_NO_TRANSFORM;
	specific_output_raws = SPECIFIC_OUTPUT_RAWS;
	specific_j5_trigger = SPECIFIC_J5_TRIGGER;
	specific_timecheck = SPECIFIC_TIMECHECK;
	specific_constrain_omega = SPECIFIC_CONSTRAIN_OMEGA;
	specific_constrain_phi   = SPECIFIC_CONSTRAIN_PHI;
	specific_constrain_kappa = SPECIFIC_CONSTRAIN_KAPPA;
	specific_strip_ave = SPECIFIC_STRIP_AVE;
	specific_bchk_time = SPECIFIC_BCHK_TIME;
	specific_bchk_deltaphi = SPECIFIC_BCHK_DELTAPHI;
	specific_is_wavelength = SPECIFIC_IS_WAVELENGTH;
	specific_approach_start = SPECIFIC_APPROACH_START;
	specific_chip_size_x = SPECIFIC_CHIP_SIZE_X;
	specific_chip_size_y = SPECIFIC_CHIP_SIZE_Y;
	specific_kappa_const = SPECIFIC_KAPPA_CONST;
	specific_madrun_naming = SPECIFIC_MADRUN_NAMING;
	specific_retryshort = SPECIFIC_RETRYSHORT;
	specific_ccd_modular = SPECIFIC_CCD_MODULAR;
        specific_pf_mod = SPECIFIC_PF_MOD;
	specific_min_velocity = SPECIFIC_MIN_VELOCITY;
	specific_max_velocity = SPECIFIC_MAX_VELOCITY;
	specific_allow_stills = SPECIFIC_ALLOW_STILLS;
	specific_pitch_tune_delta = SPECIFIC_PITCH_TUNE_DELTA;
	specific_bm8_mod = SPECIFIC_PITCH_TUNE_DELTA;
  }

/*
 *	This routine initializes scanner global
 *	variables now that the program has decided
 *	what the specific parameters actually are.
 */

ccd_init_vars()
  {
	int	mdc_sim_progress();
	int	ccd_hw_progress();
	void	mdc_sim_start();
	void	ccd_hw_start();

	if(mdc_simulation)
	  {
		dt_stat = 1.0;
		erase_time = specific_erase_time;
		scan_time = specific_scan_time;
		dc_erase_time = specific_dc_erase_time;
		phi_steps_deg = specific_phi_steps_deg;
		dist_steps_mm = specific_dist_steps_mm;
		lift_steps_mm = specific_lift_steps_mm;
		phi_top_speed = specific_phi_top_speed;
		dist_top_speed = specific_dist_top_speed;
		lift_top_speed = specific_lift_top_speed;
		dist_max_ref_point = specific_dist_max_point;
		dist_min_ref_point = specific_dist_min_point;
		lift_max_point = specific_lift_max_point;
		lift_min_point = specific_lift_min_point;
		units_per_second = specific_units_per_sec;
		units_per_dose = specific_units_per_dose;
		stat_wavelength = specific_wavelength;
		stat_multiplier = specific_multiplier;
		magic_flags = specific_flags;
		is_distance = specific_is_distance;
		is_phi = specific_is_phi;
		is_lift = specific_is_lift;
		is_2theta = specific_is_2theta;
		dark_current_interval = specific_dark_interval;
		pixel_size = specific_pixel_size;
		dk_before_run = specific_dk_before_run;
		repeat_dark_current = specific_repeat_dark;
		strip_ave = specific_strip_ave;
		bchk_time = specific_bchk_time;
		bchk_deltaphi = specific_bchk_deltaphi;
		is_wavelength = specific_is_wavelength;
		approach_start = specific_approach_start;
		chip_size_x = specific_chip_size_x;
		chip_size_y = specific_chip_size_y;
		kappa_const = specific_kappa_const;
		madrun_naming = specific_madrun_naming;
		retryshort = specific_retryshort;
		ccd_modular = specific_ccd_modular;
		pf_mod = specific_pf_mod;
		stat_attenuator = -1;	/* always begins as unknown */
		stat_hslit = -1;
		stat_vslit = -1;
		min_velocity = specific_min_velocity;
		max_velocity = specific_max_velocity;
		allow_stills = specific_allow_stills;
		pitch_tune_delta = specific_pitch_tune_delta;
		bm8_mod = specific_bm8_mod;

		nc_pointer = specific_nc_pointer;
		nc_index = specific_nc_index;
		nc_x = specific_nc_x;	
		nc_y = specific_nc_y;
		nc_rec = specific_nc_rec;
		nc_poff = specific_nc_poff;

		stat_mode = 0;
		scsi_id = specific_scsi_id;
		scsi_controller = specific_scsi_controller;
		spiral_check = specific_spiral_check;

		beam_xcen = 45.;
		beam_ycen = 45.;

		outfile_type = specific_outfile_type;
		detector_sn = specific_detector_sn;
		raw_ccd_image = specific_no_transform;
		output_raws = specific_output_raws;
		constrain_omega = specific_constrain_omega;
		constrain_phi   = specific_constrain_phi;
		constrain_kappa = specific_constrain_kappa;

		mdc_cmd_progress = mdc_sim_progress;
		mdc_cmd_start = mdc_sim_start;

		mdc_sim_initial_status();
	  }
	 else
	  {
		dt_stat = 1.0;
		erase_time = specific_erase_time;
		dc_erase_time = specific_dc_erase_time;
		scan_time = specific_scan_time;
		phi_steps_deg = specific_phi_steps_deg;
		dist_steps_mm = specific_dist_steps_mm;
		lift_steps_mm = specific_lift_steps_mm;
		phi_top_speed = specific_phi_top_speed;
		dist_top_speed = specific_dist_top_speed;
		lift_top_speed = specific_lift_top_speed;
		dist_max_ref_point = specific_dist_max_point;
		dist_min_ref_point = specific_dist_min_point;
		lift_max_point = specific_lift_max_point;
		lift_min_point = specific_lift_min_point;
		units_per_second = specific_units_per_sec;
		units_per_dose = specific_units_per_dose;
		stat_wavelength = specific_wavelength;
		stat_multiplier = specific_multiplier;
		magic_flags = specific_flags;
		is_distance = specific_is_distance;
		is_phi = specific_is_phi;
		is_lift = specific_is_lift;
		read_fast = specific_read_fast;
		read_slow = specific_read_slow;
		read_overhead = specific_read_overhead;
		bin_factor = specific_bin_factor;
		is_kappa = specific_is_kappa;
		is_omega = specific_is_omega;
		def_dezinger = specific_def_dezinger;
		is_2theta = specific_is_2theta;
		use_pc_shutter = specific_pcshutter;
		use_j5_trigger = specific_j5_trigger;
		use_timecheck = specific_timecheck;
		dark_current_interval = specific_dark_interval;
		pixel_size = specific_pixel_size;
		dk_before_run = specific_dk_before_run;
		repeat_dark_current = specific_repeat_dark;
		strip_ave = specific_strip_ave;
		bchk_time = specific_bchk_time;
		bchk_deltaphi = specific_bchk_deltaphi;
		is_wavelength = specific_is_wavelength;
		approach_start = specific_approach_start;
		chip_size_x = specific_chip_size_x;
		chip_size_y = specific_chip_size_y;
		kappa_const = specific_kappa_const;
		madrun_naming = specific_madrun_naming;
		retryshort = specific_retryshort;
		ccd_modular = specific_ccd_modular;
		pf_mod = specific_pf_mod;
		stat_attenuator = -1;		/* always begins as unknown */
		stat_hslit = -1;
		stat_vslit = -1;
		min_velocity = specific_min_velocity;
		max_velocity = specific_max_velocity;
		allow_stills = specific_allow_stills;
		pitch_tune_delta = specific_pitch_tune_delta;
		bm8_mod = specific_bm8_mod;

		nc_pointer = specific_nc_pointer;
		nc_index = specific_nc_index;
		nc_x = specific_nc_x;	
		nc_y = specific_nc_y;
		nc_rec = specific_nc_rec;
		nc_poff = specific_nc_poff;

		stat_mode = 0;
		scsi_id = specific_scsi_id;
		scsi_controller = specific_scsi_controller;
		spiral_check = specific_spiral_check;

		beam_xcen = 45.;
		beam_ycen = 45.;

		outfile_type = specific_outfile_type;
		detector_sn = specific_detector_sn;
		raw_ccd_image = specific_no_transform;
		output_raws = specific_output_raws;
		constrain_omega = specific_constrain_omega;
		constrain_phi   = specific_constrain_phi;
		constrain_kappa = specific_constrain_kappa;

		mdc_cmd_progress = ccd_hw_progress;
		mdc_cmd_start = ccd_hw_start;

		fdmar = -1;	/* this module does NOT perform hardware operatons */
	  }
  }

/*
 *	This routine handles the name translation
 *	and file opens, leaving all in their proper
 *	state.
 *
 *	Network version:
 *	  Open up the log file.
 *	  Open up the config file.
 *	  Open up the profile file.
 */

ccd_init_files()
  {
	int	i;
	char	temp[50];

	/*
	 *	Translate logical names.
	 */

	if(0 == trnlog(trntable,"CCDSCANDIR",scan_dir))                      
	  {
	    fprintf(stderr,
	      "Please set the logical name or environment variable CCDSCANDIR\n");
	    fprintf(stderr,
	      "Then re-execute ccd_dc.\n");
	    cleanexit(BAD_STATUS);
	  }
	i = strlen(scan_dir);
	if(i > 0)
	  {
	    if(scan_dir[i-1] != '/' && scan_dir[i-1] != '\\')
	      {
		scan_dir[i] = '/'; scan_dir[i+1] = '\0';
	      }
	  }
	if(0 == trnlog(trntable,"CCDSCANDIR_EXPORT",scan_dir_export))                      
	  {
	    fprintf(stderr,
	      "Please set the logical name or environment variable CCDSCANDIR_EXPORT\n");
	    fprintf(stderr,
	      "Then re-execute ccd_dc.\n");
	    cleanexit(BAD_STATUS);
	  }
	i = strlen(scan_dir_export);
	if(i > 0)
	  {
	    if(scan_dir_export[i-1] != '/' && scan_dir[i-1] != '\\')
	      {
		scan_dir_export[i] = '/'; scan_dir_export[i+1] = '\0';
	      }
	  }

	if(0 == trnlog(trntable,CCD_DC_LOCAL_LOG,lfname))
	  {
	    fprintf(stderr,
	      "Please set the logical name or environment variable.\n");
	    fprintf(stderr,
	      "Then re-execute ccd_dc.\n");
	    cleanexit(BAD_STATUS);
	  }
        if(0 == trnlog(trntable,CCD_DC_CONFIG,confname))
          {
            fprintf(stderr,
              "Please set the logical name or environment variable.\n");
            fprintf(stderr,
              "Then re-execute ccd_dc.\n");
            cleanexit(BAD_STATUS);
          }
        if(0 != trnlog(trntable,CCD_N_CTRL,temp))
	    sscanf(temp,"%d",&n_ctrl);
	  else
	    n_ctrl = 1;

	/*
	 *	Open up log file only.
	 */
	
	if(NULL == (fplog = fopen(lfname,OPENA_REC)))
	  {
	    fprintf(stderr,"Cannot open %s as ccd log file\n",lfname);
	    cleanexit(BAD_STATUS);
	  }

  }

/*
 *	ccd_init_config
 *
 *	This routine allows the user to override default
 *	values for the scanner specific variables from
 *	a configuration file.
 *
 *	The format of the configuration file is:
 *
 *	keyword		value
 *
 *	The user may specify as little of the formal
 *	keyword as is necessary for unambiguous
 *	determination of the keyword.
 */

/*
 *	keywords:
 */

struct config_key {
			char	*key_name;
			char	*key_abbr;
			int	key_value;
		  };

enum {
	KEY_ERASE_TIME	=      0,
	KEY_SCAN_TIME		,
	KEY_DC_ERASE_TIME	,
	KEY_TOTAL_VALID_BLOCKS	,
	KEY_TOTAL_PIXELS_X	,
	KEY_TOTAL_PIXELS_Y	,
	KEY_MULTIPLIER		,
	KEY_PHI_STEPS_DEG	,
	KEY_DIST_STEPS_MM	,
	KEY_PHI_TOP_SPEED	,
	KEY_DIST_TOP_SPEED	,
	KEY_DIST_MAX_POINT	,
	KEY_DIST_MIN_POINT	,
	KEY_UNITS_PER_SEC	,
	KEY_UNITS_PER_DOSE	,
	KEY_WAVELENGTH		,
	KEY_IS_DIST		,
	KEY_IS_PHI		,
	KEY_FLAGS		,
	KEY_NC_POINTER		,
	KEY_NC_INDEX		,
	KEY_NC_X		,
	KEY_NC_Y		,
	KEY_NC_REC		,
	KEY_NC_POFF		,
	KEY_SCSI_ID		,
	KEY_SCSI_CONTROLLER	,
	KEY_SPIRAL_CHECK	,
	KEY_LIFT_STEPS_MM       ,
	KEY_LIFT_TOP_SPEED      ,
	KEY_LIFT_MAX_POINT      ,
	KEY_LIFT_MIN_POINT      ,
	KEY_IS_LIFT             ,
	KEY_READ_FAST		,
	KEY_READ_SLOW		,
	KEY_READ_OVERHEAD	,
	KEY_BIN_FACTOR		,
	KEY_USEKAPPA		,
	KEY_USEOMEGA		,
	KEY_DEZINGER		,
	KEY_USE2THETA		,
	KEY_PCSHUTTER		,
	KEY_DARKINTERVAL	,
	KEY_PIXEL_SIZE		,
	KEY_DK_BEFORE_RUN	,
	KEY_REPEAT_DARK		,
	KEY_OUTFILE_TYPE	,
	KEY_DETECTOR_SN		,
	KEY_NO_TRANSFORM	,
	KEY_OUTPUT_RAWS		,
	KEY_J5_TRIGGER		,
	KEY_TIMECHECK		,
	KEY_CONSTRAIN_OMEGA	,
	KEY_CONSTRAIN_PHI	,
	KEY_CONSTRAIN_KAPPA	,
	KEY_STRIP_AVE		,
	KEY_BCHK_TIME		,
	KEY_BCHK_DELTAPHI	,
	KEY_USEWAVELENGTH	,
	KEY_APPROACH_START	,
	KEY_CHIP_SIZE_X		,
	KEY_CHIP_SIZE_Y		,
	KEY_KAPPA_CONST		,
	KEY_DAEMON_EXIT		,
	KEY_USEZERO_ANGLES	,
	KEY_USEGON_MANUAL	,
	KEY_MADRUN_NAMING	,
	KEY_RETRYSHORT		,
	KEY_CCD_MODULAR		,
	KEY_PF_MOD		,
	KEY_MIN_VELOCITY	,
	KEY_MAX_VELOCITY	,
	KEY_ALLOW_STILLS	,
	KEY_PITCH_TUNE_DELTA	,
	KEY_BM8_MOD
  };

struct config_key config_list[] = 
  {
		"erasetime","erasetime",KEY_ERASE_TIME, 
		"scantime","scantime",KEY_SCAN_TIME,
		"dcerasetime","dcerasetime",KEY_DC_ERASE_TIME,
		"blocks","blocks",KEY_TOTAL_VALID_BLOCKS,
		"pixelsx","pixelsx", KEY_TOTAL_PIXELS_X,
		"pixelsy","pixelsy",KEY_TOTAL_PIXELS_Y,
		"multiplier","multiplier",KEY_MULTIPLIER,
		"phisteps","phisteps",KEY_PHI_STEPS_DEG,
		"diststeps","diststeps",KEY_DIST_STEPS_MM,
		"phitop","phit",KEY_PHI_TOP_SPEED,
		"disttop","distt",KEY_DIST_TOP_SPEED,
		"distmax","distmax",KEY_DIST_MAX_POINT,
		"distmin","distmin",KEY_DIST_MIN_POINT,
		"unitsec","units",KEY_UNITS_PER_SEC,
		"unitdose","unitd",KEY_UNITS_PER_DOSE,
		"wavelength","wavelength",KEY_WAVELENGTH,
		"usedistance","usedistance",KEY_IS_DIST,
		"usephi","usephi",KEY_IS_PHI,
		"flags","flags",KEY_FLAGS,
		"nc_pointer","nc_poi",KEY_NC_POINTER,
		"nc_index","nc_i",KEY_NC_INDEX,
		"nc_x","nc_x",KEY_NC_X,
		"nc_y","nc_y",KEY_NC_Y,
		"nc_rec","nc_r",KEY_NC_REC,
		"nc_poff","nc_pof",KEY_NC_POFF,
		"scsi_id","scsi_id",KEY_SCSI_ID,
		"scsi_controller","scsi_controller",KEY_SCSI_CONTROLLER,
		"spiral_check","spiral_check",KEY_SPIRAL_CHECK,
		"liftsteps","liftsteps",KEY_LIFT_STEPS_MM,
		"lifttop","lifttop",KEY_LIFT_TOP_SPEED,
		"liftmax","liftmax",KEY_LIFT_MAX_POINT,
		"liftmin","liftmin",KEY_LIFT_MIN_POINT,
		"uselift","uselift",KEY_IS_LIFT,
		"read_fast","read_fast",KEY_READ_FAST,
		"read_slow","read_slow",KEY_READ_SLOW,
		"read_overhead","read_overhead",KEY_READ_OVERHEAD,
		"bin_factor","bin_factor",KEY_BIN_FACTOR,
		"usekappa","usekappa",KEY_USEKAPPA,
		"useomega","useomega",KEY_USEOMEGA,
		"dezinger","dezinger",KEY_DEZINGER,
		"use2theta","use2theta",KEY_USE2THETA,
		"pcshutter","pcshutter",KEY_PCSHUTTER,
		"darkinterval","darkinterval",KEY_DARKINTERVAL,
		"pixel_size","pixel_size",KEY_PIXEL_SIZE,
		"dk_before_run","dk_before_run",KEY_DK_BEFORE_RUN,
		"repeat_dark","repeat_dark",KEY_REPEAT_DARK,
		"outfile_type","outfile_type",KEY_OUTFILE_TYPE,
		"detector_sn","detector_sn",KEY_DETECTOR_SN,
		"no_transform","no_transform",KEY_NO_TRANSFORM,
		"output_raws","output_raws",KEY_OUTPUT_RAWS,
		"j5_trigger","j5_trigger",KEY_J5_TRIGGER,
		"timecheck","timecheck",KEY_TIMECHECK,
		"constrain_omega","constrain_omega",KEY_CONSTRAIN_OMEGA,
		"constrain_phi","constrain_phi",KEY_CONSTRAIN_PHI,
		"constrain_kappa","constrain_kappa",KEY_CONSTRAIN_KAPPA,
		"strip_ave","strip_ave",KEY_STRIP_AVE,
		"beamcheck_time","beamcheck_time",KEY_BCHK_TIME,
		"beamcheck_deltaphi","beamcheck_deltaphi",KEY_BCHK_DELTAPHI,
		"usewavelength","usewavelength",KEY_USEWAVELENGTH,
		"approach_start","approach_start",KEY_APPROACH_START,
		"chip_size_x","chip_size_x",KEY_CHIP_SIZE_Y,
		"chip_size_y","chip_size_y",KEY_CHIP_SIZE_X,
		"kappa_const","kappa_const",KEY_KAPPA_CONST,
		"daemon_exit","daemon_exit",KEY_DAEMON_EXIT,
		"usezero_angles","usezero_angles",KEY_USEZERO_ANGLES,
		"usegon_manual","usegon_manual",KEY_USEGON_MANUAL,
		"madrun_naming","madrun_naming",KEY_MADRUN_NAMING,
		"retryshort","retryshort",KEY_RETRYSHORT,
		"modular", "modular", KEY_CCD_MODULAR,
		"pf_mod", "pf_mod", KEY_PF_MOD,
		"min_velocity", "min_velocity", KEY_MIN_VELOCITY,
		"max_velocity", "max_velocity", KEY_MAX_VELOCITY,
		"allow_stills", "allow_stills", KEY_ALLOW_STILLS,
		"pitch_tune_delta","pitch_tune_delta", KEY_PITCH_TUNE_DELTA,
		"bm8_mod","bm8_mod", KEY_BM8_MOD,
		NULL,NULL,0,
  };

ccd_init_config(fpmsg)
FILE	*fpmsg;
  {
	char	tname[256];
	char	line[132];
	char	string1[132],string2[132];
	int	i,j;

	strcpy(tname,confname);

	if(NULL == (fpconfig = fopen(tname,"r")))
	  {
	    fprintf(stderr,"ccd_dc: config: cannot open config file %s\n",tname);
	    fprintf(fplog,"ccd_dc: config: cannot open config file %s\n",tname);
	    fflush(fplog);
	    return;
	  }

	while(NULL != fgets(line,sizeof line,fpconfig))
	  {
	    if(line[0] == '!' || line[0] == '#')
	      {
		fprintf(fpmsg,"%s",line);
		fprintf(fplog,"%s",line);
		continue;
	      }
	    i = sscanf(line,"%s%s",string1,string2);
	    if(i != 2)
	      {
		fprintf(stderr,"ccd_dc: config: not enough params (need 2):\n");
		fprintf(stderr,"%s",line);
		fprintf(stderr,"ccd_dc: config: ignoring that line.\n");
		continue;
	      }
	    j = 0;
	    for(i = 0; config_list[i].key_name != NULL; i++)
	      if(0 == strncmp(config_list[i].key_abbr,string1,strlen(config_list[i].key_abbr)))
		{
			j = 1;
			break;
		}
	    if(j == 0)
	      {
		fprintf(stderr,"ccd_dc: config: unrecognized keyword:\n");
		fprintf(stderr,"%s",line);
		fprintf(stderr,"ccd_dc: config: ignoring that line.\n");
		continue;
	      }
	    switch(config_list[i].key_value)
	      {
		case	KEY_ERASE_TIME:
			sscanf(string2,"%f",&specific_erase_time);
			fprintf(fpmsg,"ccd_dc: config: %s set to %10.2f\n",
				config_list[i].key_name,specific_erase_time);
			fprintf(fplog,"ccd_dc: config: %s set to %10.2f\n",
				config_list[i].key_name,specific_erase_time);
			break;
		case	KEY_SCAN_TIME:
			sscanf(string2,"%f",&specific_scan_time);
			fprintf(fpmsg,"ccd_dc: config: %s set to %10.2f\n",
				config_list[i].key_name,specific_scan_time);
			fprintf(fplog,"ccd_dc: config: %s set to %10.2f\n",
				config_list[i].key_name,specific_scan_time);
			break;
		case	KEY_DC_ERASE_TIME:
			sscanf(string2,"%f",&specific_dc_erase_time);
			fprintf(fpmsg,"ccd_dc: config: %s set to %10.2f\n",
				config_list[i].key_name,specific_dc_erase_time);
			fprintf(fplog,"ccd_dc: config: %s set to %10.2f\n",
				config_list[i].key_name,specific_dc_erase_time);
			break;
		case	KEY_TOTAL_VALID_BLOCKS:
			sscanf(string2,"%d",&specific_total_valid_blocks);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_total_valid_blocks);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_total_valid_blocks);
			break;
		case	KEY_TOTAL_PIXELS_X:
			sscanf(string2,"%d",&specific_total_pixels_x);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_total_pixels_x);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_total_pixels_x);
			break;
		case	KEY_TOTAL_PIXELS_Y:
			sscanf(string2,"%d",&specific_total_pixels_y);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_total_pixels_y);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_total_pixels_y);
			break;
		case	KEY_MULTIPLIER:
			sscanf(string2,"%f",&specific_multiplier);
			fprintf(fpmsg,"ccd_dc: config: %s set to %10.2f\n",
				config_list[i].key_name,specific_multiplier);
			fprintf(fplog,"ccd_dc: config: %s set to %10.2f\n",
				config_list[i].key_name,specific_multiplier);
			break;
		case	KEY_PHI_STEPS_DEG:
			sscanf(string2,"%d",&specific_phi_steps_deg);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_phi_steps_deg);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_phi_steps_deg);
			break;
		case	KEY_DIST_STEPS_MM:
			sscanf(string2,"%d",&specific_dist_steps_mm);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_dist_steps_mm);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_dist_steps_mm);
			break;
		case	KEY_PHI_TOP_SPEED:
			sscanf(string2,"%d",&specific_phi_top_speed);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_phi_top_speed);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_phi_top_speed);
			break;
		case	KEY_DIST_TOP_SPEED:
			sscanf(string2,"%d",&specific_dist_top_speed);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_dist_top_speed);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_dist_top_speed);
			break;
		case	KEY_DIST_MAX_POINT:
			sscanf(string2,"%d",&specific_dist_max_point);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_dist_max_point);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_dist_max_point);
			break;
		case	KEY_DIST_MIN_POINT:
			sscanf(string2,"%d",&specific_dist_min_point);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_dist_min_point);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_dist_min_point);
			break;
		case	KEY_UNITS_PER_SEC:
			sscanf(string2,"%d",&specific_units_per_sec);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_units_per_sec);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_units_per_sec);
			break;
		case	KEY_UNITS_PER_DOSE:
			sscanf(string2,"%d",&specific_units_per_dose);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_units_per_dose);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_units_per_dose);
			break;
		case	KEY_WAVELENGTH:
			sscanf(string2,"%f",&specific_wavelength);
			fprintf(fpmsg,"ccd_dc: config: %s set to %10.2f\n",
				config_list[i].key_name,specific_wavelength);
			fprintf(fplog,"ccd_dc: config: %s set to %10.2f\n",
				config_list[i].key_name,specific_wavelength);
			break;
		case	KEY_IS_DIST:
			sscanf(string2,"%d",&specific_is_distance);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_is_distance);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_is_distance);
			break;
		case	KEY_IS_PHI:
			sscanf(string2,"%d",&specific_is_phi);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_is_phi);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_is_phi);
			break;
		case	KEY_FLAGS:
			sscanf(string2,"%d",&specific_flags);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_flags);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_flags);
			break;
		case	KEY_NC_POINTER:
			sscanf(string2,"%d",&specific_nc_pointer);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_nc_pointer);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_nc_pointer);
			break;
		case	KEY_NC_INDEX:
			sscanf(string2,"%d",&specific_nc_index);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_nc_index);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_nc_index);
			break;
		case	KEY_NC_X:
			sscanf(string2,"%d",&specific_nc_x);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_nc_x);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_nc_x);
			break;
		case	KEY_NC_Y:
			sscanf(string2,"%d",&specific_nc_y);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_nc_y);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_nc_y);
			break;
		case	KEY_NC_REC:
			sscanf(string2,"%d",&specific_nc_rec);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_nc_rec);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_nc_rec);
			break;
		case	KEY_NC_POFF:
			sscanf(string2,"%d",&specific_nc_poff);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_nc_poff);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_nc_poff);
			break;
		case	KEY_SCSI_ID:
			sscanf(string2,"%d",&specific_scsi_id);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_scsi_id);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_scsi_id);
			break;
		case	KEY_SCSI_CONTROLLER:
			sscanf(string2,"%d",&specific_scsi_controller);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_scsi_controller);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_scsi_controller);
			break;
		case	KEY_SPIRAL_CHECK:
			sscanf(string2,"%d",&specific_spiral_check);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",config_list[i].key_name,specific_spiral_check);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",config_list[i].key_name,specific_spiral_check);
			break;
		case	KEY_LIFT_STEPS_MM:
			sscanf(string2,"%d",&specific_lift_steps_mm);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_lift_steps_mm);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_lift_steps_mm);
			break;
		case	KEY_LIFT_TOP_SPEED:
			sscanf(string2,"%d",&specific_lift_top_speed);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_lift_top_speed);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_lift_top_speed);
			break;
		case	KEY_LIFT_MAX_POINT:
			sscanf(string2,"%d",&specific_lift_max_point);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_lift_max_point);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_lift_max_point);
			break;
		case	KEY_LIFT_MIN_POINT:
			sscanf(string2,"%d",&specific_lift_min_point);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_lift_min_point);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_lift_min_point);
			break;
		case	KEY_IS_LIFT:
			sscanf(string2,"%d",&specific_is_lift);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_is_lift);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_is_lift);
			break;
		case	KEY_READ_FAST:
			sscanf(string2,"%f",&specific_read_fast);
			fprintf(fpmsg,"ccd_dc: config: %s set to %5.2f\n",
				config_list[i].key_name,specific_read_fast);
			fprintf(fplog,"ccd_dc: config: %s set to %5.2f\n",
				config_list[i].key_name,specific_read_fast);
			break;
		case	KEY_READ_SLOW:
			sscanf(string2,"%f",&specific_read_slow);
			fprintf(fpmsg,"ccd_dc: config: %s set to %5.2f\n",
				config_list[i].key_name,specific_read_slow);
			fprintf(fplog,"ccd_dc: config: %s set to %5.2f\n",
				config_list[i].key_name,specific_read_slow);
			break;
		case	KEY_READ_OVERHEAD:
			sscanf(string2,"%f",&specific_read_overhead);
			fprintf(fpmsg,"ccd_dc: config: %s set to %5.2f\n",
				config_list[i].key_name,specific_read_overhead);
			fprintf(fplog,"ccd_dc: config: %s set to %5.2f\n",
				config_list[i].key_name,specific_read_overhead);
			break;
		case	KEY_BIN_FACTOR:
			sscanf(string2,"%f",&specific_bin_factor);
			fprintf(fpmsg,"ccd_dc: config: %s set to %5.2f\n",
				config_list[i].key_name,specific_bin_factor);
			fprintf(fplog,"ccd_dc: config: %s set to %5.2f\n",
				config_list[i].key_name,specific_bin_factor);
			break;
		case	KEY_USEKAPPA:
			sscanf(string2,"%d",&specific_is_kappa);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_is_kappa);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_is_kappa);
			break;
		case	KEY_USEOMEGA:
			sscanf(string2,"%d",&specific_is_omega);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_is_omega);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_is_omega);
			break;
		case	KEY_DEZINGER:
			sscanf(string2,"%d",&specific_def_dezinger);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_def_dezinger);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_def_dezinger);
			break;
		case	KEY_USE2THETA:
			sscanf(string2,"%d",&specific_is_2theta);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_is_2theta);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_is_2theta);
			fprintf(stderr,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_is_2theta);
			break;
		case	KEY_USEWAVELENGTH:
			sscanf(string2,"%d",&specific_is_wavelength);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_is_wavelength);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_is_wavelength);
			fprintf(stderr,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_is_wavelength);
			break;
		case	KEY_APPROACH_START:
			sscanf(string2,"%f",&specific_approach_start);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_approach_start);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_approach_start);
			fprintf(stderr,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_approach_start);
			break;
                case    KEY_CHIP_SIZE_X:
                        sscanf(string2,"%d",&specific_chip_size_x);
                        fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
                                config_list[i].key_name,specific_chip_size_x);
                        fprintf(fplog,"ccd_dc: config: %s set to %d\n",
                                config_list[i].key_name,specific_chip_size_x);
                        fprintf(stderr,"ccd_dc: config: %s set to %d\n",
                                config_list[i].key_name,specific_chip_size_x);
                        break;
                case    KEY_CHIP_SIZE_Y:
                        sscanf(string2,"%d",&specific_chip_size_y);
                        fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
                                config_list[i].key_name,specific_chip_size_y);
                        fprintf(fplog,"ccd_dc: config: %s set to %d\n",
                                config_list[i].key_name,specific_chip_size_y);
                        fprintf(stderr,"ccd_dc: config: %s set to %d\n",
                                config_list[i].key_name,specific_chip_size_y);
                        break;
		case	KEY_PCSHUTTER:
			sscanf(string2,"%d",&specific_pcshutter);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_pcshutter);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_pcshutter);
			break;
		case	KEY_DARKINTERVAL:
			sscanf(string2,"%d",&specific_dark_interval);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_dark_interval);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_dark_interval);
			break;
		case	KEY_PIXEL_SIZE:
			sscanf(string2,"%f",&specific_pixel_size);
			fprintf(fpmsg,"ccd_dc: config: %s set to %f\n",
				config_list[i].key_name,specific_pixel_size);
			fprintf(fplog,"ccd_dc: config: %s set to %f\n",
				config_list[i].key_name,specific_pixel_size);
			break;
		case	KEY_BCHK_TIME:
			sscanf(string2,"%f",&specific_bchk_time);
			fprintf(fpmsg,"ccd_dc: config: %s set to %f\n",
				config_list[i].key_name,specific_bchk_time);
			fprintf(fplog,"ccd_dc: config: %s set to %f\n",
				config_list[i].key_name,specific_bchk_time);
			break;
		case	KEY_BCHK_DELTAPHI:
			sscanf(string2,"%f",&specific_bchk_deltaphi);
			fprintf(fpmsg,"ccd_dc: config: %s set to %f\n",
				config_list[i].key_name,specific_bchk_deltaphi);
			fprintf(fplog,"ccd_dc: config: %s set to %f\n",
				config_list[i].key_name,specific_bchk_deltaphi);
			break;
		case	KEY_DK_BEFORE_RUN:
			sscanf(string2,"%d",&specific_dk_before_run);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_dk_before_run);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_dk_before_run);
			break;
		case	KEY_REPEAT_DARK:
			sscanf(string2,"%d",&specific_repeat_dark);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_repeat_dark);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_repeat_dark);
			break;
		case	KEY_DETECTOR_SN:
			sscanf(string2,"%d",&specific_detector_sn);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_detector_sn);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_detector_sn);
			break;
		case	KEY_NO_TRANSFORM:
			sscanf(string2,"%d",&specific_no_transform);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_no_transform);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_no_transform);
			break;
		case	KEY_OUTPUT_RAWS:
			sscanf(string2,"%d",&specific_output_raws);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_output_raws);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_output_raws);
			break;
		case	KEY_J5_TRIGGER:
			sscanf(string2,"%d",&specific_j5_trigger);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_j5_trigger);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_j5_trigger);
			break;
		case	KEY_STRIP_AVE:
			sscanf(string2,"%d",&specific_strip_ave);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_strip_ave);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_strip_ave);
			break;
		case	KEY_TIMECHECK:
			sscanf(string2,"%d",&specific_timecheck);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_timecheck);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_timecheck);
			break;
		case	KEY_CONSTRAIN_OMEGA:
			sscanf(string2,"%d",&specific_constrain_omega);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_constrain_omega);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_constrain_omega);
			break;
		case	KEY_CONSTRAIN_PHI:
			sscanf(string2,"%d",&specific_constrain_phi);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_constrain_phi);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_constrain_phi);
			break;
		case	KEY_CONSTRAIN_KAPPA:
			sscanf(string2,"%d",&specific_constrain_kappa);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_constrain_kappa);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_constrain_kappa);
			break;

			/*
			 *	These three are for the GUI only.  No effect on ccd_dc.
			 */

		case	KEY_DAEMON_EXIT:
			break;
		case	KEY_USEZERO_ANGLES:
			break;
		case	KEY_USEGON_MANUAL:
			break;

		case	KEY_KAPPA_CONST:
			sscanf(string2,"%f",&specific_kappa_const);
			fprintf(fpmsg,"ccd_dc: config: %s set to %7.3f\n",
				config_list[i].key_name,specific_kappa_const);
			fprintf(fplog,"ccd_dc: config: %s set to %7.3f\n",
				config_list[i].key_name,specific_kappa_const);
			break;
		case	KEY_MADRUN_NAMING:
			sscanf(string2,"%f",&specific_madrun_naming);
			fprintf(fpmsg,"ccd_dc: config: %s set to %7.3f\n",
				config_list[i].key_name,specific_madrun_naming);
			fprintf(fplog,"ccd_dc: config: %s set to %7.3f\n",
				config_list[i].key_name,specific_madrun_naming);
			break;
		case	KEY_RETRYSHORT:
			sscanf(string2,"%f",&specific_retryshort);
			fprintf(fpmsg,"ccd_dc: config: %s set to %7.3f\n",
				config_list[i].key_name,specific_retryshort);
			fprintf(fplog,"ccd_dc: config: %s set to %7.3f\n",
				config_list[i].key_name,specific_retryshort);
			break;
		case	KEY_CCD_MODULAR:
			sscanf(string2,"%d",&specific_ccd_modular);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_ccd_modular);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_ccd_modular);
			fprintf(stdout,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_ccd_modular);
			break;
		case	KEY_PF_MOD:
			sscanf(string2,"%d",&specific_pf_mod);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_pf_mod);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_pf_mod);
			fprintf(stdout,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_pf_mod);
			break;
		case	KEY_ALLOW_STILLS:
			sscanf(string2,"%d",&specific_allow_stills);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_allow_stills);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_allow_stills);
			fprintf(stdout,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_allow_stills);
			break;
		case	KEY_MIN_VELOCITY:
			sscanf(string2,"%f",&specific_min_velocity);
			fprintf(fpmsg,"ccd_dc: config: %s set to %10.5f\n",
				config_list[i].key_name,specific_min_velocity);
			fprintf(fplog,"ccd_dc: config: %s set to %10.5f\n",
				config_list[i].key_name,specific_min_velocity);
			fprintf(stdout,"ccd_dc: config: %s set to %10.5f\n",
				config_list[i].key_name,specific_min_velocity);
			break;
		case	KEY_MAX_VELOCITY:
			sscanf(string2,"%f",&specific_max_velocity);
			fprintf(fpmsg,"ccd_dc: config: %s set to %10.5f\n",
				config_list[i].key_name,specific_max_velocity);
			fprintf(fplog,"ccd_dc: config: %s set to %10.5f\n",
				config_list[i].key_name,specific_max_velocity);
			fprintf(stdout,"ccd_dc: config: %s set to %10.5f\n",
				config_list[i].key_name,specific_max_velocity);
			break;
		case	KEY_PITCH_TUNE_DELTA:
			sscanf(string2,"%d",&specific_pitch_tune_delta);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_pitch_tune_delta);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_pitch_tune_delta);
			fprintf(stdout,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_pitch_tune_delta);
			break;
		case	KEY_BM8_MOD:
			sscanf(string2,"%d",&specific_bm8_mod);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_bm8_mod);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_bm8_mod);
			fprintf(stdout,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_bm8_mod);
			break;
		case	KEY_OUTFILE_TYPE:
			if(0 == strcmp(string2,"signed_long") ||
			   0 == strcmp(string2,"int"))
				outfile_type = 1;
			if(outfile_type == 0)
			  {
			    fprintf(fpmsg,"ccd_dc: config: %s set to unsigned_short\n",
				config_list[i].key_name);
			    fprintf(fplog,"ccd_dc: config: %s set to unsigned_short\n",
				config_list[i].key_name);
			  }
			 else
			  {
			    fprintf(fpmsg,"ccd_dc: config: %s set to signed_long\n",
				config_list[i].key_name);
			    fprintf(fplog,"ccd_dc: config: %s set to signed_long\n",
				config_list[i].key_name);
			  }
			break;
	      }
	  }
	fflush(fplog);
	fclose(fpconfig);
  }

static	char	timeholder[120];

char	*ztime()
  {
	long	clock;
	char	*cptr;

	time(&clock);
	cptr = (char *) ctime(&clock);
	strcpy(timeholder,cptr);
	timeholder[strlen(timeholder) - 1] = '\0';
	return(timeholder);
  }
]0;capel@8bmserver1:/usr/local/ccd_dist/src_std/ccd_dc_api_mad_x8c[root@8bmserver1 ccd_dc_api_mad_x8c]# ca[K!ls
ls -lrt *.[ch]
[00m-rw-r--r--    1 1115     103            84 Apr 26  1999 [00mbzero.c[00m
-rw-r--r--    1 1115     103         10815 Apr 26  1999 [00mccd_dc_hwsim.c[00m
-rw-r--r--    1 1115     103          3274 Apr 26  1999 [00mccd_dc_sio.c[00m
-rw-r--r--    1 1115     103         16876 Apr 26  1999 [00mccd_dc_input_orig.c[00m
-rw-r--r--    1 1115     103           784 Apr 26  1999 [00mutil_misc.c[00m
-rw-r--r--    1 1115     103          8331 Apr 26  1999 [00mtest_seq_first.c[00m
-rw-r--r--    1 1115     103          9949 Apr 26  1999 [00mtest_seq.c[00m
-rw-r--r--    1 1115     103           629 Apr 26  1999 [00mparse_file_name.c[00m
-rw-r--r--    1 1115     103          2003 Apr 26  1999 [00mnet_client.c[00m
-rw-r--r--    1 1115     103          2082 Apr 26  1999 [00mvms_select.h[00m
-rw-r--r--    1 1115     103          3451 Jul  5  1999 [00mccd_dc_heartbeat.c[00m
-rw-r--r--    1 1115     103          1559 Jun 19  2001 [00mccd_dc_args.c[00m
-rw-r--r--    1 1115     103          4587 Jun 19  2001 [00mccd_dc_det.c[00m
-rw-r--r--    1 1115     103          1056 Jun 19  2001 [00mccd_dc_main.c[00m
-rw-r--r--    1 1115     103         19780 Apr 18 18:21 [00mccd_server.c[00m
-rw-r--r--    1 1115     103          4604 Apr 18 18:40 [00mccd_dc_bl.c[00m
-rw-r--r--    1 1115     103          1315 Apr 18 19:22 [00mget_attenuator.c[00m
-rw-r--r--    1 1115     103         22959 Apr 18 20:43 [00mccd_dc_input.c[00m
-rw-r--r--    1 1115     103          8100 Apr 24 18:51 [00mccd_dc_seq.c[00m
-rw-r--r--    1 1115     103          9363 Apr 24 18:52 [00mccd_dc_seq_nowork.c[00m
-rw-r--r--    1 1115     103         23181 May 20 23:55 [00mccd_dc_strstat.c[00m
-rw-r--r--    1 1115     103          9357 Aug 13 09:08 [00mccd_dc_defs.h[00m
-rw-r--r--    1 1115     103         17755 Aug 13 09:08 [00mccd_dc_glob.c[00m
-rw-r--r--    1 1115     103          9785 Aug 13 09:09 [00mccd_dc_ext.h[00m
-rw-r--r--    1 1115     103         42943 Aug 13 09:12 [00mccd_dc_misc.c[00m
-rw-r--r--    1 1115     103         51448 Aug 14 13:11 [00mccd_dc_hw.c[00m
[m]0;capel@8bmserver1:/usr/local/ccd_dist/src_std/ccd_dc_api_mad_x8c[root@8bmserver1 ccd_dc_api_mad_x8c]# cat ccd_dc_hw.c
#include	"ccd_dc_ext.h"

/*
 *----------------------------------------------
 *
 *	Module to sequence the control of the CCD
 *	hardware modules.
 *
 *	Two processes are used to run hardware:
 *		ccd_det		controls the detector.
 *		ccd_bl		controls the beamline.
 *
 *	In this implimentation, it is assumed that
 *	ccd_bl controls all hardware EXCEPT the detector.
 *
 *----------------------------------------------
 */

/*
 *	Routines to accurately calculate the
 *	time commands take to execute.  This
 *	is for the completeness statistics, for
 *	the most part, and does not actually
 *	alter functionality.
 */

static	time_t	tick_clock_val;

tick_set()
  {
	time(&tick_clock_val);
  }

int	tick_diff()
  {
	time_t	current_clock_val;
	int	diff_in_secs;

	time(&current_clock_val);
	diff_in_secs = ((int) current_clock_val) - ((int) tick_clock_val);
	tick_clock_val = current_clock_val;
	return(diff_in_secs);
  }

/*
 *	Operation codes for the initialize command.
 *
 *	These are software state variables to keep
 *	track of which initialize phase the program
 *	is doing.
 */

#define	INITOP_ABORT	0
#define	INITOP_RESET	1
#define	INITOP_SHUTTER	2
#define	INITOP_LOADTAB	3
#define	INITOP_DISTANCE	4

int	init_op;

/*
 *	Operation codes for the data collection command.
 *
 *	These are purely software states so the program
 *	can keep track of what part of data collection it
 *	is doing.
 */

#define	DCOP_COLLECT	0
#define	DCOP_SCAN	1
#define	DCOP_ERASE	2
#define	DCOP_RECRESET	3
#define	DCOP_RECERASE	4
#define	DCOP_RECSHUTTER	5

int	active_trans = 0;
int	scan_readout_in_progress = 0;	/* used to make sure we don't step on scan readout in progress */
int	scan_abort_readout = 0;		/* 1 to cause scan_readout to abort and close its files */

/*
 *	These are used to check to see if distance
 *	or phi actually move, and are used in conjunction
 *	with active_trans above.
 */

double	phi_value_saved;	/* value before a move */
double	omega_value_saved;	/* value before a move */
int	dist_value_saved;	/* value before a move */
int     lift_value_saved;
int	phi_no_motion;		/* 1 if no motion was initiated */
int     dist_no_motion;         /* 1 if no motion was initiated */
int     lift_no_motion;         /* 1 if no motion was initiated */

int	shutter_retry;		/* used to keep track for shutter errors */
int	collect_counter;	/* used to make sure we check c_error for collect */
int	reset_counter;		/* used to make sure we wait long enough */
int	init_dist_ctr;		/* used to make sure we wait long enough */
int	double_exp_flag;	/* 1 to do two exposures per actual image */
int	double_exp_ctr;		/* used to toggle double exposures */
int	doing_dark_current;	/* 1 if doing dark current exposures */
int	doing_second_dk;	/* 1 if doing second dark current */
int	doing_snapshot;		/* 1 if doing a shapshot */

int	goniostat_type = 0;	/* 0 for phi only, 1 for Eulerian, 2 for Kappa */
int	wedge_count;		/* used for counting down in a wedge */
int	wedge_side;		/* 0 if doing the primary run, 1 if doing the bijvoet */
int	wedge_run;		/* which_run is being collected */
int	wedge_imno;
int	wedge_size;
float	wedge_omega;
float	wedge_phi;
float	wedge_kappa;
char	wedge_prefix[256];	/* temp holding tank for prefix */

float	current_darkcurrent_time = 0;	/* keeps track of the length of the current dark current image */

static	int	gl_blret;
static	int	exposure_short_by;	/* number of seconds, approx., by which an exposure is "short" */
static	int	short_exposure_wait;	/* 1 when we are stalling for the "rest" of a short exposure */

parse_file_name(s,t,inp)
char	*s,*t;
int	*inp;
  {
	int	i,j,k;
	
	j = strlen(s);
	for(i = j - 1; i > 0 && s[i] != '_'; i--);
	if(i == 0)
	  {
	    *inp = 0;
	    strcpy(t,s);
	    return;
	  }
	for(j = i + 1; s[j] != '\0'; j++)
	  if(s[j] < '0' || s[j] > '9')
	    {
	    	*inp = 0;
		strcpy(t,s);
		return;
	    }
	*inp = atoi(&s[i + 1]);
	for(j = 0; j < i; j++)
	  t[j] = s[j];
	t[i] = '\0';
  }

/*
 *	make_header_smv  -  make a suitable SMV header.
 */

#define	SHDSIZE		20480

char	made_header[SHDSIZE];

make_header_smv()
  {
	char	buf[32];
	int	i;
	char	*cptr;
	char	*ztime();

	clrhd(made_header);

	/*
	 *	standard items.
	 */
	
	puthd("DIM","2",made_header);

#if defined(alpha) || defined(linux)
	puthd("BYTE_ORDER","little_endian",made_header);
#else
	puthd("BYTE_ORDER","big_endian",made_header);
#endif /* alpha */

	puthd("TYPE","unsigned_short",made_header);

	if(stat_bin == 1)
	  {
            sprintf(buf,"%d",chip_size_x);
            puthd("SIZE1",buf,made_header);
            sprintf(buf,"%d",chip_size_y);
            puthd("SIZE2",buf,made_header);
	    sprintf(buf,"%6.4f",pixel_size);
	    puthd("PIXEL_SIZE",buf,made_header);
	    puthd("BIN","none",made_header);
	  }
	 else
	  {
            sprintf(buf,"%d",chip_size_x / stat_bin);
            puthd("SIZE1",buf,made_header);
            sprintf(buf,"%d",chip_size_y / stat_bin);
            puthd("SIZE2",buf,made_header);
	    sprintf(buf,"%6.4f",pixel_size * stat_bin);
	    puthd("PIXEL_SIZE",buf,made_header);
	    puthd("BIN","2x2",made_header);
	  }
	if(stat_adc == 0)
	    puthd("ADC","slow",made_header);
	  else
	    puthd("ADC","fast",made_header);
	if(0)
	{
	for(i = 0; i < n_ctrl; i++)
	  {
		sprintf(buf,"CCD_OFFSET%d",i);
		puthd(buf,"xx",made_header);
	  }
	}
	/*
	 *	adsc items.
	 */
	if(detector_sn > 0)
	  {
		sprintf(buf,"%d",detector_sn);
		puthd("DETECTOR_SN",buf,made_header);
	  }
	cptr = ztime();
	puthd("DATE",cptr,made_header);
	sprintf(buf,"%.2f",stat_time);
	puthd("TIME",buf,made_header);
	sprintf(buf,"%.3f",stat_dist);
	puthd("DISTANCE",buf,made_header);
	sprintf(buf,"%.3f",stat_osc_width);
	puthd("OSC_RANGE",buf,made_header);
	if(stat_axis == 1)
	  {
	    if(is_kappa)
	      {
		sprintf(buf,"%.3f",phi_value_saved);
		puthd("PHI",buf,made_header);
		puthd("OSC_START",buf,made_header);
		sprintf(buf,"%.3f",stat_omega);
		puthd("OMEGA",buf,made_header);
	        sprintf(buf,"%.3f",stat_kappa);
	        puthd("KAPPA",buf,made_header);
	      }
	     else
	      {
		sprintf(buf,"%.3f",phi_value_saved);
		puthd("PHI",buf,made_header);
		puthd("OSC_START",buf,made_header);
	      }
	  }
	 else
	  {
	    if(is_kappa)
	      {
		sprintf(buf,"%.3f",omega_value_saved);
		puthd("OMEGA",buf,made_header);
		puthd("OSC_START",buf,made_header);
		sprintf(buf,"%.3f",stat_phi);
		puthd("PHI",buf,made_header);
	        sprintf(buf,"%.3f",stat_kappa);
	        puthd("KAPPA",buf,made_header);
	      }
	     else
	      {
		sprintf(buf,"%.3f",omega_value_saved);
		puthd("OMEGA",buf,made_header);
		puthd("OSC_START",buf,made_header);
	      }
	  }
	if(is_2theta)
	  {
	    sprintf(buf,"%.3f",stat_2theta);
	    puthd("TWOTHETA",buf,made_header);
	  }
	if(stat_axis == 1)
	    puthd("AXIS","phi",made_header);
	  else
	    puthd("AXIS","omega",made_header);
	sprintf(buf,"%.5f",stat_wavelength);
	puthd("WAVELENGTH",buf,made_header);
	sprintf(buf,"%.3f",beam_xcen);
	puthd("BEAM_CENTER_X",buf,made_header);
	sprintf(buf,"%.3f",beam_ycen);
	puthd("BEAM_CENTER_Y",buf,made_header);
        if(doing_dark_current)
                sprintf(buf,"%d",doing_second_dk * 2 + 2 - double_exp_ctr);
          else
            {
                if(double_exp_flag)
                        sprintf(buf,"%d",4 + 2 - double_exp_ctr);
                    else
                        strcpy(buf,"5");
            }
	if(stat_attenuator != -1)
	{
		get_attenuator_name((int) (stat_attenuator + .01), buf);
		puthd("ATTENUATOR", buf, made_header);
	}
	padhd(made_header,512);
  }

/*      Routine to set the beamline to give a lock on the beamline process before starting 
*       data collection.  Right now, all it does it close the shutter, but when fully implemented
*       it should do the following:
*       1. Request a lock from the beamline process.  Upon getting a lock the "collection in progress"
*          signal line will be active.
*       2. If a lock cannot be obtained at this time (because another process is using the beamline),
*          issue a message to this effect and poll until the lock can be obtained.
*       3. After getting a lock, close the shutter.
*
*       There is also an unlock command.  Use of locks is entirely voluntary and is not enforced.
*/

     void send_bl_lock()
{
  /* output_blcmd(fdblcmd,"cmd","get_lock"); */
}
     void send_bl_unlock()
{
  /*output_blcmd(fdblcmd,"cmd","release_lock"); */
}

/*
 *	Routine to send the start detector exposing command.  Main purpose
 *	here is to build up filenames.
 */

send_det_start()
  {
	char	tempbuf[1024],tbuf[1024],infobuf[512],morebuf[100];
	char	im_3dig[4];
	char	suffix[20];
	int	hsize;
        int  detret;
	double	tmp;
	int	kind;
	char *message[80];
	
	make_header_smv();
	gethdl(&hsize, made_header);

	sprintf(tempbuf,"start\nheader_size %d\n",hsize);

	if(doing_dark_current)
		sprintf(suffix,"dkx_%d",doing_second_dk * 2 + 2 - double_exp_ctr);
	  else
	    {
		if(double_exp_flag)
			sprintf(suffix,"imx_%d",2 - double_exp_ctr);
		    else
			sprintf(suffix,"imx_0");
	    }
	util_3digit(im_3dig,stat_image_number);
	sprintf(infobuf,"info %s_%s.%s\n",stat_prefix,im_3dig,suffix);

        sprintf(morebuf,"row_xfer %d\ncol_xfer %d\n",chip_size_y / stat_bin, chip_size_x / stat_bin);
        strcat(tempbuf,morebuf);

	if(use_pc_shutter)
	  {
	    if(doing_dark_current == 0)
	      strcat(tempbuf,"pcshutter 1\n");
	     else
	      strcat(tempbuf,"pcshutter 0\n");
	  }
	if(use_j5_trigger)
	      strcat(tempbuf,"j5_trigger 1\n");
	if(use_timecheck)
	      strcat(tempbuf,"timecheck 1\n");

	strcat(tempbuf,infobuf);
	sprintf(tbuf,"adc %d\nrow_bin %d\ncol_bin %d\ntime %f\n",stat_adc,stat_bin,stat_bin,stat_time);
	strcat(tempbuf,tbuf);
	if(ccd_modular)
	{
		sprintf(tbuf,"save_raw %d\n",output_raws);
		strcat(tempbuf,tbuf);

		if(raw_ccd_image == 0)
			sprintf(tbuf,"transform_image 1\n");
		else
			sprintf(tbuf,"transform_image 0\n");
		strcat(tempbuf,tbuf);

		if(doing_dark_current)
		    kind = 2 * doing_second_dk + 2 - double_exp_ctr;
		else
		  {
		    if(double_exp_flag)
		        kind = 4 + 2 - double_exp_ctr;
		    else
		        kind = 5;
		  }
		sprintf(tbuf,"image_kind %d\n",kind);
		strcat(tempbuf,tbuf);
	}

	detret = output_detcmd(fddetcmd,tempbuf,made_header,hsize);
        if (detret == CCD_DET_NOTCONNECTED) {
          dc_stop = 1;
	  sprintf(message[0]," send_det_start");
	  issue_signal("CCD_SIG_DET_DROPPED",message);
          set_alert_msg("ERROR: Detector control not connected.");
        }
  }

/*
 *	Routine to send the start beam line exposing command.  Main purpose
 *	here is to build up filenames.
 */

int	send_bl_start()
  {
	char	tempbuf[1024],tbuf[1024];
	char	im_3dig[4];
	char	suffix[20];
	double	tmp;
	int 	bline_ret;
	char	*ztime();
        time_t  t_start,t_end;
        int     i_start,i_end,time_total;
	char *message[80];

	if(doing_dark_current)
		sprintf(suffix,"dkc(%d)",doing_second_dk * 2 + 2 - double_exp_ctr);
	  else
	    {
		if(double_exp_flag)
			sprintf(suffix,"img(%d)",2 - double_exp_ctr);
		    else
			sprintf(suffix,"img");
	    }

	if(stat_axis == 1)
		tmp = phi_value_saved;
	    else
		tmp = omega_value_saved;
	sprintf(tempbuf,"collect\ntime %10.2f\ndistance %10.2f\nosc_width %10.3f\nphi_start %10.3f\n",
		stat_time,stat_dist,stat_osc_width,tmp);
	sprintf(tbuf,"wavelength %7.5f\ndirectory %s\nimage_prefix %s\nimage_suffix %s\nimage_number %d\n",
		stat_wavelength,stat_dir,stat_prefix,suffix,stat_image_number);
	strcat(tempbuf,tbuf);

	/*
	 *	To simplify for (older) software which does not support multiple axes, if
	 *	the data collection is not omega, omit the axis specification.
	 */

	if(stat_axis == 0)
		strcat(tempbuf,"axis 0\n");

	if(doing_dark_current)
	  strcat(tempbuf,"mode darkcurrent_dc\n");
         else {
             if (stat_mode == 1) {
               sprintf (tbuf,"mode dose\nstep_size %f\ndose_per_step %f\n",
                stat_step_size, stat_dose_step);
               strcat(tempbuf,tbuf);
             }
             else {
             strcat(tempbuf,"mode beamline_dc\n");
             }
           }

	sprintf(tbuf,"adc %d\nbin %d\n",stat_adc,stat_bin);
	strcat(tempbuf,tbuf);
	util_3digit(im_3dig,stat_image_number);
	fprintf(stdout,"send_bl_start: START         at %s: %s_%s.%s\n",ztime(),stat_prefix,im_3dig,suffix);

        time(&t_start);
	i_start = (int) t_start;

	bline_ret = output_blcmd(fdblcmd,"cmd",tempbuf);
        time(&t_end);
        i_end = (int) t_end;
        time_total = t_end - t_start;

	switch (bline_ret) {
	  case CCD_BL_FATAL:
		dc_stop = 1;
	  break;
	  case CCD_BL_NOTCONNECTED:
	  case CCD_BL_DISCONNECTED:
		dc_stop = 1;
		sprintf(message[0]," CCD_BL_NOTCONNECTED");
		issue_signal("CCD_SIG_BL_DROPPED");
                set_alert_msg("ERROR: Beamline control not connected.");
/* printf ("no beamline\n"); */
	  break;
          default:
	  break;
	}
	if(dc_stop == 0 && retryshort != 0)
	  {
            fprintf(stdout,"send_bl_start: TIMERS        at %s: total %d\n",ztime(),time_total);
	    fflush(stdout);
            if(time_total < (stat_time - 2.))   /* for sure too fast */
              {
                fprintf(stdout,"send_bl_start: DONE (retry)  at %s: EXPOSURE TOO SHORT\n",ztime());
	        fflush(stdout);
                bline_ret = CCD_BL_RETRY;
		exposure_short_by = (int) (stat_time - time_total);
		exposure_short_by += 3;		/* allow some slop here */
              }
          }
        return(bline_ret);
  }

/*
*      To collect a frame, one gets a lock on the beamline process, starts the detector in collection
*      mode, starts the beamline process, waits for completion indicating status, and then unlocks
*     the detector.
*
*/
void collect_frame()
{

#ifdef X8C
  send_bl_lock();
  output_blcmd(fdblcmd,"cmd","shutter 0");   /* close the shutter, just in case */
#endif /* X8C */

  send_det_start();
  gl_blret = send_bl_start();

#ifdef X8C
  send_bl_unlock();
#endif /* X8C */

}
send_copy_command()
  {
	int	len_xfcmd;
	char	xfcmd_buf[512];
        char    num[4];
        int     i,kind,raw_end;
	char	suffix[20],raw_suffix[20];
	char	body[512];
	char	dzstuff[100];
	int	hsize;

	gethdl(&hsize, made_header);

        if(raw_ccd_image == 1)
          sprintf(body,
 "copy\nreply 0\nrow_mm %f\ncol_mm %f\ndist_mm %f\ntwo_theta %f\nheader_size %d\nrow_xfer %d\ncol_xfer %d\nrow_bin %d\ncol_bin %d\n",
                beam_xcen,beam_ycen,stat_dist,stat_2theta,hsize,chip_size_y / stat_bin ,chip_size_x / stat_bin ,
                        stat_bin,stat_bin);
         else
          sprintf(body,
 "xform\nreply 0\nrow_mm %f\ncol_mm %f\ndist_mm %f\ntwo_theta %f\nheader_size %d\nrow_xfer %d\ncol_xfer %d\nrow_bin %d\ncol_bin %d\n",
                beam_xcen,beam_ycen,stat_dist,stat_2theta,hsize,chip_size_y / stat_bin,chip_size_x / stat_bin,
                        stat_bin,stat_bin);

	if(stat_compress == 1)
		strcat(body,"compress 1\n");
	    else
		strcat(body,"compress 0\n");
	if(detector_sn > 0)
	  {
		sprintf(dzstuff,"detector_sn %d\n",detector_sn);
		strcat(body,dzstuff);
	  }
	if(strip_ave)
	  {
		if(n_strip_ave == 4)
		  sprintf(dzstuff,"strip_ave %.3f_%.3f_%.3f_%.3f\n",strip_ave_vals[0],strip_ave_vals[1],
								    strip_ave_vals[2],strip_ave_vals[3]);
		 else
		  sprintf(dzstuff,"strip_ave %.3f\n",strip_ave_vals[0]);
		strcat(body,dzstuff);
	  }
	sprintf(dzstuff,"save_raw %d\n",output_raws);
	strcat(body,dzstuff);

	if(doing_dark_current)
	  {
	    if(doing_second_dk == 0)
	    	strcpy(suffix,"dkc");
	      else
		strcpy(suffix,"dkd");

	    strcpy(raw_suffix,"dkx");
	    kind = 2 * doing_second_dk + 2 - double_exp_ctr;
	    raw_end = kind;
	  }
	 else
	  {
	    strcpy(suffix,"img");
	    strcpy(raw_suffix,"imx");
	    if(double_exp_flag)
	      {
	        kind = 4 + 2 - double_exp_ctr;
		raw_end = 2 - double_exp_ctr;
		sprintf(dzstuff,"dzratio %f\n",stat_dzratio);
		strcat(body, dzstuff);
	      }
	     else
	      {
	        kind = 5;
		raw_end = 0;
	      }
	  }

	sprintf(dzstuff,"outfile_type %d\n",outfile_type);
	strcat(body,dzstuff);

        i = stat_image_number;
        num[0] = '0' + i / 100;
        i = i - 100 * (i / 100);
        num[1] = '0' + i / 10;
        i = i - 10 * (i / 10);
        num[2] = '0' + i;
        num[3] = '\0';

	if(-1 == fdxfcm)
	  {
		fprintf(stderr,"ccd_dc: xform command file is NOT connected.\n");
		fprintf(stderr,"ccd_dc: currently, THIS IS A WARNING\n");
	  }
	 else
	  {
		sprintf(xfcmd_buf,"%sinfile <socket>\noutfile %s%s_%s.%s\nrawfile %s%s_%s.%s_%d\nkind %d\n",
			body,stat_dir,stat_prefix,num,suffix,stat_dir,stat_prefix,num,raw_suffix,raw_end,kind);
		strcat(xfcmd_buf,"end_of_det\n");
		len_xfcmd = strlen(xfcmd_buf);
		if(len_xfcmd != rep_write(fdxfcm,xfcmd_buf,len_xfcmd))
		  {
			fprintf(stderr,"ccd_dc: xform process has disconnected.\n");
			fprintf(stderr,"ccd_dc: currently, THIS IS A WARNING.\n");
			notify_server_eof(fdxfcm);
		  }
	  }
  }

/*
 *	Get the next image from the runs file.
 */

get_next_image_from_runfile(mdccp)
mdc_command	*mdccp;
  {
	char	read_file_line[256],read_file_name[256];
	float	f1,f2,f3,f4,f5;
	char	tempbuf[2048];

	if(NULL != fgets(read_file_line,sizeof (read_file_line), fprun))
	  {
	    sscanf(read_file_line,"%s %f %f %f %f %f",read_file_name,&f1,&f2,&f3,&f4,&f5);
	    parse_file_name(read_file_name,stat_prefix,&stat_image_number);
	    mdccp->cmd_col_time = f1;
	    if(mdccp->cmd_col_kappas != -9999.)
	      {
		if(fabs(f5 - stat_kappa) > 0.0001)
		  {
			sprintf(tempbuf,"kappa_move %10.3f",f5);
	        	output_blcmd(fdblcmd,"cmd",tempbuf);
			stat_kappa = f5;
		  }
	      }
	    if(mdccp->cmd_col_phis != -9999.)
	      {
		if(fabs(f4 - stat_phi) > 0.0001)
		  {
			sprintf(tempbuf,"phi_move %10.3f",f4);
	        	output_blcmd(fdblcmd,"cmd",tempbuf);
			stat_phi = f4;
		        phi_value_saved = stat_phi;
		  }
	      }
	    if(mdccp->cmd_col_omegas != -9999.)
	      {
		if(fabs(f3 - stat_omega) > 0.0001)
		  {
			sprintf(tempbuf,"omega_move %10.3f",f3);
	        	output_blcmd(fdblcmd,"cmd",tempbuf);
			stat_omega = f3;
			omega_value_saved = stat_omega;
		  }
	      }
/*
 *	This needs to be changed so that it won't crash
 *	bl progs with no wavelength move:
 *	    if(fabs(f2 - stat_wavelength) > 0.001)
 */
 	    if(is_wavelength)
	      {
	        strcpy(stat_scanner_op,"setting_wavelength");
	        sprintf(tempbuf,"wavelength_move %.6f",f2);
	        output_blcmd(fdblcmd,"cmd",tempbuf);
	        stat_wavelength = f2;
	      }
	     else
	      {
 	        if(fabs(f2 - stat_wavelength) > 0.000005)
	          {
	            strcpy(stat_scanner_op,"setting_wavelength");
	            sprintf(tempbuf,"wavelength_move %.6f",f2);
	            output_blcmd(fdblcmd,"cmd",tempbuf);
	            stat_wavelength = f2;
	          }
	      }
	  }
	 else
	   totimg = 0;
  }

/*
 *	ccd_hw_start:
 *
 *	This is where all commands to the ccd detector system
 *	begin execution.
 *
 *	ccd_hw_start will begin the sequencing of possibly
 *	complex commands, splitting their functions between
 *	calls to the beamline control and detector control
 *	processes.
 */

void	ccd_hw_start(mdccp)
mdc_command	*mdccp;
  {
	int	current,wanted,nsteps_to_move;
	int	i,j,k,runno,need_new_dk;
	int	run_found;
	float	f1,f2,f3,f4,f5;
	char	read_file_line[256],read_file_name[256];
	char	tempfname[256];
	char	tempbuf[2048],tbuf[2048],prefix_without_run[80];
	int	bline_ret;
	int	ccd_hw_progress();
	int	read_bl_wavelength;
	float	wavelength_read;
	double	velocity;
	time_t	now;
	char *message[80];

	double	fabs();

	active_trans = 0;
	command_rejected = 0;

	strcpy(stat_scanner_control,"active");

        if(mdccp->cmd_no != MDC_COM_STARTUP)
          {
            if(fdblcmd == -1)
              {
		sprintf(message[0]," ccd_hw_start");
		issue_signal("CCD_SIG_BL_DROPPED",message);
                set_alert_msg("ERROR: Beamline process NOT connected.");
                return;
              }
          }

	switch(mdccp->cmd_no)
	  {
	    case MDC_COM_STARTUP:
		break;
	    case MDC_COM_INIT:

		strcpy(stat_scanner_op,"initializing");
		output_blcmd(fdblcmd,"cmd","initialize");

		break;

	    case MDC_COM_ERASE:

		break;

	    case MDC_COM_CONFIG:

		break;

	    case MDC_COM_DSET:

		strcpy(stat_scanner_op,"setting distance");
		sprintf(tempbuf,"distance_set %10.2f",mdccp->cmd_value);
		output_blcmd(fdblcmd,"cmd",tempbuf);
		stat_dist = mdccp->cmd_value;

		break;

	    case MDC_COM_PSET:

		strcpy(stat_scanner_op,"setting phi");
		sprintf(tempbuf,"phi_set %10.3f",mdccp->cmd_value);
		output_blcmd(fdblcmd,"cmd",tempbuf);
		stat_phi = mdccp->cmd_value;

		break;

	    case MDC_COM_OSET:

		strcpy(stat_scanner_op,"setting omega");
		sprintf(tempbuf,"omega_set %10.3f",mdccp->cmd_value);
		output_blcmd(fdblcmd,"cmd",tempbuf);
		stat_omega = mdccp->cmd_value;

		break;

	    case MDC_COM_KSET:

		strcpy(stat_scanner_op,"setting kappa");
		sprintf(tempbuf,"kappa_set %10.23",mdccp->cmd_value);
		output_blcmd(fdblcmd,"cmd",tempbuf);
		stat_kappa = mdccp->cmd_value;

		break;

	    case MDC_COM_LSET:

		delta = mdccp->cmd_value;
		strcpy(stat_scanner_op,"setting lift");
		sprintf(tempbuf,"lift_set %10.3f",mdccp->cmd_value);
		output_blcmd(fdblcmd,"cmd",tempbuf);
		stat_lift = delta;

		break;

            case MDC_COM_WSET:

                delta = mdccp->cmd_value;
                strcpy(stat_scanner_op,"setting wavelength");
                sprintf(tempbuf,"wavelength_set %7.5f",mdccp->cmd_value);
                output_blcmd(fdblcmd,"cmd",tempbuf);
                stat_wavelength = delta;

                break;

	    case MDC_COM_SHUT:

		strcpy(stat_scanner_op,"Shutter control");
		if(use_pc_shutter == 0)
		{
		if(mdccp->cmd_value != 0)
		  {
			strcpy(stat_scanner_shutter,"open");
			strcpy(tempbuf,"shutter 1");
		  }
		 else
		  {
			strcpy(stat_scanner_shutter,"closed");
			strcpy(tempbuf,"shutter 0");
		  }
		output_blcmd(fdblcmd,"cmd",tempbuf);
		} else {
		    if(mdccp->cmd_value != 0)
		      {
			strcpy(stat_scanner_shutter,"open");
			strcpy(tempbuf,"shutter\npcshutter 1\n");
		      }
		     else
		      {
			strcpy(stat_scanner_shutter,"closed");
			strcpy(tempbuf,"shutter\npcshutter 0\n");
		      }
		    output_detcmd(fddetcmd,tempbuf,NULL,0);
		    /*
		     *	This is prurely cosmetic:  This gets the
		     *	shutter status properly set via the beamline
		     *	process, which does not actually do anything
		     *	BUT set this status.
		     */
		    if(mdccp->cmd_value != 0)
		      {
			strcpy(stat_scanner_shutter,"open");
			strcpy(tempbuf,"shutter 1");
		      }
		     else
		      {
			strcpy(stat_scanner_shutter,"closed");
			strcpy(tempbuf,"shutter 0");
		      }
		    output_blcmd(fdblcmd,"cmd",tempbuf);
		  }



		break;

	    case MDC_COM_SCAN:

		break;

	    case MDC_COM_DMOVE:

		strcpy(stat_scanner_op,"moving distance");
		sprintf(tempbuf,"distance_move %10.2f",mdccp->cmd_value);
		output_blcmd(fdblcmd,"cmd",tempbuf);

		break;

	    case MDC_COM_LMOVE:

		strcpy(stat_scanner_op,"moving lift");
		sprintf(tempbuf,"lift_move %10.3f",mdccp->cmd_value);
		output_blcmd(fdblcmd,"cmd",tempbuf);

		break;

            case MDC_COM_WMOVE:

                strcpy(stat_scanner_op,"moving wavelength");
                sprintf(tempbuf,"wavelength_move %7.5f",mdccp->cmd_value);
                output_blcmd(fdblcmd,"cmd",tempbuf);

                break;

            case MDC_COM_AMOVE:

                strcpy(stat_scanner_op,"moving_attenuator");
                sprintf(tempbuf,"attenuator_move %8.5f",mdccp->cmd_value);
                output_blcmd(fdblcmd,"cmd",tempbuf);
                break;

            case MDC_COM_AUTOALIGN:

                strcpy(stat_scanner_op,"autoaligning");
                sprintf(tempbuf,"autoalign %.1f",mdccp->cmd_value);
                output_blcmd(fdblcmd,"cmd",tempbuf);
                break;

	    case MDC_COM_XL_HS_MOVE:

                strcpy(stat_scanner_op,"moving_horiz_slit");
                sprintf(tempbuf, "xl_hs_move %.3f", mdccp->cmd_value);
                output_blcmd(fdblcmd,"cmd",tempbuf);
		break;

	    case MDC_COM_XL_VS_MOVE:

                strcpy(stat_scanner_op,"moving_vert_slit");
                sprintf(tempbuf, "xl_vs_move %.3f", mdccp->cmd_value);
                output_blcmd(fdblcmd,"cmd",tempbuf);
		break;

	    case MDC_COM_XL_UP_HHS_MOVE:

                strcpy(stat_scanner_op,"moving_up_h_halfslit");
                sprintf(tempbuf, "xl_up_hhs_move %.1f", mdccp->cmd_value);
                output_blcmd(fdblcmd,"cmd",tempbuf);
		break;

	    case MDC_COM_XL_UP_VHS_MOVE:

                strcpy(stat_scanner_op,"moving_up_v_halfslit");
                sprintf(tempbuf, "xl_up_vhs_move %.1f", mdccp->cmd_value);
                output_blcmd(fdblcmd,"cmd",tempbuf);
		break;

	    case MDC_COM_XL_DN_HHS_MOVE:

                strcpy(stat_scanner_op,"moving_dn_h_halfslit");
                sprintf(tempbuf, "xl_dn_hhs_move %.1f", mdccp->cmd_value);
                output_blcmd(fdblcmd,"cmd",tempbuf);
		break;

	    case MDC_COM_XL_DN_VHS_MOVE:

                strcpy(stat_scanner_op,"moving_dn_v_halfslit");
                sprintf(tempbuf, "xl_dn_vhs_move %.1f", mdccp->cmd_value);
                output_blcmd(fdblcmd,"cmd",tempbuf);
		break;

	    case MDC_COM_PMOVE:

		strcpy(stat_scanner_op,"moving phi");
		sprintf(tempbuf,"phi_move %10.3f",mdccp->cmd_value);
		output_blcmd(fdblcmd,"cmd",tempbuf);

		break;

	    case MDC_COM_PMOVEREL:

		strcpy(stat_scanner_op,"moving phi");
		sprintf(tempbuf,"phi_move_rel %10.3f",mdccp->cmd_value);
		output_blcmd(fdblcmd,"cmd",tempbuf);

		break;

	    case MDC_COM_OMOVE:

		strcpy(stat_scanner_op,"moving omega");
		sprintf(tempbuf,"omega_move %10.3f",mdccp->cmd_value);
		output_blcmd(fdblcmd,"cmd",tempbuf);

		break;

	    case MDC_COM_KMOVE:

		strcpy(stat_scanner_op,"moving kappa");
		sprintf(tempbuf,"kappa_move %10.3f",mdccp->cmd_value);
		output_blcmd(fdblcmd,"cmd",tempbuf);

		break;

	    case MDC_COM_GONMAN:

		strcpy(stat_scanner_op,"Goniostat in Manual Mode");
		sprintf(tempbuf,"gon_manual %10.3f",mdccp->cmd_value);
		output_blcmd(fdblcmd,"cmd",tempbuf);

		break;

	    case MDC_COM_HOME:

		strcpy(stat_scanner_op,"Homing Goniostat Angles");
		sprintf(tempbuf,"home");
		output_blcmd(fdblcmd,"cmd",tempbuf);

		break;

	    case MDC_COM_COLL:

	    case MDC_COM_SNAP:

		read_bl_wavelength = 0;
#ifdef	X8C
		{
		  /* get the wavelength --JB 14-Jun-01 */
#include "../incl/issue_signal.h"
		     char *message[80];
		     static char *msgname = "CCD_SIG_GETWAVE";
		     float  fw;
		     int retval;
		     
		     fw = 0;
		     message[0] = NULL;
		     retval = issue_signal(msgname, message);
		     if (retval == SIG_OK)   /* Normal response */
		       {
			 if (strlen(message) != 0)
			   {
			     sscanf(message,"%f",&fw);
			     if ((fw < 0.5) || (fw > 5.0))
			       {
				 fprintf(stdout,"Crazy wavelength of %f A read but ignored.\n",fw);
				 read_bl_wavelength = 0;
			       }
			     else
			       {
				 stat_wavelength = fw;
				 fprintf(stdout,"INFO: Wavelength set to: %f A\n",stat_wavelength);
				 read_bl_wavelength = 1;
				 wavelength_read = fw;
			       }
			   }
			 else
			   {
			     fprintf(stderr,"Error-%s did not return a value.\n", msgname);
			   }
		       }
		     else if (retval == SIG_SYSERR)
		       {
			 fprintf(stderr,"Error in system call to %s \n", msgname);
		       }
		     else if (retval == SIG_CMDERR)
		       {
			 fprintf(stderr,"Error-%s gave error message  %s", msgname,  message);
		       }
		     else if (retval == SIG_NULLMSG)
		       {
			 fprintf(stderr,"Error-%s did not return OK\n", msgname);
		       }
		   }
#endif /* X8C */

                if(fddetcmd == -1 || fdxfcm == -1)
                  {
                        strcpy(tempbuf,"ERROR: ");
			sprintf(message[0]," MDC_COLL");
                        if(fddetcmd == -1)
			  {
			    strcat(tempbuf,"Detector process NOT connected.");
			    issue_signal("CCD_SIG_DET_DROPPED",message);
			  }
                        if(fdxfcm == -1)
			  {
			    strcat(tempbuf,"Transform process NOT connected.");
			    issue_signal("CCD_SIG_XFORM_DROPPED",message);
			  }
                        set_alert_msg(tempbuf);
			command_rejected = 1;
                        return;
                  }

		if(mdccp->cmd_col_osc_width == 0)
		{
			if(allow_stills == 0)
			{
				set_alert_msg("ERROR: A still (rotation width=0) is NOT allowed");
				command_rejected = 1;
				return;
			}
		}
		else
		{
			velocity = mdccp->cmd_col_osc_width / mdccp->cmd_col_time;
			if(velocity < min_velocity)
			{
				set_alert_msg("ERROR: velocity (time / width) too small for collect");
				command_rejected = 1;
				return;
			} 
			else
			if(velocity > max_velocity)
			{
				set_alert_msg("ERROR: velocity (time / width) too large for collect");
				command_rejected = 1;
				return;
			}
		}
		parse_file_name(mdccp->cmd_col_prefix,prefix_without_run,&runno);
		if(mdccp->cmd_col_restart_run == -1)
		  {
		    if(mdccp->cmd_col_mad_mode == 0)
		      {
			mdccp->cmd_col_mad_nwave = 1;
			if(read_bl_wavelength == 0 || mdccp->cmd_col_run_wave < 0)
				mdccp->cmd_col_mad_wavelengths[0] = stat_wavelength;
			else
				mdccp->cmd_col_mad_wavelengths[0] = wavelength_read;
		      }
		    mdccp->cmd_col_restart_run = runno;
		    mdccp->cmd_col_restart_image = mdccp->cmd_col_image_number;

		    generate_run_list(mdccp);
		  }
		fprintf(stdout,"ccd_dc_api_mad: restart_run: %d restart_image: %d\n", mdccp->cmd_col_restart_run,
								 mdccp->cmd_col_restart_image);
		stat_2theta = mdccp->cmd_col_lift;

		/*
		 *	Find the first image in the runs file.
		 */
		sprintf(tempfname,"%s/%s.runlist",mdccp->cmd_col_dir,mdccp->cmd_col_prefix);
		if(NULL == (fprun = fopen(tempfname,"r")))
		  {
		    fprintf(stderr,"ccd_dc_api: FATAL: Cannot open run file %s\n",tempfname);
		    fprintf(stderr,"            This file is NECESSARY for the program to run\n");
		    fprintf(stderr,"            and should have been generated previously\n");
		    fprintf(stderr,"            by this program.\n");
		    cleanexit(BAD_STATUS);
		  }

		/*
		 *	Generate the file name of the actual beginning image
		 *	(except the .img part).
		 */

		util_3digit(tbuf,mdccp->cmd_col_restart_image);
		sprintf(tempbuf,"%s_%d_%s",prefix_without_run,mdccp->cmd_col_restart_run,tbuf);
		fprintf(stderr,"ccd_dc_api_mad: looking for image %s as first image number\n",tempbuf);

		/*
		 *	Take this image name and read each line in
		 *	the runs file, one at a time, until this string is
		 *	matched.  When this occurs, we will have the necessary
		 *	angle, etc., parameters, for the image.  The logic
		 *	works weather restart or no.
		 */

		run_found = 0;
		while(NULL != fgets(read_file_line,sizeof (read_file_line), fprun))
		  if(NULL != (char *) strstr(read_file_line,tempbuf))
		    {
			run_found = 1;
			break;
		    }
		if(run_found == 0)
		  {
		    fprintf(stderr,"ccd_dc_api: Run %d, image %d NOT FOUND in current\n",
			mdccp->cmd_col_restart_run,mdccp->cmd_col_restart_image);
		    fprintf(stderr,"            Not performing this run.\n");
		    dc_abort = 1;
		    break;
		  }
		sscanf(read_file_line,"%s %f %f %f %f %f",read_file_name,&f1,&f2,&f3,&f4,&f5);
		parse_file_name(read_file_name,stat_prefix,&stat_image_number);
		mdccp->cmd_col_time = f1;
		if(mdccp->cmd_col_omegas != -9999.)
			mdccp->cmd_col_omegas = f3;
		if(mdccp->cmd_col_phis != -9999.)
			mdccp->cmd_col_phis = f4;
		if(mdccp->cmd_col_kappas != -9999.)
			mdccp->cmd_col_kappas = f5;
		mdccp->cmd_col_image_number = mdccp->cmd_col_restart_image;
		if(is_wavelength)
		  {
		    strcpy(stat_scanner_op,"setting_wavelength");
		    sprintf(tempbuf,"wavelength_move %7.5f",f2);
		    output_blcmd(fdblcmd,"cmd",tempbuf);
		    stat_wavelength = f2;
		  }
		else
		  {
		    if(fabs(f2 - stat_wavelength) > 0.001)
		      {
		        strcpy(stat_scanner_op,"setting_wavelength");
		        sprintf(tempbuf,"wavelength_move %7.5f",f2);
		        output_blcmd(fdblcmd,"cmd",tempbuf);
		        stat_wavelength = f2;
		      }
		  }
		if(mdccp->cmd_col_atten_run != -1)
		{
			if(1 || fabs(stat_attenuator - mdccp->cmd_col_atten_run) > .001)
			{
		    		strcpy(stat_scanner_op,"setting_attenuator");
		    		sprintf(tempbuf,"attenuator_move %7.5f",mdccp->cmd_col_atten_run);
		    		output_blcmd(fdblcmd,"cmd",tempbuf);
		    		stat_attenuator = mdccp->cmd_col_atten_run;
			}
		}

		if(mdccp->cmd_col_autoal_run == 1)
		{
                	strcpy(stat_scanner_op,"autoaligning");
                	sprintf(tempbuf,"autoalign 1");
                	output_blcmd(fdblcmd,"cmd",tempbuf);
		}

		if(mdccp->cmd_col_hslit_run != -1)
		{
		    		strcpy(stat_scanner_op,"setting_horiz_slit");
		    		sprintf(tempbuf,"hslit %7.5f",mdccp->cmd_col_hslit_run);
		    		output_blcmd(fdblcmd,"cmd",tempbuf);
		    		stat_hslit = mdccp->cmd_col_hslit_run;
		}

		if(mdccp->cmd_col_vslit_run != -1)
		{
		    		strcpy(stat_scanner_op,"setting_vert_slit");
		    		sprintf(tempbuf,"vslit %7.5f",mdccp->cmd_col_vslit_run);
		    		output_blcmd(fdblcmd,"cmd",tempbuf);
		    		stat_vslit = mdccp->cmd_col_vslit_run;
		}

		if (mdccp->cmd_no == MDC_COM_SNAP) {
 		   doing_snapshot = 1;
		}
	        else {
		   doing_snapshot = 0;

		   // 8BM run CONSOLE housekeeping
		   if (bm8_mod) {

		     // make sure current client-server connection to CSERVER working.
		     // if not kill old connection and reattach
		     // if reattachment fails barf!

                      bline_ret = output_blcmd(fdblcmd,"cmd", "check_cons"); 
		      if (bline_ret == 0) {
			 set_alert_msg("Cannot re-attach to CONSOLE RPC-server/8BM");
			 dc_abort = 1;
			 break;
		      }

		      // if DCM4 note current CONSOLE script chain to it
                      bline_ret = output_blcmd(fdblcmd,"cmd", "current_script"); 
		   }
                }

		need_new_dk = 0;

		phi_speed_used = phi_top_speed;
		stat_time = mdccp->cmd_col_time;

		if(mdccp->cmd_col_omegas != -9999.)
			stat_start_omega = mdccp->cmd_col_omegas;
		if(mdccp->cmd_col_phis != -9999.)
			stat_start_phi = mdccp->cmd_col_phis;
		if(mdccp->cmd_col_kappas != -9999.)
			stat_start_kappa = mdccp->cmd_col_kappas;

		stat_axis = mdccp->cmd_col_axis;
		phi_value_saved = stat_start_phi;
		omega_value_saved = stat_start_omega;
		stat_omega = stat_start_omega;
		stat_phi = stat_start_phi;
		stat_kappa = stat_start_kappa;

		stat_osc_width = mdccp->cmd_col_osc_width;
		stat_n_images = mdccp->cmd_col_n_images;
		stat_n_passes = mdccp->cmd_col_n_passes;
		stat_image_number = mdccp->cmd_col_image_number;

		stat_compress = mdccp->cmd_col_compress;
		stat_anom = mdccp->cmd_col_anom;
		stat_wedge = mdccp->cmd_col_wedge;
		if(mdccp->cmd_col_dzratio != -1)
			stat_dzratio = mdccp->cmd_col_dzratio;
		if(mdccp->cmd_col_dkinterval != -1)
			dark_current_interval = mdccp->cmd_col_dkinterval;
		if(mdccp->cmd_col_rep_dark != -1)
			repeat_dark_current = mdccp->cmd_col_rep_dark;
		if(mdccp->cmd_col_dk_before != -1)
			dk_before_run = mdccp->cmd_col_dk_before;
		if(mdccp->cmd_col_outfile_type != -1)
			outfile_type = mdccp->cmd_col_outfile_type;
		if(mdccp->cmd_col_no_transform != -1)
		  {
			no_transform = mdccp->cmd_col_no_transform;
			raw_ccd_image = no_transform;
		  }
		if(mdccp->cmd_col_output_raws != -1)
			output_raws = mdccp->cmd_col_output_raws;
		if(stat_n_images > stat_wedge)
		    wedge_size = stat_wedge;
		  else
		    wedge_size = stat_n_images;

		if(stat_n_passes == 2)
			double_exp_flag = 1;
		  else
			double_exp_flag = 0;
		strcpy(stat_dir,mdccp->cmd_col_dir);

		if(0)	/* DEBUG 4/26/99: SUPERCEEDED BY MAD CODE HANDLING OF NAMES */
		  strcpy(stat_prefix,mdccp->cmd_col_prefix);

		if(stat_adc != mdccp->cmd_col_adc || stat_bin != mdccp->cmd_col_bin)
		    need_new_dk = 1;
		if(dk_before_run)
		    need_new_dk = 1;
		if(need_new_dk)
		    time((time_t *) &dark_current_time);

		stat_adc = mdccp->cmd_col_adc;
		stat_bin = mdccp->cmd_col_bin;

		if(stat_anom)	/* for anomalous, we need to figure out the goniostat type */
		  {
		    if(is_kappa)
		      {
		        goniostat_type = 2;
			wedge_kappa = stat_start_kappa;
			wedge_omega = stat_start_omega;
			wedge_phi =   stat_start_phi;
			kappa_init(kappa_const);
		      }
		     else
		      {
		        goniostat_type = 0;
			wedge_phi =   stat_start_phi;
		      }
		    wedge_count = wedge_size;
		    wedge_side = 0;
		    j = strlen(stat_prefix);
		    for(i = j - 1; i >= 0; i--)
		      if(stat_prefix[i] == '_')
			break;
		    wedge_run = atoi(&stat_prefix[i+1]);
		    wedge_imno = stat_image_number;
		    for(j = 0; j < i; j++)
		      wedge_prefix[j] = stat_prefix[j];
		    wedge_prefix[j] = '\0';
		  }

		if(doing_snapshot == 0)
		  {
		    beam_xcen = mdccp->cmd_col_xcen;
		    beam_ycen = mdccp->cmd_col_ycen;
		  }
		totimg = stat_n_images;
		totpass = stat_n_passes;
		stat_mode = mdccp->cmd_col_mode;
		if(stat_mode == 1)	/* dose */
			stat_time = stat_dose_step;

		if(stat_n_passes == 2)
		  {
		    double_exp_flag = 1;
		    double_exp_ctr = 2;
		  }
		 else
		  {
		    double_exp_flag = 0;
		    double_exp_ctr = 1;
		  }

		if(mdccp->cmd_no == MDC_COM_COLL)
		  {
		    fprintf(stdout,"ccd_dc_hw: doing collect, stat_time: %f current_darkcurrent_time: %f\n",stat_time, current_darkcurrent_time);
		    if(mdccp->cmd_col_newdark == 1 || need_new_dk == 1 || stat_time != current_darkcurrent_time)
		      {
		        fprintf(stdout,"ccd_dc_hw: setting up to do a new darkcurrent\n");
			doing_dark_current = 1;
			doing_second_dk = 0;
			double_exp_ctr = 2;
			current_darkcurrent_time = stat_time;
		      }
		     else
			doing_dark_current = 0;
		    if(repeat_dark_current)
		      {
			fprintf(stdout,"ccd_dc_api: informational: dark currents will be repeated\n");
			fprintf(stdout,"ccd_dc_api:                every %d seconds.\n",dark_current_interval);
		      }
		  }
		 else	/* snapshot with no recalc'd dark current */
		  {
		    doing_second_dk = 0;
		    doing_dark_current = 0;
		  }

		/*
		 *	Always move/set the distance for SNAP and COLLECT.
		 */

		if(is_distance)
		  {
			strcpy(stat_scanner_op,"moving distance");
			sprintf(tempbuf,"distance_move %10.2f",mdccp->cmd_col_dist);
			output_blcmd(fdblcmd,"cmd",tempbuf);
		  }
		else
		  {
			strcpy(stat_scanner_op,"setting distance");
			sprintf(tempbuf,"distance_set %10.2f",mdccp->cmd_col_dist);
			output_blcmd(fdblcmd,"cmd",tempbuf);
		  }
/*
 *	This code was put into the ALS.  Removed at SPring8:
 *
 *		while(fabs(stat_dist - mdccp->cmd_col_dist) > 0.01)
 *			pause();
 */
		stat_dist = mdccp->cmd_col_dist;
		if(is_2theta && mdccp->cmd_col_lift != -9999.)
		  {
			if(0)
			{
			  fprintf(stdout,"ccd_dc_api: Would move lift before run start\n");
			}
			else
			{
			strcpy(stat_scanner_op,"moving 2theta");
			sprintf(tempbuf,"lift_move %10.3f",mdccp->cmd_col_lift);
			output_blcmd(fdblcmd,"cmd",tempbuf);
			}
		  }
		stat_2theta = mdccp->cmd_col_lift;

		/*
		 *	For the three goniostat angles, move them if they
		 *	exist for COLLECT.  SNAP is handled below.
		 */

		if(is_phi && mdccp->cmd_col_phis != -9999.)
		  {
			if(0)
			{
			  fprintf(stdout,"ccd_dc_api: Would move phi before run start\n");
			}
			else
			{
			strcpy(stat_scanner_op,"moving phi");
			sprintf(tempbuf,"phi_move %10.3f",mdccp->cmd_col_phis);
			output_blcmd(fdblcmd,"cmd",tempbuf);
			}
		  }

		if(is_omega && mdccp->cmd_col_omegas != -9999.)
		  {
		    if(0)
		    {
		      fprintf(stdout,"ccd_dc_api: Would move omega before run start\n");
		    }
		    else
		    {
		    strcpy(stat_scanner_op,"moving omega");
		    sprintf(tempbuf,"omega_move %10.3f",mdccp->cmd_col_omegas);
		    output_blcmd(fdblcmd,"cmd",tempbuf);
		    }
		  }
		if(is_kappa && mdccp->cmd_col_kappas != -9999.)
		  {
		    if(0)
		    {
		      fprintf(stdout,"ccd_dc_api: Would move kappa before run start\n");
		    }
		    else
		    {
		    strcpy(stat_scanner_op,"moving kappa");
		    sprintf(tempbuf,"kappa_move %10.3f",mdccp->cmd_col_kappas);
		    output_blcmd(fdblcmd,"cmd",tempbuf);
		    }
		  }
		
		/*
		 *	For a SNAP, ONLY move the one angle (omega or phi)
		 *	which is in motion (stat_axis).  If the goniostat has
		 *	an omega, ALL snapshots are in omega, else in phi.
		 */
		
		if(doing_snapshot == 1)
		  {
		    if(stat_axis == 1)
		      {
			strcpy(stat_scanner_op,"moving phi");
			sprintf(tempbuf,"phi_move %10.3f",mdccp->cmd_col_phis);
			output_blcmd(fdblcmd,"cmd",tempbuf);
		      }
		     else
		      {
		        strcpy(stat_scanner_op,"moving omega");
		        sprintf(tempbuf,"omega_move %10.3f",mdccp->cmd_col_omegas);
		        output_blcmd(fdblcmd,"cmd",tempbuf);
		      }
		  }

		dc_stop = 0;

		if(mdccp->cmd_col_blcmd[0] != '\0')
		  {
		    bline_ret = output_blcmd(fdblcmd,"before",mdccp->cmd_col_blcmd);
		    switch (bline_ret) {
		      case CCD_BL_NOTCONNECTED:
		      case CCD_BL_DISCONNECTED:
			dc_stop = 1;
			sprintf(message[0]," CCD_BL_NOTCONNECTED");
			issue_signal("CCD_BL_DROPPED",message);
	                set_alert_msg("ERROR: Beamline control not connected.");
		  	break;
		      case CCD_BL_FATAL:
			dc_stop = 1;
			if(pf_mod)
			{
				sprintf(tempbuf,"lockout_external 0");
				output_blcmd(fdblcmd,"cmd",tempbuf);
			}
		        break;
	              default:
		  	break;
		      }
		  }
		if(dc_stop == 1)
		  {
			dc_abort = 1;
			break;
		  }

		if(pf_mod)
		{
			sprintf(tempbuf,"lockout_external 1");
			output_blcmd(fdblcmd,"cmd",tempbuf);
		}

                //time(&now);
	        //fprintf(stdout,"ccd_dc_api: pitch_tune_delta: %d pitch_tune_last: %d now: %d\n",
                //        pitch_tune_delta,pitch_tune_last,now);

		if(pitch_tune_delta)
		{
			time(&now);

			if ((now - pitch_tune_last) > pitch_tune_delta) {
			   bline_ret = output_blcmd(fdblcmd,"cmd", "pitch_tune");
			   pitch_tune_last = now;
			   usleep(500000);
			}
		}
		collect_frame();
		if(doing_dark_current == 0)
		  {
		    if(stat_axis == 1)
		        stat_phi += stat_osc_width;
		     else
		        stat_omega += stat_osc_width;
		  }

		dcop = DCOP_COLLECT;

		tick = stat_time * 1000;
		tick_set();
		units = tick;
		decrement = 1000 * (1. / dt_stat);
		dc_abort = 0;
		dc_in_progress = 1;

		break;
	  }
  }

/*
 *	This routine monitors the progress of commands issued by
 *	ccd_hw_start.  In general, most functions are taken care
 *	of by other processes; the only complex commands are scan
 *	and collect.
 */

extern	char	det_reply[2048];

int	ccd_hw_progress(mdccp)
mdc_command	*mdccp;
  {
	char	tempbuf[2048],tbuf[2048],u3dig[4];
	char	prefix_used[20],xform_out_name[256];
	int	done,detret;
	int	timediff,new_time;
	int	bline_ret,i;
	float	kappa_angs[3],euler_angs[3];
	char	*ztime();
	time_t	now;
	char *message[80];

	done = 0;

        if(mdccp->cmd_no != MDC_COM_STARTUP)
          {
            if(fdblcmd == -1)
	      {
                done = 1;
                return(done);
	      }
          }

	switch(mdccp->cmd_no)
	  {
	    case MDC_COM_STARTUP:
	    case MDC_COM_INIT:
	    case MDC_COM_ERASE:
	    case MDC_COM_DSET:
	    case MDC_COM_PSET:
	    case MDC_COM_LSET:
	    case MDC_COM_WSET:
	    case MDC_COM_CONFIG:
	    case MDC_COM_SHUT:
	    case MDC_COM_DMOVE:
	    case MDC_COM_PMOVE:
	    case MDC_COM_PMOVEREL:
	    case MDC_COM_LMOVE:
	    case MDC_COM_WMOVE:
	    case MDC_COM_OMOVE:
	    case MDC_COM_OSET:
	    case MDC_COM_KMOVE:
	    case MDC_COM_KSET:
	    case MDC_COM_GONMAN:
	    case MDC_COM_HOME:
	    case MDC_COM_AMOVE:
	    case MDC_COM_AUTOALIGN:
            case MDC_COM_XL_HS_MOVE:
            case MDC_COM_XL_VS_MOVE:
            case MDC_COM_XL_UP_HHS_MOVE:
            case MDC_COM_XL_UP_VHS_MOVE:
            case MDC_COM_XL_DN_HHS_MOVE:
            case MDC_COM_XL_DN_VHS_MOVE:


		done = 1;
		break;

	    case MDC_COM_SCAN:
	    case MDC_COM_COLL:
	    case MDC_COM_SNAP:
                if(fddetcmd == -1 || fdxfcm == -1)
                  {
                    done = 1;
                    return(done);
                  }
		if(dc_abort)
		  {
		    done = 1;
		    dc_abort = 0;
		    break;
		  }

		detret = output_detcmd(fddetcmd,"stop\n",NULL,0);

		if(strip_ave)
		  {
			output_detcmd(fddetcmd,"getparam\nstrip_ave\n",NULL,0);
			if(NULL == (char *) strstr(det_reply,"OK"))
			    n_strip_ave = 0;
			  else
			    {
				n_strip_ave = sscanf(&det_reply[3],"%f %f %f %f",
					&strip_ave_vals[0],&strip_ave_vals[1],
					&strip_ave_vals[2],&strip_ave_vals[3]);
			    }
			fprintf(stdout,"output_detcmd: STRIPS        at %s: ",ztime());
			for(i = 0; i < n_strip_ave; i++)
			  fprintf(stdout,"%.3f ",strip_ave_vals[i]);
			fprintf(stdout,"\n");
			fflush(stdout);
		  }

		if(detret == CCD_DET_RETRY)
		  {
                    if (dc_stop == 1) {
		      done = 1;
		      dc_stop = 0;
		      break;
                    }
		    if(doing_dark_current == 0)
		      {
		        if(stat_axis == 1)
		          sprintf(tempbuf,"phi_move %10.3f",phi_value_saved);
		        else
		          sprintf(tempbuf,"omega_move %10.3f",omega_value_saved);
		        output_blcmd(fdblcmd,"cmd",tempbuf);
		      }
		    collect_frame();
		    if(doing_dark_current == 0)
		      {
		        if(stat_axis == 1)
		            stat_phi += stat_osc_width;
		         else
		            stat_omega += stat_osc_width;
		      }
		    break;
		  }
                else if (detret == CCD_DET_NOTCONNECTED) {
                  dc_stop = 1;
		  sprintf(message[0]," ccd_hw_progress");
		  issue_signal("CCD_SIG_DET_DROPPED",message);
                  set_alert_msg("ERROR: Detector control not connected.");
                }
		else if (detret == CCD_DET_FATAL){
		  dc_stop = 1;
		}

		send_copy_command();

	        if(gl_blret == CCD_BL_RETRY)
		  {
                    if (dc_stop == 1) 
		      {
		        done = 1;
		        dc_stop = 0;
		        break;
                      }

		    /*
		     *	This logic assumes that the goniostat device (Mar 300 base comes to mind)
		     *	is actually "continuing" the exposure through the requested time interval.
		     *	Hence we need to wait for the "rest" of the exposure to finish before actually
		     *	continuing with the steps below.
		     */

	            strcpy(stat_scanner_op,"Idling_rest_of_short_exp");

#ifdef X8C
		    short_exposure_stall(exposure_short_by,fdblcmd);
#endif /* X8C */

		    if(stat_axis == 1)
		      sprintf(tempbuf,"phi_move %10.3f",phi_value_saved);
		     else
		      sprintf(tempbuf,"omega_move %10.3f",omega_value_saved);
		    output_blcmd(fdblcmd,"cmd",tempbuf);
		    collect_frame();
		    if(stat_axis == 1)
		        stat_phi += stat_osc_width;
		     else
		        stat_omega += stat_osc_width;
		    break;
		  }
		if(dc_stop == 1)
		  {
		    output_detcmd(fddetcmd,"flush\n",NULL,0);
		    done = 1;
		    dc_stop = 0;
		    fprintf(stdout,"ccd_dc_api: User requested STOP.  Exposures terminating.\n");
		    if(doing_dark_current && double_exp_ctr == 2)
		    	current_darkcurrent_time = 0;
		    break;
		  }

		if(doing_dark_current)
		  {
		    double_exp_ctr--;
		    if(double_exp_ctr > 0)
			collect_frame();
		     else if(doing_second_dk || stat_dzratio == 1.0)
		      {
			stat_time /= stat_dzratio;
			doing_dark_current = 0;
			if(double_exp_flag)
			    double_exp_ctr = 2;
			  else
			    double_exp_ctr = 1;
			collect_frame();
		      }
		      else if(stat_dzratio != 1.0)
			{
			  stat_time *= stat_dzratio;
			  double_exp_ctr = 2;
			  doing_second_dk = 1;
			  collect_frame();
			}
		    break;
		  }

		if(mdccp->cmd_col_blcmd[0] != '\0')
		  {
		    bline_ret = output_blcmd(fdblcmd,"during",mdccp->cmd_col_blcmd);
		    switch (bline_ret) {
		      case CCD_BL_FATAL:
			dc_stop = 1;
		        break;
		      case CCD_BL_NOTCONNECTED:
		      case CCD_BL_DISCONNECTED:
			dc_stop = 1;
			sprintf(message[0]," after scan");
			issue_signal("CCD_BL_DROPPED",message);
	                set_alert_msg("ERROR: Beamline control not connected.");
		  	break;
	              default:
		  	break;
		      }
		  }
		if(dc_stop == 1)
		  {
			dc_abort = 1;
		        output_detcmd(fddetcmd,"flush\n",NULL,0);
		        done = 1;
		    	dc_stop = 0;
			break;
		  }
		double_exp_ctr--;
		if(double_exp_ctr == 0)
		  {
		    stat_time = mdccp->cmd_col_time;
		    if(double_exp_flag == 1)
			double_exp_ctr = 2;
		     else
			double_exp_ctr = 1;
		    stat_image_number++;
		    if(stat_axis == 1)
		      {
		        phi_value_saved += mdccp->cmd_col_osc_width;
			if(constrain_phi != 180) {
			if(phi_value_saved >= 360.)
				phi_value_saved -= 360.;
			} else {
			if(phi_value_saved >= 180.)
				phi_value_saved -= 180.;
			}

		      }
		    else
		      {
		        omega_value_saved += mdccp->cmd_col_osc_width;
			if(constrain_omega != 180) {
			if(omega_value_saved >= 360.)
				omega_value_saved -= 360.;
			} else {
			if(omega_value_saved >= 180.)
				omega_value_saved -= 180.;
			}
		      }
		    if(repeat_dark_current)
		      {
			time((time_t *) &new_time);
			timediff = new_time - dark_current_time;
			if(timediff > dark_current_interval)
			  {
				doing_dark_current = 1;
				doing_second_dk = 0;
				double_exp_ctr = 2;
				dark_current_time = new_time;
			  }
		      }
		    get_next_image_from_runfile(mdccp);
		  }
		 else
		  {
		    stat_time = mdccp->cmd_col_time * stat_dzratio;
		    if(stat_axis == 1)
		      sprintf(tempbuf,"phi_move %10.3f",phi_value_saved);
		    else
		      sprintf(tempbuf,"omega_move %10.3f",omega_value_saved);
		    output_blcmd(fdblcmd,"cmd",tempbuf);
		  }

		if(totimg == 0 || dc_stop == 1)
		  {
			output_detcmd(fddetcmd,"flush\n",NULL,0);
			done = 1;
			dc_stop = 0;
			if(mdccp->cmd_col_blcmd[0] != '\0')
			  {
			    bline_ret = output_blcmd(fdblcmd,"after",mdccp->cmd_col_blcmd);
			    switch (bline_ret) {
			      case CCD_BL_FATAL:
				dc_stop = 1;
			        break;
			      case CCD_BL_NOTCONNECTED:
			      case CCD_BL_DISCONNECTED:
				dc_stop = 1;
				sprintf(message[0]," ccd_dc_hw 3");
				issue_signal("CCD_SIG_BL_DROPPED",message);
		                set_alert_msg("ERROR: Beamline control not connected.");
			  	break;
		              default:
			  	break;
			      }
			  }
			if(dc_stop == 1)
			  {
			        done = 1;
			    	dc_stop = 0;
				break;
			  }
			break;
		  }

		if(pitch_tune_delta)
		{
			time(&now);

			if ((now - pitch_tune_last) > pitch_tune_delta) {
			   bline_ret = output_blcmd(fdblcmd,"cmd", "pitch_tune");
			   pitch_tune_last = now;
			   usleep(500000);
			}
		}
		collect_frame();
		if(doing_dark_current == 0)
		  {
		    if(stat_axis == 1)
		        stat_phi += stat_osc_width;
		     else
		        stat_omega += stat_osc_width;
		  }

		tick_set();
		tick = stat_time * 1000;
		units = tick;
		decrement = 1000 * (1. / dt_stat);
		totpass = stat_n_passes;

		break;
	  }

	if(done == 1)
	  {
		strcpy(stat_scanner_msg,"");
		strcpy(stat_scanner_op,"");
		strcpy(stat_scanner_control,"idle");
		dc_in_progress = 0;
		if(pf_mod && (mdccp->cmd_no == MDC_COM_COLL || (mdccp->cmd_no == MDC_COM_SNAP)))
		{
			sprintf(tempbuf,"lockout_external 0");
			output_blcmd(fdblcmd,"cmd",tempbuf);
		}
	  }
	return (done);
  }

ccd_hw_initial_status()
  {
	stat_start_phi = 0.;
	stat_start_omega = 0.;
	stat_start_kappa = 0.;
	stat_axis = 1;
	stat_osc_width = 1.0;
	stat_n_images = 1;
	stat_n_passes = 1;
	stat_n_ccd_updates = 0;
	stat_time = 30;
	stat_dir[0] = '\0';
	stat_fname[0] = '\0';
	strcpy(stat_scanner_op,"none");
	stat_scanner_msg[0] = '\0';
	strcpy(stat_scanner_control,"idle");
	strcpy(stat_scanner_shutter,"closed");
  }

]0;capel@8bmserver1:/usr/local/ccd_dist/src_std/ccd_dc_api_mad_x8c[root@8bmserver1 ccd_dc_api_mad_x8c]# exit
exit
]0;capel@8bmserver1:/usr/local/ccd_dist[capel@8bmserver1 ccd_dist]$ exit
logout
[H[2Jcn sun1:2>exit
logout
[H[2JConnection closed by foreign host.
[ccdsys@6accd ccd_dc_api_mad_x8c]$ ls
Makefile@	    Mkfile	    ccd_dc_det.c~	ccd_dc_hwsim.c	     ccd_dc_misc.c~    mult_commands
Makefile.alpha	    added_commands  ccd_dc_ext.h	ccd_dc_input.c	     ccd_dc_seq.c      net_client.c
Makefile.linux	    bzero.c	    ccd_dc_glob.c	ccd_dc_input.c.0     ccd_dc_seq.c.0    parse_file_name
Makefile.sgi	    ccd_dc_args.c   ccd_dc_heartbeat.c	ccd_dc_input.c~      ccd_dc_sio.c      parse_file_name.c
Makefile.sun	    ccd_dc_args.c~  ccd_dc_hw.c		ccd_dc_input_orig.c  ccd_dc_strstat.c  test_seq.c
Makefile_x8c.alpha  ccd_dc_bl.c     ccd_dc_hw.c.0	ccd_dc_main.c	     ccd_server.c      test_seq_first.c
Makefile_x8c.linux  ccd_dc_bl.c~    ccd_dc_hw.c.1	ccd_dc_main.c~	     ccd_server.c~     util_misc.c
Makefile_x8c.sgi    ccd_dc_defs.h   ccd_dc_hw.c.old	ccd_dc_misc.c	     get_attenuator.c  vms_select.h
Makefile_x8c.sun    ccd_dc_det.c    ccd_dc_hw.c~	ccd_dc_misc.c.0      malcolm
[ccdsys@6accd ccd_dc_api_mad_x8c]$ vi malcolm
[>c7[?47h[?1h=[1;28r[H[2J[28;1H"malcolm" [noeol] 4371L, 159744C[1;1HScript started on Thu Sep 26 13:14:13 2002
[ccdsys@6accd ccd_dc_api_mad_x8c]$ telnet 154.^H ^H^H ^H^H ^H64.54.152.287^H ^H^H ^H^H ^H80^M
Trying 164.54.152.80...^M^M
^M
[ccdsys@6accd ccd_dc_api_mad_x8c]$ telnet chem.ucd^H ^Hsd.edu^M
Trying 132.239.68.1...^M^M
Connected to chem.ucsd.edu.^M^M
Escape character is '^]'.^M^M
^M
^M
SunOS 5.8^M
^M^M
^Mlogin: cn^M
Password: ^M
Last login: Wed Sep 25 20:45:32 from 130.87.176.110^M
^[>^[[1;3;4;5;6l^[[?7h^[[m^[[r^[[2J^[[H@^M^[[H^[[2JSun Microsystems Inc.      SunOS 5.8[7CGeneric February 20 [17;1H00^M
cn sun1:1>ssh -l capel ^[[13D^[[Kssh capel@164.54.152.80^M^M
Host key not found from database.^M^M
Key fingerprint:^M^M
xofih-kazip-pudeh-mumuf-mipas-kysup-pugec-rogop-rysyl-pevev-rexyx^M^M
You can get a public key's fingerprint by running^M^M
% ssh-keygen -F publickey.pub^M^M
on the keyfile.^M^M
Are you sure you want to continue connecting (yes/no)? ^[[?1h^[=^[[@y^[[2@es^[[?1l^[>^M^M
Host key saved to /home/research/xuong/cn/.ssh2/hostkeys/key_22_164.54.152.80.pub^M^M
host key for 164.54.152.80, accepted by cn Wed Sep 25 2002 20:01:18 -0800^M^M[1;1H[28;1H[K[28;1H:1,$s/^^M//g4392 substitutions on 4369 lines[1;1H        stat_start_phi = 0.;[1;30H[K[2;1H        stat_start_omega = 0.;[2;31H[K[3;1H        stat_start_kappa = 0.;
        stat_axis = 1;
        stat_osc_width = 1.0;[5;30H[K[6;1H        stat_n_images = 1;
        stat_n_passes = 1;[7;27H[K[8;1H        stat_n_ccd_updates = 0;
        stat_time = 30;
        stat_dir[0] = '\0';
        stat_fname[0] = '\0';
        strcpy(stat_scanner_op,"none");
        stat_scanner_msg[0] = '\0';
        strcpy(stat_scanner_control,"idle");
        strcpy(stat_scanner_shutter,"closed");[15;47H[K[16;1H  }[16;4H[K[17;1H[K[18;1H^[]0;capel@8bmserver1:/usr/local/ccd_dist/src_std/ccd_dc_api_mad_x8c^G[root@8bmserver1 ccd_dc_api_mad_x8c]# exit
exi[19;6H[K[20;1H^[]0;capel@8bmserver1:/usr/local/ccd_dist^G[capel@8bmserver1 ccd_dist]$ exit
logout[21;7H[K[22;1H^[[H^[[2Jcn sun1:2>exit[22;24H[K[23;1Hlogout[23;7H[K[24;1H^[[H^[[2JConnection closed by foreign host.
[ccdsys@6accd ccd_dc_api_mad_x8c]$ ls[25;38H[K[26;1HMakefile@           Mkfile          ccd_dc_det.c~       ccd_dc_hwsim.c       ccd_dc_misc.c~    mult_commands
Makefile.alpha      added_commands  ccd_dc_ext.h        ccd_dc_input.c       ccd_dc_seq[26;1H[107C[H[2J[1;1HScript started on Thu Sep 26 13:14:13 2002
[ccdsys@6accd ccd_dc_api_mad_x8c]$ telnet 154.^H ^H^H ^H^H ^H64.54.152.287^H ^H^H ^H^H ^H80
Trying 164.54.152.80...

[ccdsys@6accd ccd_dc_api_mad_x8c]$ telnet chem.ucd^H ^Hsd.edu
Trying 132.239.68.1...
Connected to chem.ucsd.edu.
Escape character is '^]'.


SunOS 5.8

login: cn
Password:
Last login: Wed Sep 25 20:45:32 from 130.87.176.110
^[>^[[1;3;4;5;6l^[[?7h^[[m^[[r^[[2J^[[H@^[[H^[[2JSun Microsystems Inc.      SunOS 5.8[7CGeneric February 2000[17;1Hcn sun1:1>ssh -l capel ^[[13D^[[Kssh capel@164.54.152.80
Host key not found from database.
Key fingerprint:
xofih-kazip-pudeh-mumuf-mipas-kysup-pugec-rogop-rysyl-pevev-rexyx
You can get a public key's fingerprint by running
% ssh-keygen -F publickey.pub
on the keyfile.
Are you sure you want to continue connecting (yes/no)? ^[[?1h^[=^[[@y^[[2@es^[[?1l^[>
Host key saved to /home/research/xuong/cn/.ssh2/hostkeys/key_22_164.54.152.80.pub
host key for 164.54.152.80, accepted by cn Wed Sep 25 2002 20:01:18 -0800
capel's password:[1;1H[H[2J[1;1Hhost key for 164.54.152.80, accepted by cn Wed Sep 25 2002 20:01:18 -0800
capel's password:
capel's password:
Authentication successful.
Last login: Tue Aug 20 14:40:16 2002 from exec2bm
^[]0;capel@8bmserver1:~^G[capel@8bmserver1 capel]$ cd /usr/local/ccd_dist
^[]0;capel@8bmserver1:/usr/local/ccd_dist^G[capel@8bmserver1 ccd_dist]$ ls
^[[00m^[[01;34mbin^[[00m[37C^[[00mdiagnostic.log^[[00m  ^[[01;34mLOGIN_files^[[0 [9;1H0m  ^[[01;34msrc_bls^[[00m      ^[[01;31msrc.tar^[[00m[13C^[[01;34mtmp^[[00m
^[[00mccd_xform.log^[[00m[27C^[[00mENVIRON^[[00m[9C^[[00mRUN_315^[[00m      ^[[01;31 [11;1Hmsrc_bls.tar^[[00m  ^[[01;34mtables_904_swbin^[[00m
^[[00mdet_api_8bmserver1.imm.aps.anl.gov.log^[[00m  ^[[01;34mlib^[[00m[13C^[[01;34msaved_tars^[[00m   ^[ [13;1H[01;34msrc_std^[[00m      ^[[01;34mtables_api_904^[[00m
^[[00mdet_api_8bmserver2.imm.aps.anl.gov.log^[[00m  ^[[01;31mlib.tar^[[00m[9C^[[01;34msrc^[[00m[10C^[ [15;1H[01;31msrc_std.tar^[[00m  ^[[01;34mtables_api_904_sim^[[00m
^[[m^[]0;capel@8bmserver1:/usr/local/ccd_dist^G[capel@8bmserver1 ccd_dist]$ ls -l
^[[00mtotal 147536
drwxr-xr-x    8 8bmuser  8bmuser      4096 Dec  6  2001 ^[[01;34mbin^[[00m
-rw-r--r--    1 8bmuser  8bmuser[9C0 Aug 22 11:03 ^[[00mccd_xform.log^[[00m
-rw-r--r--    1 root     root[10C867 Aug 22 11:02 ^[[00mdet_api_8bmserver1.imm.aps.anl.gov.log^[[00m
-rw-r--r--    1 8bmuser  8bmuser[7C867 Apr 24 19:22 ^[[00mdet_api_8bmserver2.imm.aps.anl.gov.log^[[00m
-rw-r--r--    1 8bmuser  8bmuser[9C0 Aug 22 11:02 ^[[00mdiagnostic.log^[[00m
-rw-r--r--    1 8bmuser  8bmuser[7C100 Feb 15  2002 ^[[00mENVIRON^[[00m
drwx------    6 8bmuser  8bmuser      4096 Feb  7  1998 ^[[01;34mlib^[[00m
-rw-r--r--    1 root     root     13035520 Jul 24 18:40 ^[[01;31mlib.tar^[[00m
drwxr-xr-x    3 8bmuser  8bmuser      4096 Jul 16 18:56 ^[[01;34mLOGIN_files^[[00m
-rw-r--r--    1 8bmuser  8bmuser[7C672 Feb 15  2002 ^[[00mRUN_315^[[00m[1;1H[H[2J[1;1Hdrwxr-xr-x    3 8bmuser  8bmuser      4096 Jul 16 18:56 ^[[01;34mLOGIN_files^[[00m
-rw-r--r--    1 8bmuser  8bmuser[7C672 Feb 15  2002 ^[[00mRUN_315^[[00m
drwx------    4 8bmuser  8bmuser      4096 Feb 14  2002 ^[[01;34msaved_tars^[[00m
drwxr-xr-x    5 root     root[9C4096 May 20 16:38 ^[[01;34msrc^[[00m
drwx------   53 8bmuser  8bmuser      4096 Apr 25 16:24 ^[[01;34msrc_bls^[[00m
-rw-r--r--    1 root     root     19609600 Jul 24 18:21 ^[[01;31msrc_bls.tar^[[00m
drwx------  159 8bmuser  8bmuser      4096 Jun 13 15:22 ^[[01;34msrc_std^[[00m
-rw-r--r--    1 root     root     106096640 Jul 24 18:32 ^[[01;31msrc_std.tar^[[00m
-rw-r--r--    1 root     root     12093440 Jul 24 18:40 ^[[01;31msrc.tar^[[00m
drwxrwxrwx    3 8bmuser  8bmuser      4096 Feb 27  2002 ^[[01;34mtables_904_swbin^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Aug 13 09:15 ^[[01;34mtables_api_904^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Feb 27  2002 ^[[01;34mtables_api_904_sim^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Apr  9  1998 ^[[01;34mtmp^[[00m
^[[m^[]0;capel@8bmserver1:/usr/local/ccd_dist^G[capel@8bmserver1 ccd_dist]$ su
Password:
^[]0;capel@8bmserver1:/usr/local/ccd_dist^G[root@8bmserver1 ccd_dist]# rm *.tar
rm: remove `lib.tar'? y
rm: remove `src_bls.tar'? y
rm: remove `src_std.tar'? y
rm: remove `src.tar'? y
^[]0;capel@8bmserver1:/usr/local/ccd_dist^G[root@8bmserver1 ccd_dist]# ls
^[[00m^[[01;34mbin^[[00m[37C^[[00mdiagnostic.log^[[00m  ^[[00mRUN_315^[[00m      [23;1H^[[01;34msrc_std^[[00m[13C^[[01;34mtmp^[[00m
^[[00mccd_xform.log^[[00m[27C^[[00mENVIRON^[[00m[9C^[[01;34msaved_tars^[[00m  ^[[01; [25;1H34mtables_904_swbin^[[00m
^[[00mdet_api_8bmserver1.imm.aps.anl.gov.log^[[00m  ^[[01;34mlib^[[00m[13C^[[01;34msrc^[[00m[9C^[[ [27;1H01;34mtables_api_904^[[00m[1;1H[1;27r[1;1H[23M[1;28r[5;1H^[[00mdet_api_8bmserver2.imm.aps.anl.gov.log^[[00m  ^[[01;34mLOGIN_files^[[00m     ^[[01;34msrc_bls^[[00m     ^[[ [6;1H01;34mtables_api_904_sim^[[00m
^[[m^[]0;capel@8bmserver1:/usr/local/ccd_dist^G[root@8bmserver1 ccd_dist]# ls -l
^[[00mtotal 60
drwxr-xr-x    8 8bmuser  8bmuser      4096 Dec  6  2001 ^[[01;34mbin^[[00m
-rw-r--r--    1 8bmuser  8bmuser[9C0 Aug 22 11:03 ^[[00mccd_xform.log^[[00m
-rw-r--r--    1 root     root[10C867 Aug 22 11:02 ^[[00mdet_api_8bmserver1.imm.aps.anl.gov.log^[[00m
-rw-r--r--    1 8bmuser  8bmuser[7C867 Apr 24 19:22 ^[[00mdet_api_8bmserver2.imm.aps.anl.gov.log^[[00m
-rw-r--r--    1 8bmuser  8bmuser[9C0 Aug 22 11:02 ^[[00mdiagnostic.log^[[00m
-rw-r--r--    1 8bmuser  8bmuser[7C100 Feb 15  2002 ^[[00mENVIRON^[[00m
drwx------    6 8bmuser  8bmuser      4096 Feb  7  1998 ^[[01;34mlib^[[00m
drwxr-xr-x    3 8bmuser  8bmuser      4096 Jul 16 18:56 ^[[01;34mLOGIN_files^[[00m
-rw-r--r--    1 8bmuser  8bmuser[7C672 Feb 15  2002 ^[[00mRUN_315^[[00m
drwx------    4 8bmuser  8bmuser      4096 Feb 14  2002 ^[[01;34msaved_tars^[[00m
drwxr-xr-x    5 root     root[9C4096 May 20 16:38 ^[[01;34msrc^[[00m
drwx------   53 8bmuser  8bmuser      4096 Apr 25 16:24 ^[[01;34msrc_bls^[[00m
drwx------  159 8bmuser  8bmuser      4096 Jun 13 15:22 ^[[01;34msrc_std^[[00m
drwxrwxrwx    3 8bmuser  8bmuser      4096 Feb 27  2002 ^[[01;34mtables_904_swbin^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Aug 13 09:15 ^[[01;34mtables_api_904^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Feb 27  2002 ^[[01;34mtables_api_904_sim^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Apr  9  1998 ^[[01;34mtmp^[[00m
^[[m^[]0;capel@8bmserver1:/usr/local/ccd_dist^G[root@8bmserver1 ccd_dist]# cd src_std
^[]0;capel@8bmserver1:/usr/local/ccd_dist/src_std^G[root@8bmserver1 src_std]# ls -lrt[1;1H[H[2J[1;1H^[[m^[]0;capel@8bmserver1:/usr/local/ccd_dist^G[root@8bmserver1 ccd_dist]# cd src_std
^[]0;capel@8bmserver1:/usr/local/ccd_dist/src_std^G[root@8bmserver1 src_std]# ls -lrt
^[[00mtotal 5436
drwxr-xr-x    2 8bmuser  8bmuser      4096 Feb  7  1998 ^[[01;34mmdchw_dslib^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Apr 23  1998 ^[[01;34mmod_stab^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 May 17  1998 ^[[01;34mdark_stat^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Aug 21  1998 ^[[01;34mincl_backup^[[00m
drwxr-xr-x    3 8bmuser  8bmuser      4096 Aug 21  1998 ^[[01;34mdet_dev^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Nov 24  1998 ^[[01;34msmv_to_mar^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Dec  1  1998 ^[[01;34mdet_emulator^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Dec  7  1998 ^[[01;34mccd_xform_mult_api^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Dec  7  1998 ^[[01;34mccd_dc_mult_api^[[00m
drwxr-xr-x    4 8bmuser  8bmuser      4096 Dec 29  1998 ^[[01;34mfor_kinder^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Jan 27  1999 ^[[01;34mcheck_for_beam^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Feb  1  1999 ^[[01;34mcombine_smv_raw^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Feb 15  1999 ^[[01;34mccd_dc_t2k_api^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Feb 24  1999 ^[[01;34mtile_check^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 May 18  1999 ^[[01;34mccd_dc_calib^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Jun 15  1999 ^[[01;34mfix98^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Aug 13  1999 ^[[01;34mccdhwlib^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Sep 14  1999 ^[[01;34mccd_noise^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Sep 15  1999 ^[[01;34mccd_xform_check^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Sep 19  1999 ^[[01;34mccd_daemon_pc^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Oct  3  1999 ^[[01;34mccdsys_autopc^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Dec 14  1999 ^[[01;34mcombine_smv^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Dec 27  1999 ^[[01;34mccd_dc_api^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Jan  9  2000 ^[[01;34mpck2smv^[[00m[1;1H[H[2J[1;1Hdrwxr-xr-x    2 8bmuser  8bmuser      4096 Dec 27  1999 ^[[01;34mccd_dc_api^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Jan  9  2000 ^[[01;34mpck2smv^[[00m
drwxr-xr-x    3 8bmuser  8bmuser      4096 Jan 21  2000 ^[[01;34msmv2pck^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Feb 22  2000 ^[[01;34mderive_flood^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Feb 22  2000 ^[[01;34mderive_aux_flood^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Feb 24  2000 ^[[01;34mdet_emulator_q4^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Feb 24  2000 ^[[01;34mfileio_for_nt^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Feb 28  2000 ^[[01;34mxmitrecv^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Mar  1  2000 ^[[01;34mccd_dc_api_mad_chip^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Mar  2  2000 ^[[01;34mrot_fill_t2k^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Mar 30  2000 ^[[01;34mdet_sim_q4_full^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Jun 22  2000 ^[[01;34mstat_corners^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Jun 29  2000 ^[[01;34mccd_xform_calib^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Jul 11  2000 ^[[01;34mdet_sim_q4^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Jul 12  2000 ^[[01;34mstat_corners_special^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Jul 12  2000 ^[[01;34mrecalc_nonunf^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Jul 18  2000 ^[[01;34mfsplit^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Jul 29  2000 ^[[01;34mwave_server^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Jul 31  2000 ^[[01;34mmakefullimage^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Aug  1  2000 ^[[01;34mfan_out^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Aug  5  2000 ^[[01;34mccd_bl_gen_blsim^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Aug  5  2000 ^[[01;34mblsim_server^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Aug  6  2000 ^[[01;34mprep_q210_sim_input^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Aug  6  2000 ^[[01;34mimage_seq^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Sep 12  2000 ^[[01;34mmarty_calibint^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Sep 22  2000 ^[[01;34mccd_dc_esrf^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Sep 22  2000 ^[[01;34mccd_dc_api_lib^[[00m[1;1H[H[2J[1;1Hdrwxr-xr-x    2 8bmuser  8bmuser      4096 Sep 22  2000 ^[[01;34mccd_dc_esrf^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Sep 22  2000 ^[[01;34mccd_dc_api_lib^[[00m
drwxr-xr-x    3 8bmuser  8bmuser      4096 Sep 23  2000 ^[[01;34mnew_detcon_lib^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Sep 26  2000 ^[[01;34mdet_sim_t2k^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Nov 13  2000 ^[[01;34mt2k_ldtest^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Nov 13  2000 ^[[01;34mt2k_imt^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Dec  1  2000 ^[[01;34mt2k_libdet^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Dec  5  2000 ^[[01;34mmask_spots^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Feb 12  2001 ^[[01;34mtest_xform^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Feb 19  2001 ^[[01;34msub_smv^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Feb 19  2001 ^[[01;34mref_210^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Mar  7  2001 ^[[01;34mmarian_xformlib^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Mar  7  2001 ^[[01;34mlibxform_cn_chess^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Mar 15  2001 ^[[01;34mccd_status^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Mar 20  2001 ^[[01;34mgain_adj_441^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Mar 22  2001 ^[[01;34mfix_pc_fmt^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Mar 31  2001 ^[[01;34mtempcon_server^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Mar 31  2001 ^[[01;34mtempcon_client^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Apr  5  2001 ^[[01;34mped_adj^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Apr 13  2001 ^[[01;34mlibdet_update^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Apr 14  2001 ^[[01;34mlibxf_mod_test^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Apr 18  2001 ^[[01;34mccd_bl_gen_t2k^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Apr 18  2001 ^[[01;34mccd_bl_flood^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Apr 20  2001 ^[[01;34mccd_bl_gen_fast^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Apr 26  2001 ^[[01;34mped_adj_442^[[00m
drwxr-xr-x    3 8bmuser  8bmuser      4096 May  8  2001 ^[[01;34mccd_image_gather_single^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 May 12  2001 ^[[01;34mlibdetmod_ms_test^[[00m[1;1H[H[2J[1;1Hdrwxr-xr-x    3 8bmuser  8bmuser      4096 May  8  2001 ^[[01;34mccd_image_gather_single^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 May 12  2001 ^[[01;34mlibdetmod_ms_test^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 May 12  2001 ^[[01;34mlibdet_module_ms^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 May 14  2001 ^[[01;34mlibdet^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 May 21  2001 ^[[01;34mped_adj_443^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 May 27  2001 ^[[01;34mccd_dc_api_plus^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 May 27  2001 ^[[01;34mccd_xform_t2k_plus^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 May 28  2001 ^[[01;34mlibdetmod_test^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Jun 18  2001 ^[[01;34mlibdet_module^[[00m
drwxr-xr-x    3 8bmuser  8bmuser      4096 Jun 21  2001 ^[[01;34mlibxform_module_marian^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Jun 25  2001 ^[[01;34mserver_test^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Jun 28  2001 ^[[01;34mmodify_int_files^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Jul  4  2001 ^[[01;34mssrl_bin^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Jul  6  2001 ^[[01;34mlibxform^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Jul  9  2001 ^[[01;34mflood_inv_test^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Jul 25  2001 ^[[01;34mccd_xform_t2k^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Jul 26  2001 ^[[01;34mcrop_bin_2k^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Aug  4  2001 ^[[01;34mflood_runs^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Aug  5  2001 ^[[01;34mmodify_flood1_443^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Aug  9  2001 ^[[01;34mdet_api_module^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Aug  9  2001 ^[[01;34mderive_flood_210^[[00m
drwxr-xr-x    3 8bmuser  8bmuser      4096 Aug 16  2001 ^[[01;34mdezinger^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Aug 25  2001 ^[[01;34mdetcon_test_mp^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Aug 26  2001 ^[[01;34mnonsuch^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Aug 26  2001 ^[[01;34mdummy_pc_process^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Aug 26  2001 ^[[01;34mclient_test^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Aug 26  2001 ^[[01;34msend_exit_to_remote^[[00m[1;1H[H[2J[1;1Hdrwxr-xr-x    2 8bmuser  8bmuser      4096 Aug 26  2001 ^[[01;34mclient_test^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Aug 26  2001 ^[[01;34msend_exit_to_remote^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Aug 27  2001 ^[[01;34mdetcon_lib_mp^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Sep  4  2001 ^[[01;34mgraduated_flood^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Sep  8  2001 ^[[01;34mlibxform_2x2^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Sep  8  2001 ^[[01;34mccd_xform_2x2^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Sep  8  2001 ^[[01;34mpc_remote_start^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Sep  8  2001 ^[[01;34mdet_module_remote^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Sep  8  2001 ^[[01;34mmodify_flood_443^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Sep  8  2001 ^[[01;34mlibxform_3x3^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Sep  8  2001 ^[[01;34mccd_xform_3x3^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Sep  9  2001 ^[[01;34msignal_pc_remote.0^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Sep 11  2001 ^[[01;34mmodify_flood_901^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Sep 17  2001 ^[[01;34msw_bin^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Sep 17  2001 ^[[01;34mbin_ccd^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Sep 19  2001 ^[[01;34mmodify_floodfield^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Oct  2  2001 ^[[01;34madjust_interp_origin^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Oct  8  2001 ^[[01;34mstat_areas.0^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Oct  9  2001 ^[[01;34mped_modify^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Oct 16  2001 ^[[01;34mmodify_nonunf^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Oct 16  2001 ^[[01;34mgains_443^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Oct 16  2001 ^[[01;34mmodify_flood1_443_bin^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Oct 17  2001 ^[[01;34mccd_dc_api_pf^[[00m
drwxr-xr-x    3 8bmuser  8bmuser      4096 Oct 17  2001 ^[[01;34mccd_bl_gen_pf^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Nov  6  2001 ^[[01;34mregion_solve^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Nov 13  2001 ^[[01;34mdet_api^[[00m
drwxr-xr-x    4 8bmuser  8bmuser      4096 Nov 20  2001 ^[[01;34mals_updates^[[00m[1;1H[H[2J[1;1Hdrwxr-xr-x    2 8bmuser  8bmuser      4096 Nov 13  2001 ^[[01;34mdet_api^[[00m
drwxr-xr-x    4 8bmuser  8bmuser      4096 Nov 20  2001 ^[[01;34mals_updates^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Nov 28  2001 ^[[01;34mmake_gain_regions^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Nov 28  2001 ^[[01;34mstat_regions^[[00m
-rw-r--r--    1 8bmuser  8bmuser   1280000 Nov 29  2001 ^[[01;31madx_slit.tar^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Dec  4  2001 ^[[01;34mdetcon_lib^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Dec  4  2001 ^[[01;34mdetcon_test^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Dec  5  2001 ^[[01;34mtestthread^[[00m
-rw-r--r--    1 8bmuser  8bmuser    194261 Dec  7  2001 ^[[01;31mccd_dc_api_mad.tar.Z^[[00m
drwxr-xr-x    3 8bmuser  8bmuser      4096 Dec 13  2001 ^[[01;34mccd_image_gather.0^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Dec 18  2001 ^[[01;34mssrl_to_adsc_names^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Dec 19  2001 ^[[01;34mretransform^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Jan 27  2002 ^[[01;34mmake_q4_gain_regions^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Feb 11  2002 ^[[01;34mpatch_header^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Feb 11  2002 ^[[01;34mmake_gain_objects^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Feb 11  2002 ^[[01;34mtemp_tweak^[[00m
drwxrwxr-x    2 8bmuser  8bmuser      4096 Feb 14  2002 ^[[01;34mulib_ccd^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Feb 14  2002 ^[[01;34mccd_bl_gen^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Feb 26  2002 ^[[01;34mlibxform_module^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Feb 26  2002 ^[[01;34mdet_module_plus^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Feb 26  2002 ^[[01;34mccd_xform_new_api^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Feb 26  2002 ^[[01;34mdet_api_workstation^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Feb 28  2002 ^[[01;34mlibdet_module_plus^[[00m
-rw-r--r--    1 root     root[8C61440 May 17 15:11 ^[[01;31msignal_pc_remote.tar^[[00m
-rw-r--r--    1 root     root[7C419840 May 17 15:12 ^[[01;31mccd_image_gather.tar^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 May 17 15:18 ^[[01;34mccdsys^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 May 20 10:59 ^[[01;34mincl^[[00m[1;1H[H[2J[1;1Hdrwxr-xr-x    2 8bmuser  8bmuser      4096 May 17 15:18 ^[[01;34mccdsys^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 May 20 10:59 ^[[01;34mincl^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 May 20 11:00 ^[[01;34mauxlib^[[00m
drwxr-xr-x    8 8bmuser  8bmuser      4096 May 20 16:32 ^[[01;34madx_ccd^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 May 20 16:53 ^[[01;34mccd_daemon^[[00m
drwxr-xr-x    2 1120     games[8C4096 May 20 16:57 ^[[01;34msignal_pc_remote^[[00m
drwxr-xr-x    2 1115     103[10C4096 May 20 17:33 ^[[01;34madx_ccd_control_pf^[[00m
drwxr-xr-x    3 8bmuser  8bmuser      4096 May 21 13:00 ^[[01;34mlibwincompat^[[00m
-rw-r--r--    1 root     root[7C883023 May 21 13:33 ^[[01;31m8bm_updates.tar.Z^[[00m
-rw-r--r--    1 root     root[7C460800 May 21 13:38 ^[[01;31mqc_315.tar^[[00m
drwxr-xr-x    3 1120     games[8C4096 Jun 12 18:45 ^[[01;34mccd_image_gather^[[00m
-rw-r--r--    1 root     root[7C573440 Jun 13 14:47 ^[[01;31mstat_areas_ssrl.tar^[[00m
drwx------    2 1166     users[8C4096 Jun 13 14:48 ^[[01;34mstat_areas^[[00m
-rw-r--r--    1 root     root[7C573440 Jun 13 15:10 ^[[01;31mstat_spots.tar^[[00m
drwx------    2 1120     games[8C4096 Jun 13 15:10 ^[[01;34mstat_spots^[[00m
-rw-r--r--    1 root     root[7C430080 Jun 13 15:22 ^[[01;31mxgraph-11.tar^[[00m
drwx------    4 1166     users[8C4096 Jun 13 15:24 ^[[01;34mxgraph-11^[[00m
drwxr-xr-x    2 8bmuser  8bmuser      4096 Jul 16 18:51 ^[[01;34mccd_dc_api_mad^[[00m
drwxr-xr-x    2 1115     103[10C4096 Aug 14 13:11 ^[[01;34mccd_dc_api_mad_x8c^[[00m
^[[m^[]0;capel@8bmserver1:/usr/local/ccd_dist/src_std^G[root@8bmserver1 src_std]# cd ccd_dc_api_mad_x8c
^[]0;capel@8bmserver1:/usr/local/ccd_dist/src_std/ccd_dc_api_mad_x8c^G[root@8bmserver1 ccd_dc_api_mad_x8c]# lks - [22;1Hl^H^H^H^H^H^H^[[Klks -l^H^H^H^H^H^H^[[Kls -l
^[[00mtotal 1608
-rw-r--r--    1 1115     103[11C438 Apr 26  1999 ^[[00madded_commands^[[00m
-rw-r--r--    1 1115     103[12C84 Apr 26  1999 ^[[00mbzero.c^[[00m
-rw-r--r--    1 1115     103[10C1559 Jun 19  2001 ^[[00mccd_dc_args.c^[[00m
-rw-r--r--    1 1115     103[10C1559 Apr 26  1999 ^[[00mccd_dc_args.c~^[[00m[1;1H[H[2J[1;1H-rw-r--r--    1 1115     103[10C1559 Jun 19  2001 ^[[00mccd_dc_args.c^[[00m
-rw-r--r--    1 1115     103[10C1559 Apr 26  1999 ^[[00mccd_dc_args.c~^[[00m
-rw-r--r--    1 root     root[8C37996 Aug 13 09:16 ^[[00mccd_dc_args.o^[[00m
-rw-r--r--    1 1115     103[10C4604 Apr 18 18:40 ^[[00mccd_dc_bl.c^[[00m
-rw-r--r--    1 1115     103[10C4576 Apr 11  2001 ^[[00mccd_dc_bl.c~^[[00m
-rw-r--r--    1 root     root[8C40692 Aug 13 09:16 ^[[00mccd_dc_bl.o^[[00m
-rw-r--r--    1 1115     103[10C9357 Aug 13 09:08 ^[[00mccd_dc_defs.h^[[00m
-rw-r--r--    1 1115     103[10C4587 Jun 19  2001 ^[[00mccd_dc_det.c^[[00m
-rw-r--r--    1 1115     103[10C4578 Jun 19  2001 ^[[00mccd_dc_det.c~^[[00m
-rw-r--r--    1 root     root[8C41192 Aug 13 09:16 ^[[00mccd_dc_det.o^[[00m
-rw-r--r--    1 1115     103[10C9785 Aug 13 09:09 ^[[00mccd_dc_ext.h^[[00m
-rw-r--r--    1 1115     103[9C17755 Aug 13 09:08 ^[[00mccd_dc_glob.c^[[00m
-rw-r--r--    1 root     root[8C55936 Aug 13 09:16 ^[[00mccd_dc_glob.o^[[00m
-rw-r--r--    1 1115     103[10C3451 Jul  5  1999 ^[[00mccd_dc_heartbeat.c^[[00m
-rw-r--r--    1 root     root[8C38760 Aug 13 09:16 ^[[00mccd_dc_heartbeat.o^[[00m
-rw-r--r--    1 1115     103[9C51448 Aug 14 13:11 ^[[00mccd_dc_hw.c^[[00m
-rw-r--r--    1 1115     103[9C51287 Aug 13 12:24 ^[[00mccd_dc_hw.c~^[[00m
-rw-r--r--    1 1115     103[9C43207 Jun  5  2001 ^[[00mccd_dc_hw.c.0^[[00m
-rw-r--r--    1 1115     103[9C43644 Jun 14  2001 ^[[00mccd_dc_hw.c.1^[[00m
-rw-r--r--    1 1115     103[9C35364 Apr 26  1999 ^[[00mccd_dc_hw.c.old^[[00m
-rw-r--r--    1 root     root[8C93652 Aug 14 13:11 ^[[00mccd_dc_hw.o^[[00m
-rw-r--r--    1 1115     103[9C10815 Apr 26  1999 ^[[00mccd_dc_hwsim.c^[[00m
-rw-r--r--    1 root     root[8C52280 Aug 13 09:16 ^[[00mccd_dc_hwsim.o^[[00m
-rw-r--r--    1 1115     103[9C22959 Apr 18 20:43 ^[[00mccd_dc_input.c^[[00m
-rw-r--r--    1 1115     103[9C20752 Jun  6  1999 ^[[00mccd_dc_input.c~^[[00m
-rw-r--r--    1 1115     103[9C17802 Apr 26  1999 ^[[00mccd_dc_input.c.0^[[00m
-rw-r--r--    1 root     root[8C61852 Aug 13 09:16 ^[[00mccd_dc_input.o^[[00m[1;1H[H[2J[1;1H-rw-r--r--    1 1115     103[9C17802 Apr 26  1999 ^[[00mccd_dc_input.c.0^[[00m
-rw-r--r--    1 root     root[8C61852 Aug 13 09:16 ^[[00mccd_dc_input.o^[[00m
-rw-r--r--    1 1115     103[9C16876 Apr 26  1999 ^[[00mccd_dc_input_orig.c^[[00m
-rw-r--r--    1 1115     103[10C1056 Jun 19  2001 ^[[00mccd_dc_main.c^[[00m
-rw-r--r--    1 1115     103[10C1011 Jun 19  2001 ^[[00mccd_dc_main.c~^[[00m
-rw-r--r--    1 root     root[8C37472 Aug 13 09:16 ^[[00mccd_dc_main.o^[[00m
-rw-r--r--    1 1115     103[9C42943 Aug 13 09:12 ^[[00mccd_dc_misc.c^[[00m
-rw-r--r--    1 1115     103[9C38647 Jun 19  2001 ^[[00mccd_dc_misc.c~^[[00m
-rw-r--r--    1 1115     103[9C33426 Apr 26  1999 ^[[00mccd_dc_misc.c.0^[[00m
-rw-r--r--    1 root     root[8C84188 Aug 13 09:16 ^[[00mccd_dc_misc.o^[[00m
-rw-r--r--    1 1115     103[10C8100 Apr 24 18:51 ^[[00mccd_dc_seq.c^[[00m
-rw-r--r--    1 1115     103[10C9732 Apr 26  1999 ^[[00mccd_dc_seq.c.0^[[00m
-rw-r--r--    1 1115     103[10C9363 Apr 24 18:52 ^[[00mccd_dc_seq_nowork.c^[[00m
-rw-r--r--    1 root     root[8C47324 Aug 13 09:16 ^[[00mccd_dc_seq.o^[[00m
-rw-r--r--    1 1115     103[10C3274 Apr 26  1999 ^[[00mccd_dc_sio.c^[[00m
-rw-r--r--    1 root     root[8C40400 Aug 13 09:16 ^[[00mccd_dc_sio.o^[[00m
-rw-r--r--    1 1115     103[9C23181 May 20 23:55 ^[[00mccd_dc_strstat.c^[[00m
-rw-r--r--    1 root     root[8C58004 Aug 13 09:16 ^[[00mccd_dc_strstat.o^[[00m
-rw-r--r--    1 1115     103[9C19780 Apr 18 18:21 ^[[00mccd_server.c^[[00m
-rw-r--r--    1 1115     103[9C19327 Jun 19  2001 ^[[00mccd_server.c~^[[00m
-rw-r--r--    1 root     root[8C61760 Aug 13 09:16 ^[[00mccd_server.o^[[00m
-rw-r--r--    1 root     root[12C0 Aug 13 10:59 ^[[00mccd_xform.log^[[00m
-rw-r--r--    1 root     root[10C867 Aug 13 10:59 ^[[00mdet_api_8bmserver1.imm.aps.anl.gov.log^[[00m
-rw-r--r--    1 root     root[12C0 Aug 13 10:59 ^[[00mdiagnostic.log^[[00m
-rw-r--r--    1 1115     103[10C1315 Apr 18 19:22 ^[[00mget_attenuator.c^[[00m
-rw-r--r--    1 root     root[8C12356 Aug 13 09:16 ^[[00mget_attenuator.o^[[00m
lrwxrwxrwx    1 1115     103[12C18 May 20 10:46 ^[[01;36mMakefile^[[00m -> ^[[00mMakefile_x8c.alpha^[[00m[1;1H[H[2J[1;1H-rw-r--r--    1 root     root[8C12356 Aug 13 09:16 ^[[00mget_attenuator.o^[[00m
lrwxrwxrwx    1 1115     103[12C18 May 20 10:46 ^[[01;36mMakefile^[[00m -> ^[[00mMakefile_x8c.alpha^[[00m[3;1H-rw-r--r--    1 1115     103[12C83 Apr 26  1999 ^[[00mMakefile.alpha^[[00m
-rw-r--r--    1 1115     103[12C92 Apr 23 09:17 ^[[00mMakefile.linux^[[00m
-rw-r--r--    1 1115     103[12C74 Apr 26  1999 ^[[00mMakefile.sgi^[[00m
-rw-r--r--    1 1115     103[12C89 Apr 26  1999 ^[[00mMakefile.sun^[[00m
-rw-r--r--    1 1115     103[12C89 Apr 23 13:26 ^[[00mMakefile_x8c.alpha^[[00m
-rw-r--r--    1 1115     103[12C98 Apr 18 17:23 ^[[00mMakefile_x8c.linux^[[00m
-rw-r--r--    1 1115     103[12C80 Apr 18 17:24 ^[[00mMakefile_x8c.sgi^[[00m
-rw-r--r--    1 1115     103[12C95 Apr 18 17:24 ^[[00mMakefile_x8c.sun^[[00m
-rw-r--r--    1 1115     103[11C639 Aug 13 11:13 ^[[00mMkfile^[[00m
-rw-r--r--    1 1115     103[11C821 Apr 26  1999 ^[[00mmult_commands^[[00m
-rw-r--r--    1 1115     103[10C2003 Apr 26  1999 ^[[00mnet_client.c^[[00m
-rw-r--r--    1 root     root[8C23544 Aug 13 09:16 ^[[00mnet_client.o^[[00m
-rw-r--r--    1 1115     103[9C13348 Apr 26  1999 ^[[00mparse_file_name^[[00m
-rw-r--r--    1 1115     103[11C629 Apr 26  1999 ^[[00mparse_file_name.c^[[00m
-rw-r--r--    1 1115     103[10C9949 Apr 26  1999 ^[[00mtest_seq.c^[[00m
-rw-r--r--    1 1115     103[10C8331 Apr 26  1999 ^[[00mtest_seq_first.c^[[00m
-rw-r--r--    1 1115     103[11C784 Apr 26  1999 ^[[00mutil_misc.c^[[00m
-rw-r--r--    1 root     root[8C11396 Aug 13 09:16 ^[[00mutil_misc.o^[[00m
-rw-r--r--    1 1115     103[10C2082 Apr 26  1999 ^[[00mvms_select.h^[[00m
^[[m^[]0;capel@8bmserver1:/usr/local/ccd_dist/src_std/ccd_dc_api_mad_x8c^G[root@8bmserver1 ccd_dc_api_mad_x8c]# l [23;1Hs -lrt *,^H ^H.[ch]
^[[00m-rw-r--r--    1 1115     103[12C84 Apr 26  1999 ^[[00mbzero.c^[[00m
-rw-r--r--    1 1115     103[9C10815 Apr 26  1999 ^[[00mccd_dc_hwsim.c^[[00m
-rw-r--r--    1 1115     103[10C3274 Apr 26  1999 ^[[00mccd_dc_sio.c^[[00m
-rw-r--r--    1 1115     103[9C16876 Apr 26  1999 ^[[00mccd_dc_input_orig.c^[[00m[1;1H[H[2J[1;1H-rw-r--r--    1 1115     103[10C3274 Apr 26  1999 ^[[00mccd_dc_sio.c^[[00m
-rw-r--r--    1 1115     103[9C16876 Apr 26  1999 ^[[00mccd_dc_input_orig.c^[[00m
-rw-r--r--    1 1115     103[11C784 Apr 26  1999 ^[[00mutil_misc.c^[[00m
-rw-r--r--    1 1115     103[10C8331 Apr 26  1999 ^[[00mtest_seq_first.c^[[00m
-rw-r--r--    1 1115     103[10C9949 Apr 26  1999 ^[[00mtest_seq.c^[[00m
-rw-r--r--    1 1115     103[11C629 Apr 26  1999 ^[[00mparse_file_name.c^[[00m
-rw-r--r--    1 1115     103[10C2003 Apr 26  1999 ^[[00mnet_client.c^[[00m
-rw-r--r--    1 1115     103[10C2082 Apr 26  1999 ^[[00mvms_select.h^[[00m
-rw-r--r--    1 1115     103[10C3451 Jul  5  1999 ^[[00mccd_dc_heartbeat.c^[[00m
-rw-r--r--    1 1115     103[10C1559 Jun 19  2001 ^[[00mccd_dc_args.c^[[00m
-rw-r--r--    1 1115     103[10C4587 Jun 19  2001 ^[[00mccd_dc_det.c^[[00m
-rw-r--r--    1 1115     103[10C1056 Jun 19  2001 ^[[00mccd_dc_main.c^[[00m
-rw-r--r--    1 1115     103[9C19780 Apr 18 18:21 ^[[00mccd_server.c^[[00m
-rw-r--r--    1 1115     103[10C4604 Apr 18 18:40 ^[[00mccd_dc_bl.c^[[00m
-rw-r--r--    1 1115     103[10C1315 Apr 18 19:22 ^[[00mget_attenuator.c^[[00m
-rw-r--r--    1 1115     103[9C22959 Apr 18 20:43 ^[[00mccd_dc_input.c^[[00m
-rw-r--r--    1 1115     103[10C8100 Apr 24 18:51 ^[[00mccd_dc_seq.c^[[00m
-rw-r--r--    1 1115     103[10C9363 Apr 24 18:52 ^[[00mccd_dc_seq_nowork.c^[[00m
-rw-r--r--    1 1115     103[9C23181 May 20 23:55 ^[[00mccd_dc_strstat.c^[[00m
-rw-r--r--    1 1115     103[10C9357 Aug 13 09:08 ^[[00mccd_dc_defs.h^[[00m
-rw-r--r--    1 1115     103[9C17755 Aug 13 09:08 ^[[00mccd_dc_glob.c^[[00m
-rw-r--r--    1 1115     103[10C9785 Aug 13 09:09 ^[[00mccd_dc_ext.h^[[00m
-rw-r--r--    1 1115     103[9C42943 Aug 13 09:12 ^[[00mccd_dc_misc.c^[[00m
-rw-r--r--    1 1115     103[9C51448 Aug 14 13:11 ^[[00mccd_dc_hw.c^[[00m
^[[m^[]0;capel@8bmserver1:/usr/local/ccd_dist/src_std/ccd_dc_api_mad_x8c^G[root@8bmserver1 ccd_dc_api_mad_x8c]# c [26;1Hat ^H^H^H^H^[[Km^H^[[Kcat ccd_dc_defs.h
#include[8C<stdio.h>[1;1H[H[2J[1;1H^[[m^[]0;capel@8bmserver1:/usr/local/ccd_dist/src_std/ccd_dc_api_mad_x8c^G[root@8bmserver1 ccd_dc_api_mad_x8c]# c [2;1Hat ^H^H^H^H^[[Km^H^[[Kcat ccd_dc_defs.h
#include[8C<stdio.h>
#include[8C"../incl/ccdconv.h"
#include[8C"../incl/esd.h"
#include[8C"../incl/esd_com.h"
#include[8C"../incl/ccddefs.h"
#include[8C"../incl/ccdsys.h"
#include[8C<errno.h>
#include[8C<signal.h>
#include[8C<math.h>

#ifndef VMS
#include[8C<sys/types.h>
#include[8C<sys/time.h>
#include[8C<sys/socket.h>
#include[8C<netinet/in.h>
#else
#include[8C<types.h>
#include[8C<time.h>
#include[8C<socket.h>
#include[8C<in.h>
#include[8C"../incl/vms_select.h"
#endif /* VMS */

#ifdef VMS
#define GOOD_STATUS     1[1;1H[H[2J[1;1H#ifdef VMS
#define GOOD_STATUS     1
#define BAD_STATUS      2
#else
#define GOOD_STATUS     0
#define BAD_STATUS      1
#endif /* VMS */

#define CCD_N_CTRL[14C"CCD_N_CTRL"

#define CCD_DET_OK[14C0
#define CCD_DET_RETRY[11C1
#define CCD_DET_FATAL[11C2
#define CCD_DET_NOTCONNECTED    3
#define CCD_DET_DISCONNECTED    4

#define CCD_BL_OK[15C10
#define CCD_BL_RETRY[12C11
#define CCD_BL_FATAL[12C12
#define CCD_BL_NOTCONNECTED     13
#define CCD_BL_DISCONNECTED     14

#define MAXREMARK[7C100
#define BLCMDMAX[8C256

struct mdc_command {[27;17Hint     cmd_used;[7C/* 0 if this queue entry unused */[1;1H[H[2J[1;1Hstruct mdc_command {[2;17Hint     cmd_used;[7C/* 0 if this queue entry unused */[3;17Hstruct mdc_command *cmd_next;   /* next command in queue */[4;17Hint     cmd_no;[9C/* the command number/this command */[5;17Hint     cmd_err;[8C/* 1 if there is an error */[6;17Hfloat   cmd_value;      /* a value field, if appropriate */[7;17Hfloat   cmd_col_dist;   /* distance for data collection */[8;17Hfloat   cmd_col_lift;   /* lift value for data collection */[9;17Hfloat   cmd_col_phis;   /* phi start for data collection */[10;17Hfloat   cmd_col_omegas; /* omega start for data collection */[11;17Hfloat   cmd_col_kappas; /* kappa start for data collection */[12;17Hfloat   cmd_col_osc_width;  /* oscillation width/image */[13;17Hint     cmd_col_axis;   /* 1 for phi, 0 for omega */[14;17Hint     cmd_col_newdark;    /* 1 for a new dark current image, else 0 */[15;17Hint     cmd_col_anom;[7C/* 1 for anomalous data */[16;17Hint     cmd_col_wedge;      /* wedge (#frames per batch) size for anom data */[17;17Hint     cmd_col_n_images;   /* number of images to collect */[18;17Hint     cmd_col_n_passes;   /* number of osc passes/image */[19;17Hfloat   cmd_col_time;[7C/* data collection time/image */[20;17Hint     cmd_col_mode;[7C/* 0 = collect time, 1 dose */[21;17Hint     cmd_col_image_number; /* start image number */[22;17Hchar    cmd_col_dir[132];   /* directory for output images */[23;17Hchar    cmd_col_prefix[30]; /* image name prefix */[24;17Hchar    cmd_col_suffix[30]; /* image name suffix */[25;17Hint     cmd_col_adc;[8C/* adc select */[26;17Hint     cmd_col_bin;[8C/* bin select */[27;17Hfloat   cmd_col_xcen;[7C/* x detector center in mm for oblique correction */[1;1H[H[2J[1;17Hint     cmd_col_bin;[8C/* bin select */[2;17Hfloat   cmd_col_xcen;[7C/* x detector center in mm for oblique correction */[3;17Hfloat   cmd_col_ycen;[7C/* y detector center in mm for oblique correction */[4;17Hint     cmd_col_compress;   /* 0 for none, 1 for .Z, 2 for .pck */[5;17Hfloat   cmd_col_dzratio;    /* ratio of 2nd picture expos time to 1st */[6;17Hint     cmd_col_dkinterval; /* interval between darks */[7;17Hint     cmd_col_rep_dark;   /* 1 to repeat darks every darkinterval seconds */[8;17Hint     cmd_col_dk_before;  /* 1 to repeat darks before each run */[9;17Hint     cmd_col_outfile_type;   /* 0 for 16 bit, 1 for 32 bit, 2 for 16 + overflow records */[10;17Hint     cmd_col_no_transform;   /* 1 to not transform data */[11;17Hint     cmd_col_output_raws;    /* 1 to output raws */[12;17Hfloat   cmd_col_step_size;      /* size of step for step/dose mode */[13;17Hfloat   cmd_col_dose_step;      /* dose per step, step/dose mode */[14;17Hfloat   cmd_col_atten_run;      /* attenuator amount for this run */[15;17Hfloat   cmd_col_hslit_run;      /* horiz slit amount for this run */[16;17Hfloat   cmd_col_vslit_run;      /* vertical slit amount for this run */[17;17Hfloat   cmd_col_autoal_run;     /* autoalign every run */[18;17Hfloat   cmd_col_run_wave;[19;17Hint     cmd_col_mad_mode;[7C/* 0 never, 1 per run, 2 per wedge, 3 per nframes */[20;17Hint     cmd_col_mad_nframes;    /* for mode = 3, number of frames between wavelength changes */[21;17Hint     cmd_col_mad_nwave;      /* number of wavelengths */[22;17Hfloat   cmd_col_mad_wavelengths[10];    /* wavelengths */[23;17Hfloat   cmd_col_do_wavelength;  /* used after runs are expanded in the queue */[24;17Hint     cmd_col_remarkc;[8C/* number of remark records */[25;17Hint     cmd_col_restart_run;[12C/* run number for restart */[26;17Hint     cmd_col_restart_image;[10C/* image number for restart */[27;17Hchar    *cmd_col_remarkv[MAXREMARK];  /* pointers to remarks */[1;17H[H[2J[1;1Hstruct mdc_command {[2;17Hint     cmd_used;[7C/* 0 if this queue entry unused */[3;17Hstruct mdc_command *cmd_next;   /* next command in queue */[4;17Hint     cmd_no;[9C/* the command number/this command */[5;17Hint     cmd_err;[8C/* 1 if there is an error */[6;17Hfloat   cmd_value;      /* a value field, if appropriate */[7;17Hfloat   cmd_col_dist;   /* distance for data collection */[8;17Hfloat   cmd_col_lift;   /* lift value for data collection */[9;17Hfloat   cmd_col_phis;   /* phi start for data collection */[10;17Hfloat   cmd_col_omegas; /* omega start for data collection */[11;17Hfloat   cmd_col_kappas; /* kappa start for data collection */[12;17Hfloat   cmd_col_osc_width;  /* oscillation width/image */[13;17Hint     cmd_col_axis;   /* 1 for phi, 0 for omega */[14;17Hint     cmd_col_newdark;    /* 1 for a new dark current image, else 0 */[15;17Hint     cmd_col_anom;[7C/* 1 for anomalous data */[16;17Hint     cmd_col_wedge;      /* wedge (#frames per batch) size for anom data */[17;17Hint     cmd_col_n_images;   /* number of images to collect */[18;17Hint     cmd_col_n_passes;   /* number of osc passes/image */[19;17Hfloat   cmd_col_time;[7C/* data collection time/image */[20;17Hint     cmd_col_mode;[7C/* 0 = collect time, 1 dose */[21;17Hint     cmd_col_image_number; /* start image number */[22;17Hchar    cmd_col_dir[132];   /* directory for output images */[23;17Hchar    cmd_col_prefix[30]; /* image name prefix */[24;17Hchar    cmd_col_suffix[30]; /* image name suffix */[25;17Hint     cmd_col_adc;[8C/* adc select */[26;17Hint     cmd_col_bin;[8C/* bin select */[27;17Hfloat   cmd_col_xcen;[7C/* x detector center in mm for oblique correction */[27;17H[H[2J[1;1H#ifdef VMS
#define GOOD_STATUS     1
#define BAD_STATUS      2
#else
#define GOOD_STATUS     0
#define BAD_STATUS      1
#endif /* VMS */

#define CCD_N_CTRL[14C"CCD_N_CTRL"

#define CCD_DET_OK[14C0
#define CCD_DET_RETRY[11C1
#define CCD_DET_FATAL[11C2
#define CCD_DET_NOTCONNECTED    3
#define CCD_DET_DISCONNECTED    4

#define CCD_BL_OK[15C10
#define CCD_BL_RETRY[12C11
#define CCD_BL_FATAL[12C12
#define CCD_BL_NOTCONNECTED     13
#define CCD_BL_DISCONNECTED     14

#define MAXREMARK[7C100
#define BLCMDMAX[8C256

struct mdc_command {[27;17Hint     cmd_used;[7C/* 0 if this queue entry unused */[27;17H[H[2J[1;1H^[[m^[]0;capel@8bmserver1:/usr/local/ccd_dist/src_std/ccd_dc_api_mad_x8c^G[root@8bmserver1 ccd_dc_api_mad_x8c]# c [2;1Hat ^H^H^H^H^[[Km^H^[[Kcat ccd_dc_defs.h
#include[8C<stdio.h>
#include[8C"../incl/ccdconv.h"
#include[8C"../incl/esd.h"
#include[8C"../incl/esd_com.h"
#include[8C"../incl/ccddefs.h"
#include[8C"../incl/ccdsys.h"
#include[8C<errno.h>
#include[8C<signal.h>
#include[8C<math.h>

#ifndef VMS
#include[8C<sys/types.h>
#include[8C<sys/time.h>
#include[8C<sys/socket.h>
#include[8C<netinet/in.h>
#else
#include[8C<types.h>
#include[8C<time.h>
#include[8C<socket.h>
#include[8C<in.h>
#include[8C"../incl/vms_select.h"
#endif /* VMS */

#ifdef VMS
#define GOOD_STATUS     1[H[2J[1;1H-rw-r--r--    1 1115     103[10C3274 Apr 26  1999 ^[[00mccd_dc_sio.c^[[00m
-rw-r--r--    1 1115     103[9C16876 Apr 26  1999 ^[[00mccd_dc_input_orig.c^[[00m
-rw-r--r--    1 1115     103[11C784 Apr 26  1999 ^[[00mutil_misc.c^[[00m
-rw-r--r--    1 1115     103[10C8331 Apr 26  1999 ^[[00mtest_seq_first.c^[[00m
-rw-r--r--    1 1115     103[10C9949 Apr 26  1999 ^[[00mtest_seq.c^[[00m
-rw-r--r--    1 1115     103[11C629 Apr 26  1999 ^[[00mparse_file_name.c^[[00m
-rw-r--r--    1 1115     103[10C2003 Apr 26  1999 ^[[00mnet_client.c^[[00m
-rw-r--r--    1 1115     103[10C2082 Apr 26  1999 ^[[00mvms_select.h^[[00m
-rw-r--r--    1 1115     103[10C3451 Jul  5  1999 ^[[00mccd_dc_heartbeat.c^[[00m
-rw-r--r--    1 1115     103[10C1559 Jun 19  2001 ^[[00mccd_dc_args.c^[[00m
-rw-r--r--    1 1115     103[10C4587 Jun 19  2001 ^[[00mccd_dc_det.c^[[00m
-rw-r--r--    1 1115     103[10C1056 Jun 19  2001 ^[[00mccd_dc_main.c^[[00m
-rw-r--r--    1 1115     103[9C19780 Apr 18 18:21 ^[[00mccd_server.c^[[00m
-rw-r--r--    1 1115     103[10C4604 Apr 18 18:40 ^[[00mccd_dc_bl.c^[[00m
-rw-r--r--    1 1115     103[10C1315 Apr 18 19:22 ^[[00mget_attenuator.c^[[00m
-rw-r--r--    1 1115     103[9C22959 Apr 18 20:43 ^[[00mccd_dc_input.c^[[00m
-rw-r--r--    1 1115     103[10C8100 Apr 24 18:51 ^[[00mccd_dc_seq.c^[[00m
-rw-r--r--    1 1115     103[10C9363 Apr 24 18:52 ^[[00mccd_dc_seq_nowork.c^[[00m
-rw-r--r--    1 1115     103[9C23181 May 20 23:55 ^[[00mccd_dc_strstat.c^[[00m
-rw-r--r--    1 1115     103[10C9357 Aug 13 09:08 ^[[00mccd_dc_defs.h^[[00m
-rw-r--r--    1 1115     103[9C17755 Aug 13 09:08 ^[[00mccd_dc_glob.c^[[00m
-rw-r--r--    1 1115     103[10C9785 Aug 13 09:09 ^[[00mccd_dc_ext.h^[[00m
-rw-r--r--    1 1115     103[9C42943 Aug 13 09:12 ^[[00mccd_dc_misc.c^[[00m
-rw-r--r--    1 1115     103[9C51448 Aug 14 13:11 ^[[00mccd_dc_hw.c^[[00m
^[[m^[]0;capel@8bmserver1:/usr/local/ccd_dist/src_std/ccd_dc_api_mad_x8c^G[root@8bmserver1 ccd_dc_api_mad_x8c]# c [26;1Hat ^H^H^H^H^[[Km^H^[[Kcat ccd_dc_defs.h
#include[8C<stdio.h>[H[2J[1;1H^[[m^[]0;capel@8bmserver1:/usr/local/ccd_dist/src_std/ccd_dc_api_mad_x8c^G[root@8bmserver1 ccd_dc_api_mad_x8c]# c [2;1Hat ^H^H^H^H^[[Km^H^[[Kcat ccd_dc_defs.h
#include[8C<stdio.h>
#include[8C"../incl/ccdconv.h"
#include[8C"../incl/esd.h"
#include[8C"../incl/esd_com.h"
#include[8C"../incl/ccddefs.h"
#include[8C"../incl/ccdsys.h"
#include[8C<errno.h>
#include[8C<signal.h>
#include[8C<math.h>

#ifndef VMS
#include[8C<sys/types.h>
#include[8C<sys/time.h>
#include[8C<sys/socket.h>
#include[8C<netinet/in.h>
#else
#include[8C<types.h>
#include[8C<time.h>
#include[8C<socket.h>
#include[8C<in.h>
#include[8C"../incl/vms_select.h"
#endif /* VMS */

#ifdef VMS
#define GOOD_STATUS     1[1;1H[H[2J[1;1H#ifdef VMS
#define GOOD_STATUS     1
#define BAD_STATUS      2
#else
#define GOOD_STATUS     0
#define BAD_STATUS      1
#endif /* VMS */

#define CCD_N_CTRL[14C"CCD_N_CTRL"

#define CCD_DET_OK[14C0
#define CCD_DET_RETRY[11C1
#define CCD_DET_FATAL[11C2
#define CCD_DET_NOTCONNECTED    3
#define CCD_DET_DISCONNECTED    4

#define CCD_BL_OK[15C10
#define CCD_BL_RETRY[12C11
#define CCD_BL_FATAL[12C12
#define CCD_BL_NOTCONNECTED     13
#define CCD_BL_DISCONNECTED     14

#define MAXREMARK[7C100
#define BLCMDMAX[8C256

struct mdc_command {[27;17Hint     cmd_used;[7C/* 0 if this queue entry unused */[1;1H[H[2J[1;1Hstruct mdc_command {[2;17Hint     cmd_used;[7C/* 0 if this queue entry unused */[3;17Hstruct mdc_command *cmd_next;   /* next command in queue */[4;17Hint     cmd_no;[9C/* the command number/this command */[5;17Hint     cmd_err;[8C/* 1 if there is an error */[6;17Hfloat   cmd_value;      /* a value field, if appropriate */[7;17Hfloat   cmd_col_dist;   /* distance for data collection */[8;17Hfloat   cmd_col_lift;   /* lift value for data collection */[9;17Hfloat   cmd_col_phis;   /* phi start for data collection */[10;17Hfloat   cmd_col_omegas; /* omega start for data collection */[11;17Hfloat   cmd_col_kappas; /* kappa start for data collection */[12;17Hfloat   cmd_col_osc_width;  /* oscillation width/image */[13;17Hint     cmd_col_axis;   /* 1 for phi, 0 for omega */[14;17Hint     cmd_col_newdark;    /* 1 for a new dark current image, else 0 */[15;17Hint     cmd_col_anom;[7C/* 1 for anomalous data */[16;17Hint     cmd_col_wedge;      /* wedge (#frames per batch) size for anom data */[17;17Hint     cmd_col_n_images;   /* number of images to collect */[18;17Hint     cmd_col_n_passes;   /* number of osc passes/image */[19;17Hfloat   cmd_col_time;[7C/* data collection time/image */[20;17Hint     cmd_col_mode;[7C/* 0 = collect time, 1 dose */[21;17Hint     cmd_col_image_number; /* start image number */[22;17Hchar    cmd_col_dir[132];   /* directory for output images */[23;17Hchar    cmd_col_prefix[30]; /* image name prefix */[24;17Hchar    cmd_col_suffix[30]; /* image name suffix */[25;17Hint     cmd_col_adc;[8C/* adc select */[26;17Hint     cmd_col_bin;[8C/* bin select */[27;17Hfloat   cmd_col_xcen;[7C/* x detector center in mm for oblique correction */[1;1H[H[2J[1;1H#ifdef VMS
#define GOOD_STATUS     1
#define BAD_STATUS      2
#else
#define GOOD_STATUS     0
#define BAD_STATUS      1
#endif /* VMS */

#define CCD_N_CTRL[14C"CCD_N_CTRL"

#define CCD_DET_OK[14C0
#define CCD_DET_RETRY[11C1
#define CCD_DET_FATAL[11C2
#define CCD_DET_NOTCONNECTED    3
#define CCD_DET_DISCONNECTED    4

#define CCD_BL_OK[15C10
#define CCD_BL_RETRY[12C11
#define CCD_BL_FATAL[12C12
#define CCD_BL_NOTCONNECTED     13
#define CCD_BL_DISCONNECTED     14

#define MAXREMARK[7C100
#define BLCMDMAX[8C256

struct mdc_command {[27;17Hint     cmd_used;[7C/* 0 if this queue entry unused */[27;17H[H[2J[1;1Hstruct mdc_command {[2;17Hint     cmd_used;[7C/* 0 if this queue entry unused */[3;17Hstruct mdc_command *cmd_next;   /* next command in queue */[4;17Hint     cmd_no;[9C/* the command number/this command */[5;17Hint     cmd_err;[8C/* 1 if there is an error */[6;17Hfloat   cmd_value;      /* a value field, if appropriate */[7;17Hfloat   cmd_col_dist;   /* distance for data collection */[8;17Hfloat   cmd_col_lift;   /* lift value for data collection */[9;17Hfloat   cmd_col_phis;   /* phi start for data collection */[10;17Hfloat   cmd_col_omegas; /* omega start for data collection */[11;17Hfloat   cmd_col_kappas; /* kappa start for data collection */[12;17Hfloat   cmd_col_osc_width;  /* oscillation width/image */[13;17Hint     cmd_col_axis;   /* 1 for phi, 0 for omega */[14;17Hint     cmd_col_newdark;    /* 1 for a new dark current image, else 0 */[15;17Hint     cmd_col_anom;[7C/* 1 for anomalous data */[16;17Hint     cmd_col_wedge;      /* wedge (#frames per batch) size for anom data */[17;17Hint     cmd_col_n_images;   /* number of images to collect */[18;17Hint     cmd_col_n_passes;   /* number of osc passes/image */[19;17Hfloat   cmd_col_time;[7C/* data collection time/image */[20;17Hint     cmd_col_mode;[7C/* 0 = collect time, 1 dose */[21;17Hint     cmd_col_image_number; /* start image number */[22;17Hchar    cmd_col_dir[132];   /* directory for output images */[23;17Hchar    cmd_col_prefix[30]; /* image name prefix */[24;17Hchar    cmd_col_suffix[30]; /* image name suffix */[25;17Hint     cmd_col_adc;[8C/* adc select */[26;17Hint     cmd_col_bin;[8C/* bin select */[27;17Hfloat   cmd_col_xcen;[7C/* x detector center in mm for oblique correction */[1;1H[H[2J[1;17Hint     cmd_col_bin;[8C/* bin select */[2;17Hfloat   cmd_col_xcen;[7C/* x detector center in mm for oblique correction */[3;17Hfloat   cmd_col_ycen;[7C/* y detector center in mm for oblique correction */[4;17Hint     cmd_col_compress;   /* 0 for none, 1 for .Z, 2 for .pck */[5;17Hfloat   cmd_col_dzratio;    /* ratio of 2nd picture expos time to 1st */[6;17Hint     cmd_col_dkinterval; /* interval between darks */[7;17Hint     cmd_col_rep_dark;   /* 1 to repeat darks every darkinterval seconds */[8;17Hint     cmd_col_dk_before;  /* 1 to repeat darks before each run */[9;17Hint     cmd_col_outfile_type;   /* 0 for 16 bit, 1 for 32 bit, 2 for 16 + overflow records */[10;17Hint     cmd_col_no_transform;   /* 1 to not transform data */[11;17Hint     cmd_col_output_raws;    /* 1 to output raws */[12;17Hfloat   cmd_col_step_size;      /* size of step for step/dose mode */[13;17Hfloat   cmd_col_dose_step;      /* dose per step, step/dose mode */[14;17Hfloat   cmd_col_atten_run;      /* attenuator amount for this run */[15;17Hfloat   cmd_col_hslit_run;      /* horiz slit amount for this run */[16;17Hfloat   cmd_col_vslit_run;      /* vertical slit amount for this run */[17;17Hfloat   cmd_col_autoal_run;     /* autoalign every run */[18;17Hfloat   cmd_col_run_wave;[19;17Hint     cmd_col_mad_mode;[7C/* 0 never, 1 per run, 2 per wedge, 3 per nframes */[20;17Hint     cmd_col_mad_nframes;    /* for mode = 3, number of frames between wavelength changes */[21;17Hint     cmd_col_mad_nwave;      /* number of wavelengths */[22;17Hfloat   cmd_col_mad_wavelengths[10];    /* wavelengths */[23;17Hfloat   cmd_col_do_wavelength;  /* used after runs are expanded in the queue */[24;17Hint     cmd_col_remarkc;[8C/* number of remark records */[25;17Hint     cmd_col_restart_run;[12C/* run number for restart */[26;17Hint     cmd_col_restart_image;[10C/* image number for restart */[27;17Hchar    *cmd_col_remarkv[MAXREMARK];  /* pointers to remarks */[1;17H[H[2J[1;17Hint     cmd_col_restart_image;[10C/* image number for restart */[2;17Hchar    *cmd_col_remarkv[MAXREMARK];  /* pointers to remarks */[3;17Hchar    cmd_col_blcmd[BLCMDMAX];[4;16H};

typedef struct mdc_command mdc_command;

enum {[9;9HMDC_COM_EOC = 0,[10;9HMDC_COM_EXIT,[11;9HMDC_COM_CONFIG,[12;9HMDC_COM_STARTUP,[13;9HMDC_COM_ERASE,[14;9HMDC_COM_INIT,[15;9HMDC_COM_STOP,[16;9HMDC_COM_ABORT,[17;9HMDC_COM_DMOVE,[18;9HMDC_COM_PMOVE,[19;9HMDC_COM_PMOVEREL,[20;9HMDC_COM_DSET,[21;9HMDC_COM_PSET,[22;9HMDC_COM_LMOVE,[23;9HMDC_COM_LSET,[24;9HMDC_COM_WMOVE,[25;9HMDC_COM_WSET,[26;9HMDC_COM_SHUT,[27;9HMDC_COM_SCAN,[1;17H[H[2J[1;9HMDC_COM_SHUT,[2;9HMDC_COM_SCAN,[3;9HMDC_COM_OMOVE,[4;9HMDC_COM_OSET,[5;9HMDC_COM_KMOVE,[6;9HMDC_COM_KSET,[7;9HMDC_COM_COLL,[8;9HMDC_COM_SNAP,[9;9HMDC_COM_GONMAN,[10;9HMDC_COM_HOME,[11;9HMDC_COM_AMOVE,[12;9HMDC_COM_AUTOALIGN,[13;9HMDC_COM_XL_HS_MOVE,[14;9HMDC_COM_XL_VS_MOVE,[15;9HMDC_COM_XL_UP_HHS_MOVE,[16;9HMDC_COM_XL_UP_VHS_MOVE,[17;9HMDC_COM_XL_DN_HHS_MOVE,[18;9HMDC_COM_XL_DN_VHS_MOVE,[19;9HMDC_COM_QLIST,[20;9HMDC_COM_QFLUSH,[21;9HMDC_COL_DIST,[22;9HMDC_COL_PHIS,[23;9HMDC_COL_OSCW,[24;9HMDC_COL_NIM,[25;9HMDC_COL_DEZING,[26;9HMDC_COL_TIME,[27;9HMDC_COL_IMNO,[1;9H[H[2J[1;9HMDC_COL_TIME,[2;9HMDC_COL_IMNO,[3;9HMDC_COL_DIR,[4;9HMDC_COL_PRE,[5;9HMDC_COL_SUF,[6;9HMDC_COL_MODE,[7;9HMDC_COL_WAVE,[8;9HMDC_COL_REMARK,[9;9HMDC_COL_LIFT,[10;9HMDC_COL_ADC,[11;9HMDC_COL_BIN,[12;9HMDC_COL_CENTER,[13;9HMDC_COL_KSTART,[14;9HMDC_COL_OSTART,[15;9HMDC_COL_AXIS,[16;9HMDC_COL_NDARK,[17;9HMDC_COL_ANOM,[18;9HMDC_COL_WEDGE,[19;9HMDC_COL_COMPRESS,[20;9HMDC_COL_BLCMD,[21;9HMDC_COL_DZRATIO,[22;9HMDC_COL_DKIVAL,[23;9HMDC_COL_DKREP,[24;9HMDC_COL_DKBEF,[25;9HMDC_COL_OFILE,[26;9HMDC_COL_NO_TRANSFORM,[27;9HMDC_COL_OUTPUT_RAWS,[1;9H[H[2J[1;9HMDC_COL_NO_TRANSFORM,[2;9HMDC_COL_OUTPUT_RAWS,[3;9HMDC_COL_STEP_SIZE,[4;9HMDC_COL_DOSE_STEP,[5;9HMDC_COL_MAD,[6;9HMDC_COL_MAD_WAVE,[7;9HMDC_COL_RESTART_RUN,[8;9HMDC_COL_RESTART_IMAGE,[9;9HMDC_COL_ATTEN_RUN,[10;9HMDC_COL_AUTOAL_RUN,[11;9HMDC_COL_HSLIT_RUN,[12;9HMDC_COL_VSLIT_RUN[13;9H};

#define MAXQUEUE[8C100

#define MAX_CMD[9C16

/*
 *      These are defines which are common to all
 *      scanners.  They form the first level
 *      initialization to the programs specific
 *      scanner variables.  These values may be
 *      overridden by a user supplied configuration
 *      table.
 */[1;9H[H[2J[1;2H*/

#define SPECIFIC_PHI_STEPS_DEG  (500)
#define SPECIFIC_DIST_STEPS_MM  (100)
#define SPECIFIC_PHI_TOP_SPEED  (2000)
#define SPECIFIC_DIST_TOP_SPEED (1000)
#define SPECIFIC_DIST_MAX_POINT (42500)
#define SPECIFIC_DIST_MIN_POINT (6500)
#define SPECIFIC_UNITS_PER_SEC  (1000)
#define SPECIFIC_UNITS_PER_DOSE (1000)
#define SPECIFIC_WAVELENGTH     (1.5418)
#define SPECIFIC_IS_DIST[8C(1)
#define SPECIFIC_IS_PHI[9C(1)
#define SPECIFIC_MULTIPLIER     (4.)
#define SPECIFIC_FLAGS[10C(0)
#define SPECIFIC_LIFT_STEPS_MM  (100)
#define SPECIFIC_LIFT_TOP_SPEED (1000)
#define SPECIFIC_LIFT_MAX_POINT (15000)
#define SPECIFIC_LIFT_MIN_POINT (0)
#define SPECIFIC_IS_LIFT[8C(0)

#define SPECIFIC_NC_POINTER     (0)
#define SPECIFIC_NC_INDEX[7C(0)
#define SPECIFIC_NC_X[11C(0)
#define SPECIFIC_NC_Y[11C(0)
#define SPECIFIC_NC_REC[9C(0)
#define SPECIFIC_NC_POFF[8C(0)[1;2H[H[2J[1;1H#define SPECIFIC_NC_REC[9C(0)
#define SPECIFIC_NC_POFF[8C(0)

#define SPECIFIC_SCSI_ID[8C(2)
#define SPECIFIC_SCSI_CONTROLLER[8C(0)
#define SPECIFIC_SPIRAL_CHECK   (1)

#define SPECIFIC_READ_FAST      (2.2)
#define SPECIFIC_READ_SLOW      (8.7)
#define SPECIFIC_READ_OVERHEAD  (1.0)
#define SPECIFIC_BIN_FACTOR     (2.7)
#define SPECIFIC_IS_KAPPA[7C(0)
#define SPECIFIC_IS_OMEGA[7C(0)
#define SPECIFIC_DEF_DEZINGER   (0)
#define SPECIFIC_IS_2THETA      (0)
#define SPECIFIC_PCSHUTTER      (0)
#define SPECIFIC_DARK_INTERVAL  (0)
#define SPECIFIC_PIXEL_SIZE     (0.085)
#define SPECIFIC_DK_BEFORE_RUN  (1)
#define SPECIFIC_OUTFILE_TYPE   (0)
#define SPECIFIC_DETECTOR_SN    (-1)
#define SPECIFIC_NO_TRANSFORM   (0)
#define SPECIFIC_OUTPUT_RAWS    (0)
#define SPECIFIC_J5_TRIGGER     (0)
#define SPECIFIC_TIMECHECK      (0)
#define SPECIFIC_CONSTRAIN_OMEGA[8C(360)
#define SPECIFIC_CONSTRAIN_PHI[10C(360)[1;1H[H[2J[1;1H#define SPECIFIC_CONSTRAIN_OMEGA[8C(360)
#define SPECIFIC_CONSTRAIN_PHI[10C(360)
#define SPECIFIC_CONSTRAIN_KAPPA[8C(360)
#define SPECIFIC_STRIP_AVE      (0)
#define SPECIFIC_BCHK_TIME      (2.)
#define SPECIFIC_BCHK_DELTAPHI  (0.1)
#define SPECIFIC_IS_WAVELENGTH  (0)
#define SPECIFIC_APPROACH_START (0.0)
#define SPECIFIC_CHIP_SIZE_X      (1152)
#define SPECIFIC_CHIP_SIZE_Y      (1152)
#define SPECIFIC_KAPPA_CONST    (50.0)
#define SPECIFIC_MADRUN_NAMING  (0)
#define SPECIFIC_RETRYSHORT     (0)
#define SPECIFIC_CCD_MODULAR    (0)
#define SPECIFIC_PF_MOD[9C(0)
#define SPECIFIC_MIN_VELOCITY   (.0001)
#define SPECIFIC_MAX_VELOCITY   (100.0)
#define SPECIFIC_ALLOW_STILLS   (0)
#define SPECIFIC_PITCH_TUNE_DELTA (0)
#define SPECIFIC_BM8_MOD[8C(0)

/*
 *      These are scanner specific values, in the
 *      sense that they differ from TYPE of scanner.
 *
 *      They form the first level initialization to
 *      the programs specific scanner variables.[1;1H[H[2J[1;2H*      They form the first level initialization to
 *      the programs specific scanner variables.
 *      These values may be overridden by a user
 *      supplied configration file.
 *
 *      Possible defines: (ONLY one may be defined)
 *
 *      #define SCANNER_TYPE_BIG_BIG    1
 *      #define SCANNER_TYPE_SMALL_HOLE 1
 */

#define SCANNER_TYPE_SMALL_HOLE 1

#ifdef SCANNER_TYPE_BIG_BIG

#define SPECIFIC_ERASE_TIME[13C(40.)
#define SPECIFIC_SCAN_TIME[14C(136.)
#define SPECIFIC_DC_ERASE_TIME[10C(70.)
#define SPECIFIC_TOTAL_VALID_BLOCKS     (11952)
#define SPECIFIC_TOTAL_PIXELS_X[9C(2000)
#define SPECIFIC_TOTAL_PIXELS_Y[9C(2000)

#endif /* SCANNER_TYPE_BIG_BIG */

#ifdef SCANNER_TYPE_SMALL_HOLE

#define SPECIFIC_ERASE_TIME[13C(34.)[1;2H[H[2J[2;1H#define SPECIFIC_ERASE_TIME[13C(34.)
#define SPECIFIC_SCAN_TIME[14C(100.)
#define SPECIFIC_DC_ERASE_TIME[10C(39.)
#define SPECIFIC_TOTAL_VALID_BLOCKS     (4224)
#define SPECIFIC_TOTAL_PIXELS_X[9C(1200)
#define SPECIFIC_TOTAL_PIXELS_Y[9C(1200)

#endif /* SCANNER_TYPE_SMALL_HOLE */

#ifdef SCANNER_TYPE_SMALL

#define SPECIFIC_ERASE_TIME[13C(34.)
#define SPECIFIC_SCAN_TIME[14C(75.)
#define SPECIFIC_DC_ERASE_TIME[10C(54.)
#define SPECIFIC_TOTAL_VALID_BLOCKS     (4352)
#define SPECIFIC_TOTAL_PIXELS_X[9C(1200)
#define SPECIFIC_TOTAL_PIXELS_Y[9C(1200)
#define SPECIFIC_MULTIPLIER[13C(4.)

#endif /* SCANNER_TYPE_SMALL */
^[]0;capel@8bmserver1:/usr/local/ccd_dist/src_std/ccd_dc_api_mad_x8c^G[root@8bmserver1 ccd_dc_api_mad_x8c]# cat c [23;1Hcd_dc_glob.c
#include[8C"ccd_dc_defs.h"

char ifname[256];[7C/* translated command file name */
char ofname[256];[7C/* translated output file name */[1;1H[H[2J[1;1Hchar ifname[256];[7C/* translated command file name */
char ofname[256];[7C/* translated output file name */
char sfname[256];[7C/* translated status file name */
char simdir[256];[7C/* translated directory name for fake images */
char xfcmdn[256];[7C/* ip_xform command name */
char lfname[256];[7C/* for logging important hardware messages */
char confname[256];     /* configuration file name */
char profname[256];     /* profile file name */

char fname_lead[256];   /* leading part of output images */
char fname_dir[256];    /* the directory part */
char scan_dir[256];     /* used to store the spiral files */
char scan_dir_export[256];      /* used to store the spiral files with exported NFS directory name of scan_dir */[14;1Hchar spiralfilename[512];[7C/* used to contain spiral file name */
char spiralfilename_export[512];[8C/* exported spiral file name */
char cartimagename[512];[8C/* what the spiral file will transform to */

int     fdcom;[10C/* file (socket) desc for command */
int     fdout;[10C/* file (socket) desc for output */
FILE    *fpout;[9C/* file pointer for output */
int     fdstat;[9C/* file (socket) desc for status */
int     fdxfcm;[9C/* file (socket) desc for transform */
FILE    *fplog;[9C/* log file for useful info */
FILE    *fpconfig;      /* file pointer for config file */
FILE    *fprun;[9C/* used in run file generation */
int     fddetcmd;[7C/* detector process command socket */
int     fddetstatus;    /* detector process status socket */[1;1H[H[2J[1;1Hint     fddetcmd;[7C/* detector process command socket */
int     fddetstatus;    /* detector process status socket */
int     fdblcmd;[8C/* beamline process command socket */
int     fdblstatus;     /* beamline process status socket */

int     fposcom;[8C/* current file position for command */
int     fposout;[8C/* current file position for output */
int     fposstat;[7C/* current file position for status */
int     detector_sn;    /* serial number of the detector, if known */
int     output_raws;    /* 1 to output raws */
int     no_transform;   /* 1 to do no transform on line */
int     constrain_omega;[8C/* 0 for don't care, 180 for -180:180, 360 (def) for 0-360 */
int     constrain_phi;[10C/* 0 for don't care, 180 for -180:180, 360 (def) for 0-360 */
int     constrain_kappa;[8C/* 0 for don't care, 180 for -180:180, 360 (def) for 0-360 */

FILE    *fpnull;[8C/* /dev/null */
int     dc_in_progress; /* Set when data collection is in progress */

char *trntable = LOGICAL_NAME_TABLE;    /* Essentially for VMS */

mdc_command     mdc_queue[MAXQUEUE];    /* queue of scanner commands */
mdc_command     *mdc_head;[14C/* points to first queue member */
mdc_command     mdc_current;[12C/* current command being executed */

/*
 *      Scanner status information.
 */[1;1H[H[2J[1;2H*      Scanner status information.
 */

float   stat_dist;[14C/* current distance */
float   stat_phi;[15C/* current phi */
float   stat_lift;[14C/* current lift */
float   stat_omega;[13C/* current omega */
float   stat_kappa;[13C/* current kappa */
float   stat_start_phi;[9C/* starting phi value for this scan */
float   stat_start_omega;[7C/* starting omega */
float   stat_start_kappa;[7C/* strting kappa */
float   stat_osc_width;[9C/* oscillation range */
float   stat_time;[14C/* exposure time */
float   stat_intensity;[9C/* intensity reading from mar */
float   stat_wavelength;[8C/* wavelength */
float   stat_multiplier;[8C/* scanner specific multiplier factor */
int     stat_axis;[14C/* 1 for phi, 0 for omega */
int     stat_mode;[14C/* 0 for time mode, 1 for dose mode */
int     stat_max_count;[9C/* maximum counts in an exposure */
int     stat_n_images;[10C/* number of images in this collection */
int     stat_n_passes;[10C/* number of passes per image */
int     stat_n_mdc_updates;     /* number of times mdc has update stat file */
int     stat_n_ccd_updates;     /* number of times ccd_dc has updated its OWN status file */
int     stat_image_number;      /* used to keep track of the current image number */
int     stat_adc;[15C/* adc value (slow=0, fast = 1) */
int     stat_bin = 0;[11C/* 1 for 1x1, 2 for 2x2 binning */
char    stat_dir[80];[11C/* directory for collecting data */[1;2H[H[2J[1;1Hint     stat_bin = 0;[11C/* 1 for 1x1, 2 for 2x2 binning */
char    stat_dir[80];[11C/* directory for collecting data */
char    stat_prefix[890];[7C/* code name + encoded run number */
char    stat_fname[80];[9C/* current file name */
char    stat_scanner_op[80];    /* scanner operation in progress */
char    stat_scanner_msg[80];   /* any useful scanner message */
char    stat_scanner_control[80];  /* control state */
char    stat_scanner_shutter[80];  /* state of the shutter */
char    stat_mode_msg[80];      /* collection mode: dose or time */
float   stat_xcen;[14C/* x beam center in mm for oblique correction */
float   stat_ycen;[14C/* y beam center in mm for oblique correction */
float   stat_2theta;[12C/* two theta of the detector */
int     stat_compress;[10C/* 0 for none, 1 for .Z 2 for .pck */
int     stat_anom;[14C/* 1 for anomalous, else 0 */
int     stat_wedge;[13C/* number of frames per anom mini-run */
float   stat_dzratio = 1.0;     /* ratio of 2nd/1st image expos time/dezingering */
float   stat_step_size;[9C/* step size for step/dose mode */
float   stat_dose_step;[9C/* dose per step for step/dose mode */
float   stat_attenuator;[8C/* attenuator amount */
float   stat_hslit;[13C/* horiz slit amount */
float   stat_vslit;[13C/* vertical slit amount */
float   min_velocity;[11C/* min data collection velocity */
float   max_velocity;[11C/* max data collection velocity */
int     allow_stills;

/*
 *      Simulation timing and control.[1;1H[H[2J[1;1H/*
 *      Simulation timing and control.
 */

int     use_pc_shutter;
int     use_j5_trigger;
int     use_timecheck;
int     sim_cmd_ticks;[10C/* when goes to zero, the command is done */

int     tick;[11C/* used for clock counting */
int     units;[10C/* used for calculating percentage completion */
int     decrement;      /* used for pseudo-timing of things */
int     dcop;[11C/* software state used for collect & scan */
int     retrycnt;[7C/* retry count for hardware faults */
int     msign;[10C/* used in calculations */
float   start_val;      /* used in calculations */
float   delta;[10C/* ditto */
int     totimg;[9C/* used for deciding when data collection done */
int     totpass;[8C/* same, only for multiple passes in a single osc */
int     dc_abort;[7C/* signals a data collection abort */
int     dc_stop;[8C/* signals a stop after current exposure */
int     command_rejected;[7C/* 1 if the command was rejected by ccd_hw_start */
int     dc_abort_ctr;   /* used during the abort procedure */
int     dc_error_rec;   /* used during data collection error recovery */
char    mdc_alert[80];  /* used to signal a hardware alert */

char    *mdc_comlit[] = {[1;1H[H[2J[2;1Hchar    *mdc_comlit[] = {[3;25H"eoc",[4;25H"exit",[5;25H"config",[6;25H"startup",[7;25H"erase",[8;25H"initialize",[9;25H"stop",[10;25H"abort",[11;25H"distance_move",[12;25H"phi_move",[13;25H"phi_move_rel",[14;25H"distance_set",[15;25H"phi_set",[16;25H"lift_move",[17;25H"lift_set",[18;25H"wavelength_move",[19;25H"wavelength_set",[20;25H"shutter",[21;25H"scan",[22;25H"omega_move",[23;25H"omega_set",[24;25H"kappa_move",[25;25H"kappa_set",[26;25H"collect",[27;25H"snap",[1;1H[H[2J[1;25H"collect",[2;25H"snap",[3;25H"gon_manual",[4;25H"home",[5;25H"attenuate",[6;25H"autoalign",[7;25H"xl_hs_move",[8;25H"xl_vs_move",[9;25H"xl_up_hhs_move",[10;25H"xl_up_vhs_move",[11;25H"xl_dn_hhs_move",[12;25H"xl_dn_vhs_move",[13;25H"queue_list",[14;25H"queue_flush",[15;25H"distance",[16;25H"phi_start",[17;25H"osc_width",[18;25H"n_images",[19;25H"de_zinger",[20;25H"time",[21;25H"image_number",[22;25H"directory",[23;25H"image_prefix",[24;25H"image_suffix",[25;25H"mode",[26;25H"wavelength",[27;25H"remark",[1;25H[H[2J[1;25H"wavelength",[2;25H"remark",[3;25H"lift",[4;25H"adc",[5;25H"bin",[6;25H"center",[7;25H"kappa_start",[8;25H"omega_start",[9;25H"axis",[10;25H"newdark",[11;25H"anomalous",[12;25H"wedge",[13;25H"compress",[14;25H"blcmd",[15;25H"dzratio",[16;25H"darkinterval",[17;25H"repeat_dark",[18;25H"dk_before_run",[19;25H"outfile_type",[20;25H"no_transform",[21;25H"output_raw",[22;25H"step_size",[23;25H"dose_per_step",[24;25H"mad",[25;25H"mad_wave",[26;25H"restart_run",[27;25H"restart_image",[1;25H[H[2J[1;25H"restart_run",[2;25H"restart_image",[3;25H"atten_run",[4;25H"autoal_run",[5;25H"hslit_run",[6;25H"vslit_run",[7;25HNULL[8;25H};

/*
 *      Variables which apply to both simulated and actual
 *      hardware operation.
 */

int     mdc_cmd_active;[17C/* 1 if we have an active command */
int     mdc_simulation;[17C/* 1 if simulation, 0 if actual hardware */
int     raw_ccd_image = 0;[14C/* 1 if doing calibration, else 0 */
int     repeat_dark_current = 0;[8C/* 1 if doing repeated dark currents, else 0 */
int     dark_current_interval = 0;      /* interval in sec for recollect dark currents */
int     dark_current_time = 0;[10C/* time function value for last dark current */
int     pixel_size;
int     dk_before_run;[18C/* 1 for dark current repeat before a run */
int     strip_ave;[22C/* 1 to use strip averages for dark pedistal renorm in xform */

int     n_ctrl;[25C/* number of controllers */
int     n_strip_ave;[20C/* number of returned strip_ave values */
float   strip_ave_vals[4];[14C/* their values */[1;25H[H[2J[1;1Hint     n_strip_ave;[20C/* number of returned strip_ave values */
float   strip_ave_vals[4];[14C/* their values */

int     (*mdc_cmd_start)();[13C/* function which starts commands */
int     (*mdc_cmd_progress)();[10C/* function checking progress */

int     fdmar;[18C/* file descriptor for mar */
struct  esd_status_block rs;    /* raw sataus block */
float   dt_stat;[16C/* number of seconds per status update */
float   kappa_const;[12C/* kappa goniostat constant, usually about 50 degrees */

/*
 *      Hardware scanner status.
 */

int     active[MAX_CMD];
int     started[MAX_CMD];
int     queued[MAX_CMD];
int     all_done[MAX_CMD];
int     aborted[MAX_CMD];
int     c_error[MAX_CMD];
short   last_valid_data;
short   last_command;
int     mains_active;
int     hv_on;
int     open_xray_shutter;
int     xray_shutter_open;[1;1H[H[2J[1;1HScript started on Thu Sep 26 13:14:13 2002
[ccdsys@6accd ccd_dc_api_mad_x8c]$ telnet 154.^H ^H^H ^H^H ^H64.54.152.287^H ^H^H ^H^H ^H80
Trying 164.54.152.80...

[ccdsys@6accd ccd_dc_api_mad_x8c]$ telnet chem.ucd^H ^Hsd.edu
Trying 132.239.68.1...
Connected to chem.ucsd.edu.
Escape character is '^]'.


SunOS 5.8

login: cn
Password:
Last login: Wed Sep 25 20:45:32 from 130.87.176.110
^[>^[[1;3;4;5;6l^[[?7h^[[m^[[r^[[2J^[[H@^[[H^[[2JSun Microsystems Inc.      SunOS 5.8[7CGeneric February 2000[17;1Hcn sun1:1>ssh -l capel ^[[13D^[[Kssh capel@164.54.152.80
Host key not found from database.
Key fingerprint:
xofih-kazip-pudeh-mumuf-mipas-kysup-pugec-rogop-rysyl-pevev-rexyx
You can get a public key's fingerprint by running
% ssh-keygen -F publickey.pub
on the keyfile.
Are you sure you want to continue connecting (yes/no)? ^[[?1h^[=^[[@y^[[2@es^[[?1l^[>
Host key saved to /home/research/xuong/cn/.ssh2/hostkeys/key_22_164.54.152.80.pub
host key for 164.54.152.80, accepted by cn Wed Sep 25 2002 20:01:18 -0800
capel's password:[1;1H[28;1H/cat[1;27r[1;1H[2M[1;28r[26;1Hcapel's password:
Authentication successful.[28;1H[K[27;9H
/cat[H[2J[1;1H-rw-r--r--    1 1115     103[9C19780 Apr 18 18:21 ^[[00mccd_server.c^[[00m
-rw-r--r--    1 1115     103[10C4604 Apr 18 18:40 ^[[00mccd_dc_bl.c^[[00m
-rw-r--r--    1 1115     103[10C1315 Apr 18 19:22 ^[[00mget_attenuator.c^[[00m
-rw-r--r--    1 1115     103[9C22959 Apr 18 20:43 ^[[00mccd_dc_input.c^[[00m
-rw-r--r--    1 1115     103[10C8100 Apr 24 18:51 ^[[00mccd_dc_seq.c^[[00m
-rw-r--r--    1 1115     103[10C9363 Apr 24 18:52 ^[[00mccd_dc_seq_nowork.c^[[00m
-rw-r--r--    1 1115     103[9C23181 May 20 23:55 ^[[00mccd_dc_strstat.c^[[00m
-rw-r--r--    1 1115     103[10C9357 Aug 13 09:08 ^[[00mccd_dc_defs.h^[[00m
-rw-r--r--    1 1115     103[9C17755 Aug 13 09:08 ^[[00mccd_dc_glob.c^[[00m
-rw-r--r--    1 1115     103[10C9785 Aug 13 09:09 ^[[00mccd_dc_ext.h^[[00m
-rw-r--r--    1 1115     103[9C42943 Aug 13 09:12 ^[[00mccd_dc_misc.c^[[00m
-rw-r--r--    1 1115     103[9C51448 Aug 14 13:11 ^[[00mccd_dc_hw.c^[[00m
^[[m^[]0;capel@8bmserver1:/usr/local/ccd_dist/src_std/ccd_dc_api_mad_x8c^G[root@8bmserver1 ccd_dc_api_mad_x8c]# c [14;1Hat ^H^H^H^H^[[Km^H^[[Kcat ccd_dc_defs.h
#include[8C<stdio.h>
#include[8C"../incl/ccdconv.h"
#include[8C"../incl/esd.h"
#include[8C"../incl/esd_com.h"
#include[8C"../incl/ccddefs.h"
#include[8C"../incl/ccdsys.h"
#include[8C<errno.h>
#include[8C<signal.h>
#include[8C<math.h>

#ifndef VMS
#include[8C<sys/types.h>
#include[8C<sys/time.h>[13;113H[28;1H/cat[7mWarning: File "malcolm" has changed since editing started[14;23H[m[28;1H[K[28;1H:q![?1l>[2J[?47l8[J[ccdsys@6accd ccd_dc_api_mad_x8c]$ exit
exit

Script done on Thu Sep 26 13:20:53 2002
