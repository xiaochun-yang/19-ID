/*
 * Generated by the ICS builderXcessory (BX).
 *
 *
 * Builder Xcessory 3.0.
 *
 */
#include <Xm/Xm.h>
#include <Xm/Text.h>
#include <Xm/TextF.h>
#include <Xm/FileSB.h>
#include <X11/keysym.h> 
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <unistd.h>
#include "param_gui.h"

#define DECLARE_ADX_GLOBALS

#include "adx.h"

#undef DECLARE_ADX_GLOBALS

static char Copyright[] = "Copyright (C) 1994-1997 Area Detector Systems Corporation, Andrew Steven Arvai";

#define EV_ANGSTROM     (12398.4243)

/*
 * Standard includes for builtins.
 */
#include <string.h>
#include <ctype.h>
#include "creation-c.h"

/*
 * Macros to make code look nicer between ANSI and K&R.
 */
#ifndef ARGLIST
#if (NeedFunctionPrototypes == 0)
#define PROTOTYPE(p)	()
#define ARGLIST(p)	p
#define ARG(a, b)	a b;
#define GRA(a, b)	a b;
#define UARG(a, b)      a b;
#define GRAU(a, b)      a b;
#else
#define PROTOTYPE(p)	p
#define ARGLIST(p)	(
#define ARG(a, b)	a b,
#define GRA(a, b)	a b)
#ifdef __cplusplus
#define UARG(a, b)      a,
#define GRAU(a, b)      a)
#else
#define UARG(a, b)      a b,
#define GRAU(a, b)      a b)
#endif
#endif
#endif

Widget		BxFindTopShell PROTOTYPE((Widget));
WidgetList	BxWidgetIdsFromNames PROTOTYPE((Widget, char*, char*));


/*      Function Name:	BxExitCB
 *
 *      Description:   	This functions expects an integer to be passed in
 *		       	client data.  It calls the exit() system call with
 *			the integer value as the argument to the function.
 *
 *      Arguments:      Widget		w: 	the activating widget.
 *			XtPointer	client:	the integer exit value.
 *			XtPointer	call:	the call data (unused).
 */

/* ARGSUSED */
void
BxExitCB ARGLIST((w, client, call))
UARG( Widget, w)
ARG( XtPointer, client)
GRAU( XtPointer, call)
{
	/*int		exitValue = (int)client;*/
	Window window;
	int dest_x=47, dest_y=114;
	static int init=0;
	Arg args[4];
	Dimension m_XmNx, m_XmNy, m_XmNwidth, m_XmNheight;
    
	if (!init) {
		init=1;
		XtSetArg(args[0], XmNx, 500);
		XtSetArg(args[1], XmNy, 500);
		XtSetValues(exitDialog,args,2);
	}

	raise_window(exitDialog);
	window  = XtWindow(exitDialog);

	/*
	XtSetArg(args[0], XmNx, &m_XmNx);
	XtSetArg(args[1], XmNy, &m_XmNy);
	XtSetArg(args[2], XmNwidth, &m_XmNwidth);
	XtSetArg(args[3], XmNheight, &m_XmNheight);
	XtGetValues(pushButton220, args, 4);
	*/
	XtVaGetValues(pushButton220,
		XmNx, &m_XmNx,
		XmNy, &m_XmNy,
		XmNwidth, &m_XmNwidth,
		XmNheight, &m_XmNheight,
		NULL);

	dest_x = m_XmNx + m_XmNwidth/2;
	dest_y = m_XmNy + m_XmNheight/2;

	/*XWarpPointer(display, None, window, 0, 0, 0, 0, dest_x, dest_y);*/
	
	XWarpPointer(display, None, XtWindow(pushButton220),
		0, 0, 0, 0, m_XmNwidth/2, m_XmNheight/2);
	
}

/* ARGSUSED */
void
collect_activateCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	static int init=0;
	Arg args[2];
	char *runstr, *directory, *prefix, *str;

	if (debug) {
		fprintf(stderr,"Called collect_activateCallback\n");
		fflush(stderr);
	}

	/* Update Project Window */
	str = XmTextFieldGetString(strategy_directory_textField);
	XmTextFieldSetString(project_data_dir_textField,str);
	XtFree(str);

	str = XmTextFieldGetString(strategy_image_prefix_textField);
	XmTextFieldSetString(project_i_prefix_textField,str);
	XtFree(str);

	if (!init) {
		init=1;
		XtSetArg(args[0], XmNx, 500);
		XtSetArg(args[1], XmNy, 500);
		XtSetValues(stopDialog,args,2);
	}
    
	directory = XmTextFieldGetString(strategy_directory_textField);
	prefix =    XmTextFieldGetString(strategy_image_prefix_textField);

	if (XmToggleButtonGetState(strategy_time_mode_toggleButton) == True)
		image_collect_mode = TIME_MODE; 
	else
	if (XmToggleButtonGetState(strategy_dose_mode_toggleButton) == True)
		image_collect_mode = DOSE_MODE; 
	else {
		fprintf(stderr,"ERROR: no time/dose mode set in RUN(S)...\n");
		fflush(stderr);
		image_collect_mode = TIME_MODE;
	}

	if (XmToggleButtonGetState(strategy_fast_toggleButton) == True)
		image_adc_mode = 1; 
	else
	if (XmToggleButtonGetState(strategy_slow_toggleButton) == True)
		image_adc_mode = 0; 
	else {
		fprintf(stderr,"ERROR: no adc mode set in RUN(S)...\n");
		fflush(stderr);
		image_adc_mode = 0;
	}

	if (XmToggleButtonGetState(options_output16_toggleButton) == True) {
		if (XmToggleButtonGetState(options_outputsmv_toggleButton) == True) 
			outfile_type = 0; 
		else
			outfile_type = 8; 
	}
	else
	if (XmToggleButtonGetState(options_output32_toggleButton) == True) {
		if (XmToggleButtonGetState(options_outputsmv_toggleButton) == True) 
			outfile_type = 1;
		else
			outfile_type = 9;
	}
	else {
		fprintf(stderr,"Warning: Unknown output format. Using 16 + overflow\n");
		fflush(stderr);
		outfile_type = 2;
	}

	if (XmToggleButtonGetState(strategy_bin1_toggleButton) == True)
		image_bin_mode = 1; 
	else
	if (XmToggleButtonGetState(strategy_bin2_toggleButton) == True)
		image_bin_mode = 2; 
	else {
		fprintf(stderr,"ERROR: no bin mode set in RUN(S)...\n");
		fflush(stderr);
		image_bin_mode = 1;
	}

	if (XmToggleButtonGetState(options_xform_yes) == True)
		xform_mode = 1; 
	else
	if (XmToggleButtonGetState(options_xform_no) == True)
		xform_mode = 0; 
	else {
		fprintf(stderr,"ERROR: no xform mode set in RUN(S)...\n");
		fflush(stderr);
		xform_mode = 1;
	}

	if (XmToggleButtonGetState(options_saveraw_yes) == True)
		saveraw_mode = 1; 
	else
	if (XmToggleButtonGetState(options_saveraw_no) == True)
		saveraw_mode = 0; 
	else {
		fprintf(stderr,"ERROR: no saveraw mode set in RUN(S)...\n");
		fflush(stderr);
		saveraw_mode = 0;
	}

	if (XmToggleButtonGetState(strategy_comp_none_toggleButton) == True)
		image_compression = COMP_NONE;
	else
	if (XmToggleButtonGetState(strategy_comp_Z_toggleButton) == True)
		image_compression = COMP_Z;
	else
	if (XmToggleButtonGetState(strategy_comp_pck_toggleButton) == True)
		image_compression = COMP_PCK;
	else {
		fprintf(stderr,"ERROR: no compression mode set in RUN(S)...\n");
		fflush(stderr);
		image_compression = COMP_NONE;
	}

	strcpy(image_directory, directory);
	mk_directory(image_directory);
	strcpy(image_prefix, prefix);

	/* Remove tailing '_' from image_prefix */
	if (strlen(image_prefix) && image_prefix[strlen(image_prefix)-1] == '_')
		image_prefix[strlen(image_prefix)-1] = 0;

	switch  (image_compression) 
	{
		case COMP_NONE:
			strcpy(image_suffix, "img");
			break;
		case COMP_Z:
			strcpy(image_suffix, "img.Z");
			break;
		case COMP_PCK:
			strcpy(image_suffix, "img.pck");
			break;
		default:
			strcpy(image_suffix, "img");
			break;
	}
			
	if (debug) {
		fprintf(stderr,"Directory: %s\n",directory);
		fprintf(stderr,"Image Prefix %s\n",prefix);
	}

	if (iswhite(directory)) {
		sprintf(error_msg,"\nNo Directory.\n\nAborting Collect.");
		post_error(error_msg);
		return;
	}
	if (!is_writable(directory)) {
		sprintf(error_msg,"\nDirectory \"%s\" is not writable.\n\nAborting Collect.",
			directory);
		post_error(error_msg);
		return;
	}

	if (iswhite(prefix)) {
		sprintf(error_msg,"\nNo Image Prefix.\n\nAborting Collect.");
		post_error(error_msg);
		return;
	}

	if (debug) {
		fprintf(stderr,"Mode: %s\n",image_collect_mode==TIME_MODE?"Time":"Dose");
		fprintf(stderr,"Compression: %s\n",
			image_compression==COMP_NONE?"None":image_compression==COMP_Z?".Z":".pck");
	}

	runstr = (char *)XmTextGetString(runtext);
	if (debug) {
		fprintf(stderr,"Called collect_runs:\"%s\"\n",runstr);
		fflush(stderr);
	}

#ifdef CHECK_WEAK_BEAM
	if (beam_intensity < WEAK_BEAM) {
   		XmString xmstr;
		char beam_str[32];

		sprintf(beam_str,"%1.2f",beam_intensity);
		xmstr = XmStringCreateSimple(beam_str);
		XtSetArg(args[0], XmNlabelString, xmstr);
		XtSetValues(weakbeam_label2,args,1);
    		XmStringFree(xmstr);
		raise_window(weakbeamDialog);
	}
	else
#endif /* CHECK_WEAK_BEAM */
		collect_runs(runstr);
	XtFree(runstr);

	XtFree(directory);
	XtFree(prefix);
}

#ifdef OLD_JUNK
/* ARGSUSED */
void
show_messages_callback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	static int init=0;
	if (!init) {
		init=1;
		XmTextInsert(messageWindow_text,0,
"These are some messages written to the message window...\n\
\n\
     The image plate is collecting data...\
");
	}
	if (message_dialog_up) {
		message_dialog_up = 0;
		XtUnmanageChild(messageDialog);
	}
	else {
		raise_window(messageDialog);
		message_dialog_up = 1;
	}

}
/* ARGSUSED */
void
message_unmapCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	Arg args[1];

	if (message_dialog_up == 1) {
		message_dialog_up = 0;
		XtSetArg(args[0], XmNset, False);
		XtSetValues(messageButton,args,1);
	}
}
#endif /* OLD_JUNK */

/* ARGSUSED */
void
snap_callback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	char *directory, *image;
	double phi, distance, offset, exposure_time;
	int i, image_number;
	char buf[1024];
	char orig_image[256];
	/*static int start_adxv;*/
	char *centerx_str, *centery_str;
	float center_x, center_y;

	if (debug) {
		fprintf(stderr,"Called snap_callback...\n");
		fflush(stderr);
	}

	if(marcommandfp==NULL){
		fprintf(stderr,"marcommandfp=NULL\n"); fflush(stderr);
		emess("Error: no command file");
		return;
	}

	directory = XmTextFieldGetString(snap_directory_textField);
	if (iswhite(directory)) {
		sprintf(error_msg,"\nNo Directory.\n\nAborting Snapshot.");
		post_error(error_msg);
		return;
	}
	if (!is_writable(directory)) {
		sprintf(error_msg,"\nDirectory \"%s\" is not writable.\n\nAborting Snapshot.",
			directory);
		post_error(error_msg);
		return;
	}

	image =     XmTextFieldGetString(snap_image_textField);

	if (iswhite(image)) {
		sprintf(error_msg,"\nNo Image Prefix.\n\nAborting Snapshot.");
		post_error(error_msg);
		return;
	}

	sprintf(error_msg,"\nImage Prefix must be of the form\n\n    XXXX_YYY\n\nWhere XXXX is any string and YYY is a 3-digit integer.\n\nAborting Snapshot.");

	for(i=strlen(image);i--;) {
		if (!isspace(image[i])) {
			if (!isdigit(image[i])) {
				post_error(error_msg);
				return;
			}
			break;
		}
	}

	strcpy(tmpstr,image);
	strcpy(orig_image,image);
	image_number = get_frame_number(strcat(tmpstr,".img")) ;
	if (image_number < 0) {
		post_error(error_msg);
		return;
	}

	for(i=strlen(image);i--;) {
		if (image[i] == '_') {
			image[i] = 0;
			break;
		}
	}
	if (i < 0) {
		post_error(error_msg);
		return;
	}

	phi = wtof(snap_phi_textField);

	exposure_time = wtof(snap_exposure_time_textField);
	if (exposure_time < 0.0) {
		sprintf(error_msg,"\nBad Value for Exposure Time: %f.\n\nAborting Snapshot.",exposure_time);
		post_error(error_msg);
		return;
	}

	delta_phi = wtof(snap_step_size_textField);

	distance = wtof(snap_distance_textField);
	if ((distance < Limit.distmin) || (distance > Limit.distmax) ) {
		sprintf(error_msg,"\nAttempt to Drive Distance to %1.2f. This value is out of Range.\n\nSnapshot has been aborted.\n\nMinimum Distance: %6.2f\nMaximum Distance: %6.2f",
		distance,Limit.distmin,Limit.distmax);

		post_error(error_msg);
		return;
	}

	offset = wtof(snap_offset_textField);
	if ((offset < Limit.liftmin) || (offset > Limit.liftmax) ) {
		sprintf(error_msg,"\nAttempt to Drive Offset to %1.2f. This value is out of Range.\n\nSnapshot has been aborted.\n\nMinimum Offset: %6.2f\nMaximum Offset: %6.2f",
		offset,Limit.liftmin,Limit.liftmax);

		post_error(error_msg);
		return;
	}

	/*
	fprintf(stderr,"Directory: %s\n",directory);
	fprintf(stderr,"Image: %s\n",image);
	fprintf(stderr,"Phi: %1.2f\n",phi);
	fprintf(stderr,"Exposure Time: %f\n",exposure_time);
	fprintf(stderr,"Step Size: %1.2f\n",delta_phi);
	fprintf(stderr,"Distance: %1.2f\n",distance);
	fprintf(stderr,"Offset: %1.2f\n",offset);
	 */

	if (XmToggleButtonGetState(options_output16_toggleButton) == True) {
		if (XmToggleButtonGetState(options_outputsmv_toggleButton) == True) 
			outfile_type = 0; 
		else
			outfile_type = 8; 
	}
	else
	if (XmToggleButtonGetState(options_output32_toggleButton) == True) {
		if (XmToggleButtonGetState(options_outputsmv_toggleButton) == True) 
			outfile_type = 1;
		else
			outfile_type = 9;
	}
	else {
		fprintf(stderr,"Warning: Unknown output format. Using 16 + overflow\n");
		fflush(stderr);
		outfile_type = 2;
	}


	if (XmToggleButtonGetState(options_xform_yes) == True)
		xform_mode = 1; 
	else
	if (XmToggleButtonGetState(options_xform_no) == True)
		xform_mode = 0; 
	else {
		fprintf(stderr,"ERROR: no xform mode set in RUN(S)...\n");
		fflush(stderr);
		xform_mode = 1;
	}

	if (XmToggleButtonGetState(options_saveraw_yes) == True)
		saveraw_mode = 1; 
	else
	if (XmToggleButtonGetState(options_saveraw_no) == True)
		saveraw_mode = 0; 
	else {
		fprintf(stderr,"ERROR: no saveraw mode set in RUN(S)...\n");
		fflush(stderr);
		saveraw_mode = 0;
	}

	strcpy(image_directory, directory);
	mk_directory(image_directory);
	strcpy(image_prefix, image);
	strcpy(image_suffix, ".img");

	centerx_str = XmTextFieldGetString(strategy_beamx_textField);
	centery_str = XmTextFieldGetString(strategy_beamy_textField);

	if (iswhite(centerx_str) || iswhite(centery_str)) {
		if ((beam_x == 0) && (beam_y == 0)) {
			center_x = sc_conf.pixelsize * sc_conf.pixelsx/2.0 + sc_conf.pixelsize/2.0;
			center_y = sc_conf.pixelsize * (sc_conf.pixelsy/2.0 - 1) + sc_conf.pixelsize/2.0;
		}
		else {
			center_x = beam_x;
			center_y = beam_y;
		}
	}
	else {
		center_x = atof(centerx_str);
		center_y = atof(centery_str);
	}

	XtFree(centerx_str);
	XtFree(centery_str);

	strcpy(buf,"");
	if (exposure_time <= 0) { /* SCAN command */
		marcommand(SCAN, 1.0);
	}
	else
	if (XmToggleButtonGetState(snap_ydc_toggleButton) == True) {

#ifdef CHESS_CCD
		centerx_str = XmTextFieldGetString(strategy_beamx_textField);
		centery_str = XmTextFieldGetString(strategy_beamy_textField);

		/* At CHESS some people may collect data using snapshot
		 */
		if (iswhite(centerx_str) || iswhite(centery_str)) {
			sprintf(error_msg,
				"\nCoordinates of the Beam Center (in mm) MUST be entered in the Run(s) Window.\n\nThese values may be obtained from adxv or denzo.\n\nAborting Snapshot.");
			post_error(error_msg);
			XtFree(centerx_str);
			XtFree(centery_str);
			XtFree(directory);
			XtFree(image);
			return;
		}

		XtFree(centerx_str);
		XtFree(centery_str);
#endif /* CHESS_CCD */



		/* Send a Run (Collect, not Snap) */
		sprintf(buf+strlen(buf), "collect\n");
		sprintf(buf+strlen(buf), "newdark 1\n");
		sprintf(buf+strlen(buf), "distance %1.4f\n", distance);
		sprintf(buf+strlen(buf), "lift %1.4f\n", offset);
		sprintf(buf+strlen(buf), "time %1.4f\n", exposure_time);
		sprintf(buf+strlen(buf), "mode time\n");
#ifdef OLD
		if (sc_conf.usekappa == 1) {
			sprintf(buf+strlen(buf), "axis omega\n");
			sprintf(buf+strlen(buf), "omega_start %1.4f\n", phi);
		}
		else {
			sprintf(buf+strlen(buf), "axis phi\n");
			sprintf(buf+strlen(buf), "phi_start %1.4f\n", phi);
		}
#endif /* OLD */
		if (XmToggleButtonGetState(snap_axisPhi_toggleButton) == True) {
			sprintf(buf+strlen(buf), "axis phi\n");
			sprintf(buf+strlen(buf), "phi_start %1.4f\n", phi);
		}
		else {
			sprintf(buf+strlen(buf), "axis omega\n");
			sprintf(buf+strlen(buf), "omega_start %1.4f\n", phi);
		}

		if(sc_conf.pf_mod)	/* PF Start */
		sprintf(buf+strlen(buf), "wavelength %1.4f\n",wavelength);
			/* PF Finish */
		sprintf(buf+strlen(buf), "osc_width %1.4f\n", delta_phi);
		sprintf(buf+strlen(buf), "n_images %d\n", 1);
		sprintf(buf+strlen(buf), "image_number %d\n", image_number);
		sprintf(buf+strlen(buf), "directory %s\n",image_directory);
		sprintf(buf+strlen(buf), "image_prefix %s\n", image);
		sprintf(buf+strlen(buf), "outfile_type %d\n", outfile_type);
		sprintf(buf+strlen(buf), "output_raw %d\n",saveraw_mode);
		sprintf(buf+strlen(buf), "no_transform %d\n",!xform_mode);

		if (XmToggleButtonGetState(snap_dez_yes_toggleButton) == True)
			sprintf(buf+strlen(buf), "de_zinger 1\n");
		else
			sprintf(buf+strlen(buf), "de_zinger 0\n");

		/*
		sprintf(buf+strlen(buf), "max_deg_step %d\n", TextFieldGetInt(options_step_textField));
		 */

		/*
		if (XmToggleButtonGetState(options_darkrun_toggleButton) == True)
			sprintf(buf+strlen(buf), "dk_before_run %d\n", 1);
		else
			sprintf(buf+strlen(buf), "dk_before_run %d\n", 0);

		if (XmToggleButtonGetState(options_darkinterval_toggleButton) == True)
			sprintf(buf+strlen(buf), "repeat_dark %d\n", 1);
		else {
			sprintf(buf+strlen(buf), "repeat_dark %d\n", 0);
			sprintf(buf+strlen(buf), "darkinterval %d\n",
				TextFieldGetInt(options_darkinterval_textField);
		}
		*/

		sprintf(buf+strlen(buf), "bin %d\n",
			(XmToggleButtonGetState(snap_bin1_toggleButton) == True)?1:2);
		if(sc_conf.t2k_detector == 1)
		{
			if(XmToggleButtonGetState(snap_bin1_toggleButton) == True)
				sprintf(buf+strlen(buf), "adc 0\n");
			else
				sprintf(buf+strlen(buf), "adc %d\n",
					(XmToggleButtonGetState(snap_fast_toggleButton) == True)?1:0);
		}
		else
		{
			sprintf(buf+strlen(buf), "adc %d\n",
				(XmToggleButtonGetState(snap_fast_toggleButton) == True)?1:0);
		}
		sprintf(buf+strlen(buf), "center %f %f\n",center_x,center_y);

		strcat(buf,"eoc\n");

		fputs(buf,marcommandfp);
		fflush(marcommandfp);

		if (debug) {
			fputs(buf,stdout);
			fflush(stdout);
		}
	}
	else {
		sprintf(buf+strlen(buf), "snap\n");
		sprintf(buf+strlen(buf), "distance %1.4f\n", distance);
		sprintf(buf+strlen(buf), "lift %1.4f\n", offset);
		sprintf(buf+strlen(buf), "time %1.4f\n", exposure_time);
		sprintf(buf+strlen(buf), "mode time\n");
#ifdef OLD
		if (sc_conf.usekappa == 1) {
			sprintf(buf+strlen(buf), "axis omega\n");
			sprintf(buf+strlen(buf), "omega_start %1.4f\n", phi);
		}
		else {
			sprintf(buf+strlen(buf), "axis phi\n");
			sprintf(buf+strlen(buf), "phi_start %1.4f\n", phi);
		}
#endif /* OLD */

		if (XmToggleButtonGetState(snap_axisPhi_toggleButton) == True) {
			sprintf(buf+strlen(buf), "axis phi\n");
			sprintf(buf+strlen(buf), "phi_start %1.4f\n", phi);
		}
		else {
			sprintf(buf+strlen(buf), "axis omega\n");
			sprintf(buf+strlen(buf), "omega_start %1.4f\n", phi);
		}
		if(sc_conf.pf_mod)	/* PF Start */
		{
		wavelength = TextFieldGetFloat(wavelength_textField);
		sprintf(buf+strlen(buf), "wavelength %1.4f\n",wavelength);
		}
			/* PF End */
		/*
		if (fabs(delta_phi) < 0.01)
			sprintf(buf+strlen(buf), "osc_width %1.4f\n", 0.01);
		else
		*/
		sprintf(buf+strlen(buf), "osc_width %1.4f\n", delta_phi);
		sprintf(buf+strlen(buf), "n_images %d\n", 1);
		sprintf(buf+strlen(buf), "image_number %d\n", image_number);
		sprintf(buf+strlen(buf), "directory %s\n",image_directory);
		sprintf(buf+strlen(buf), "image_prefix %s\n", image);
		sprintf(buf+strlen(buf), "image_suffix img\n");
		sprintf(buf+strlen(buf), "outfile_type %d\n", outfile_type);
		sprintf(buf+strlen(buf), "output_raw %d\n",saveraw_mode);
		sprintf(buf+strlen(buf), "no_transform %d\n",!xform_mode);

		if (XmToggleButtonGetState(snap_dez_yes_toggleButton) == True)
			sprintf(buf+strlen(buf), "de_zinger 1\n");
		else
			sprintf(buf+strlen(buf), "de_zinger 0\n");

		/*
		sprintf(buf+strlen(buf), "max_deg_step %d\n", TextFieldGetInt(options_step_textField));
		 */

		sprintf(buf+strlen(buf), "bin %d\n",
			(XmToggleButtonGetState(snap_bin1_toggleButton) == True)?1:2);

		if(sc_conf.t2k_detector == 1)
		{
			if(XmToggleButtonGetState(snap_bin1_toggleButton) == True)
				sprintf(buf+strlen(buf), "adc 0\n");
			else
				sprintf(buf+strlen(buf), "adc %d\n",
					(XmToggleButtonGetState(snap_fast_toggleButton) == True)?1:0);
		}
		else
		{
			sprintf(buf+strlen(buf), "adc %d\n",
				(XmToggleButtonGetState(snap_fast_toggleButton) == True)?1:0);
		}
		sprintf(buf+strlen(buf), "center %f %f\n",center_x,center_y);

		strcat(buf,"eoc\n");

		fputs(buf,marcommandfp);
		fflush(marcommandfp);

		if (debug) {
			fputs(buf,stdout);
			fflush(stdout);
		}
	}
	collecting = 1;

	for(i=0; i <= MAX_RUNS; i++) {
		Run[i].nframes = 0;
	}

	/*
	Run[0].number = 0;
	Run[0].start = 1;
	Run[0].nframes = 1;
	Run[0].distance = distance;
	Run[0].offset = offset;
	Run[0].phi = phi;
	Run[0].delta_phi = delta_phi;
	if (exposure_time < 0.01)
		exposure_time = 0.01;
	Run[0].exposure = exposure_time;
	 */


	if (!adxv_running()) {
		/*start_adxv = !start_adxv;*/

		if ((center_x != -1000) && (center_y != 1000)) {
			sprintf(buf,"PWD=%s ; export PWD ; cd %s ; adxv -beam_center %f %f -autoload &",
				directory,directory,center_x,center_y);
		}
		else {
			sprintf(buf,"PWD=%s ; export PWD ; cd %s ; adxv -autoload &",
				directory,directory);
		}
		system(buf);
	}

	next_image(orig_image); /* Increment image # */
	XmTextFieldSetString(snap_image_textField,orig_image);

	phi += delta_phi; /* Increment phi */

	if (sc_conf.constrain_phi == 180) {
		while(current_phi > 180.0)
			current_phi -= 360.0;
		while(current_phi < -180.0)
			current_phi += 360.0;
	}
	else
	if (sc_conf.constrain_phi == 0) {
	}
	else {
		while(current_phi > 360.0)
			current_phi -= 360.0;
		while(current_phi < 0.0)
			current_phi += 360.0;
	}

	TextFieldSetFloat(snap_phi_textField,phi);
	XmToggleButtonSetState(snap_ydc_toggleButton,False,False);
	XmToggleButtonSetState(snap_ndc_toggleButton,True,False);

	XmTextFieldSetString(strategy_directory_textField, directory);

	XtFree(directory);
	XtFree(image);
}

/* ARGSUSED */
void
text_focusCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	if (debug) {
		fprintf(stderr,"Called text_focusCallback()...\n");
		fflush(stderr);
	}

	/*init_text(w);*/
}

/* ARGSUSED */
void
strategy_activateCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	static int init=0;
	char *directory, d[257];
	Arg args[2];


	if (!init) {
		init=1;
		XtSetArg(args[0], XmNx, scr_width + STRATEGYDIALOG_X);
		XtSetArg(args[1], XmNy, STRATEGYDIALOG_Y);
		XtSetValues(strategyDialog,args,2);
	}

	directory = XmTextFieldGetString(strategy_directory_textField);
	if (iswhite(directory)) {
		XtFree(directory);
		directory = XmTextFieldGetString(snap_directory_textField);
		if (iswhite(directory)) {
			getcwd (d, 256);
			XmTextFieldSetString(strategy_directory_textField,d);
		}
		else
			XmTextFieldSetString(strategy_directory_textField,directory);

	}
	XtFree(directory);
	XmTextSetInsertionEnd(strategy_directory_textField);

	/*XtUnmanageChild(strategyDialog);*/
	raise_window(strategyDialog);

	if (beamline_mode==True) {
		Arg  args[1];

		XtSetArg(args[0], XmNwidth, 656+S_WIDTH);
		XtSetValues(scrolledWindow1,args,1);

    		XtSetArg(args[0], XmNresizeWidth, True); 
		XtSetValues(runtext,args,1);
		XtSetArg(args[0], XmNwidth, 637+S_WIDTH);
		XtSetValues(runtext,args,1);
    		XtSetArg(args[0], XmNresizeWidth, False); 
		XtSetValues(runtext,args,1);
	}
}

/* ARGSUSED */
void
snapshot_activateCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	char *directory, *image, *exposure;
	static int init=0;
	Arg args[2];

	directory = XmTextFieldGetString(snap_directory_textField);
	/*if (!strcmp(directory, "")) {*/
	if (iswhite(directory)) {
		XtFree(directory);
		directory = XmTextFieldGetString(strategy_directory_textField);
		if (iswhite(directory))
		    XmTextFieldSetString(snap_directory_textField,"/tmp");
		else
		    XmTextFieldSetString(snap_directory_textField,directory);

	}
	XmTextSetInsertionEnd(snap_directory_textField);


	image = XmTextFieldGetString(snap_image_textField);
	if (!strcmp(image, "")) {
		/*image = XmTextFieldGetString(strategy_image_prefix_textField);*/
		XmTextFieldSetString(snap_image_textField,"snap_99_001");
		XmTextSetInsertionEnd(snap_image_textField);
	}
	if (XmToggleButtonGetState(snap_axisPhi_toggleButton) == True) {
		TextFieldSetFloat(snap_phi_textField,current_phi);
		TextFieldSetFloat(snap_step_size_textField,delta_phi);
	}
	else {
		TextFieldSetFloat(snap_phi_textField,current_omega);
		TextFieldSetFloat(snap_step_size_textField,delta_phi);
	}
	TextFieldSetFloat(snap_distance_textField,current_distance);

	if (XtIsSensitive(snap_offset_textField))
		TextFieldSetFloat(snap_offset_textField,current_offset);

	exposure = XmTextFieldGetString(snap_exposure_time_textField);
	if (!strcmp(exposure, ""))
		XmTextFieldSetString(snap_exposure_time_textField,"10");
	XmTextSetInsertionEnd(snap_exposure_time_textField);
	XtFree(exposure);

	
	/*
	XmToggleButtonSetState(snap_plate_180_toggleButton,True,False);
	XmToggleButtonSetState(snap_plate_300_toggleButton,False,False);
	 */
	 
	XtFree(directory);
	XtFree(image);

	if (!init) {
		init=1;
		XtSetArg(args[0], XmNx, scr_width + SNAPSHOTDIALOG_X);
		XtSetArg(args[1], XmNy, SNAPSHOTDIALOG_Y);
		XtSetValues(snapshotDialog,args,2);
	}

	raise_window(snapshotDialog);
}

/* ARGSUSED */
void
modify_distance_activateCb(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	double distance;
	Window window;
	int dest_x=356, dest_y=196;
	Dimension m_XmNx, m_XmNy, m_XmNwidth, m_XmNheight;
	static int init=0;
	Arg args[2];

	if (!init) {
		init=1;
		XtSetArg(args[0], XmNx, 500);
		XtSetArg(args[1], XmNy, 500);
		XtSetValues(define_distance_Dialog,args,2);
	}

	if (debug) {
		fprintf(stderr,"Called modify_distance_activateCallback...\n");
		fflush(stderr);
	}

	distance = wtof(w);
	if ((sc_conf.usedistance == 1) && ((distance < Limit.distmin) || (distance > Limit.distmax)) ) {
		sprintf(error_msg,"\nAttempt to %s Distance to %1.2f. This value is out of Range.\n\nOperation has been aborted.\n\nMinimum Distance: %6.2f\nMaximum Distance: %6.2f",
		(XmToggleButtonGetState(define_distance_pushButton) == True)?"Define":"Drive",
		distance,Limit.distmin,Limit.distmax);

		post_error(error_msg);
		return;
	}
	if (XmToggleButtonGetState(define_distance_pushButton) == True) {

#ifdef OLD_TEXT
	if (!init_text) {
		init_text=1;
		XmTextInsert(define_distance_text,0,
"Defining the distance will NOT move the detector!\n\
\n\
     It will redefine the current distance. This is\n\
  VERY DANGEROUS and is normally not done.\n\
\n\
          Are you SURE you want to do this?\
");
	}
#endif /* OLD TEXT */
		if (sc_conf.usedistance == 0) { 
			marcommand(SET_DISTANCE, distance);
		}
		else {
			raise_window(define_distance_Dialog);
			window  = XtWindow(define_distance_Dialog);

			XtVaGetValues(pushButton2,
				XmNx, &m_XmNx,
				XmNy, &m_XmNy,
				XmNwidth, &m_XmNwidth,
				XmNheight, &m_XmNheight,
				NULL);

			dest_x = m_XmNx + m_XmNwidth/2;
			dest_y = m_XmNy + m_XmNheight/2;

			XWarpPointer(display, None, window, 0, 0, 0, 0, dest_x, dest_y);
		}
	}
	else {
		marcommand(DRIVE_DISTANCE, distance);
	}


}

/* ARGSUSED */
void
manualcontrol_activateCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	static int init=0;
	Arg args[2];

	if (!init) {
		init=1;
		XtSetArg(args[0], XmNx, scr_width + MANUALCONTROLDIALOG_X);
		XtSetArg(args[1], XmNy, MANUALCONTROLDIALOG_Y);
		XtSetValues(manual_controlDialog,args,2);
	}
	raise_window(manual_controlDialog);
}

/* ARGSUSED */
void
exit_activateCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	int user_data;
	XtVaGetValues(w, XmNuserData, &user_data, NULL);

	switch(user_data)
	  {
	    case EXIT_YES:
		exit(1);
		break;
	    case EXIT_NO:
	    	XtUnmanageChild(exitDialog);
		break;
	    case EXIT_ALL:
		if (sc_conf.daemon_exit == 0) {
			system("ccdsys shutdown");
		}
		else {
			system("ccdsys exit");
		}
		exit(1);
		break;
	    case EXIT_HELP:
		break;
	  }
}

/* ARGSUSED */
void
drive_phi_activateCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	int user_data;
	XtVaGetValues(w, XmNuserData, &user_data, NULL);

	if(sc_conf.usephi)
	{
		switch(user_data)
		  {
		    case PHI_90:
			marcommand(DRIVE_PHI_REL, 90.0);
			break;
	 	   case PHI_180:
			marcommand(DRIVE_PHI_REL, 180.0);
			break;
		    default:
			break;
		  }
	}
	else
	{
		switch(user_data)
		  {
		    case PHI_90:
			marcommand(DRIVE_OMEGA_REL, 90.0);
			break;
	 	   case PHI_180:
			marcommand(DRIVE_OMEGA_REL, 180.0);
			break;
		    default:
			break;
		  }
	}
}

/* ARGSUSED */
void
driveto_phi_activateCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	int user_data;
	XtVaGetValues(w, XmNuserData, &user_data, NULL);

	if(sc_conf.usephi)
	{
		switch(user_data)
		  {
		    case PHI_90:
			marcommand(DRIVE_PHI, 90.0);
			break;
	 	   case PHI_180:
			marcommand(DRIVE_PHI, 180.0);
			break;
	 	   case PHI_0:
			marcommand(DRIVE_PHI, 0.0);
			break;
	 	   case PHI_270:
			marcommand(DRIVE_PHI, 270.0);
			break;
		    default:
			break;
		  }
	}
	else
	{
		switch(user_data)
		  {
		    case PHI_90:
			marcommand(DRIVE_OMEGA, 90.0);
			break;
	 	   case PHI_180:
			marcommand(DRIVE_OMEGA, 180.0);
			break;
	 	   case PHI_0:
			marcommand(DRIVE_OMEGA, 0.0);
			break;
	 	   case PHI_270:
			marcommand(DRIVE_OMEGA, 270.0);
			break;
		    default:
			break;
		  }
	}
}

/* ARGSUSED */
void
modify_phi_activateCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	double phi;
	Window window;
	Dimension m_XmNx, m_XmNy, m_XmNwidth, m_XmNheight;
	int dest_x=104, dest_y=169;
	static int init=0;
	Arg args[2];
    
	if (!init) {
		init=1;
		XtSetArg(args[0], XmNx, 500);
		XtSetArg(args[1], XmNy, 500);
		XtSetValues(define_phi_Dialog,args,2);
	}

	if (debug) {
		fprintf(stderr,"Called modify_phi_activateCallback...\n");
		fflush(stderr);
	}

	phi = wtof(w);

	if (XmToggleButtonGetState(define_phi_pushButton) == True) {
		if (sc_conf.usephi == 0) { 
			marcommand(SET_PHI, phi);
		}
		else {
#ifdef CHESS_CCD
			marcommand(SET_PHI, phi);
#else
			raise_window(define_phi_Dialog);
			window  = XtWindow(define_phi_Dialog);
			XtVaGetValues(pushButton11,
				XmNx, &m_XmNx,
				XmNy, &m_XmNy,
				XmNwidth, &m_XmNwidth,
				XmNheight, &m_XmNheight,
				NULL);

			dest_x = m_XmNx + m_XmNwidth/2;
			dest_y = m_XmNy + m_XmNheight/2;
			XWarpPointer(display, None, window, 0, 0, 0, 0, dest_x, dest_y);
#endif /* CHESS_CCD */
		}
	}
	else {
		marcommand(DRIVE_PHI, phi);
	}

}

/* ARGSUSED */
void
modify_twotheta_activateCb(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	double twotheta;
	Window window;
	Dimension m_XmNx, m_XmNy, m_XmNwidth, m_XmNheight;
	int dest_x=343, dest_y=193;
	static int init=0;
	Arg args[2];

	if (!init) {
		init=1;
		XtSetArg(args[0], XmNx, 500);
		XtSetArg(args[1], XmNy, 500);
		XtSetValues(define_offset_Dialog,args,2);
	}

	if (debug) {
		fprintf(stderr,"Called modify_twotheta_activateCallback...\n");
		fflush(stderr);
	}
	twotheta = wtof(w);

	if ((sc_conf.uselift == 1) && ((twotheta < Limit.liftmin) || (twotheta > Limit.liftmax)) ) {
		if ((Limit.liftmin == 0.0) && (Limit.liftmax == 0.0)) 
		sprintf(error_msg,"\nThis CCD does not support this operation.");
		else
		sprintf(error_msg,"\nAttempt to %s Offset to %1.2f. This value is out of Range.\n\nOperation has been aborted.\n\nMinimum Offset: %6.2f\nMaximum Offset: %6.2f",
		(XmToggleButtonGetState(define_twotheta_pushButton) == True)?"Define":"Drive",
		twotheta,Limit.liftmin,Limit.liftmax);

		post_error(error_msg);
		return;
	}

	if (XmToggleButtonGetState(define_twotheta_pushButton) == True) {
		if (sc_conf.uselift == 0) { 
			marcommand(SET_OFFSET, twotheta);
		}
		else {
			raise_window(define_offset_Dialog);
			window  = XtWindow(define_offset_Dialog);
			XtVaGetValues(pushButton12,
				XmNx, &m_XmNx,
				XmNy, &m_XmNy,
				XmNwidth, &m_XmNwidth,
				XmNheight, &m_XmNheight,
				NULL);

			dest_x = m_XmNx + m_XmNwidth/2;
			dest_y = m_XmNy + m_XmNheight/2;
			XWarpPointer(display, None, window, 0, 0, 0, 0, dest_x, dest_y);
		}
	}
	else {
		marcommand(DRIVE_OFFSET,twotheta);
	}
    

}

/* ARGSUSED */
void
cancel_activateCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	XtUnmanageChild(define_distance_Dialog);

	/* Reset toggle button to Drive (not Define)
	 */
	if (sc_conf.usedistance == 1) {
		XmToggleButtonSetState(define_distance_pushButton,False,False);
		XmToggleButtonSetState(drive_distance_pushButton,True,False);
	}
}

/* ARGSUSED */
void
define_distance_activateCb(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	double distance;

	distance = wtof(modify_distance_textField);
	marcommand(SET_DISTANCE,distance);

	/* Reset toggle button to Drive (not Define)
	 */

	if (sc_conf.usedistance == 1) {
		XmToggleButtonSetState(define_distance_pushButton,False,False);
		XmToggleButtonSetState(drive_distance_pushButton,True,False);
	}

	XtUnmanageChild(define_distance_Dialog);
}

/* ARGSUSED */
void
stop_activateCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	int user_data;

	XtVaGetValues(w, XmNuserData, &user_data, NULL);

	switch(user_data)
	  {
	    case STOP_YES:
		marcommand(STOP,0.0);
	    	XtUnmanageChild(stopDialog);
		break;
	    case STOP_NO:
	    	XtUnmanageChild(stopDialog);
		break;
	    default:
		break;
	  }
}

/* ARGSUSED */
void
define_phi_activateCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	int user_data;
	double phi;

	XtVaGetValues(w, XmNuserData, &user_data, NULL);

	switch(user_data)
	  {
	    case YES:
		phi = wtof(modify_phi_textField);
		marcommand(SET_PHI,phi);
	    	XtUnmanageChild(define_phi_Dialog);
		break;
	    case NO:
	    	XtUnmanageChild(define_phi_Dialog);
		break;
	    default:
		break;
	  }

	/* Reset toggle button to Drive (not Define)
	 */
	if (sc_conf.usephi == 1) {
		XmToggleButtonSetState(define_phi_pushButton,False,False);
		XmToggleButtonSetState(drive_phi_pushButton,True,False);
	}
}

/* ARGSUSED */
void
define_offset_activateCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	int user_data;
	double offset;

	XtVaGetValues(w, XmNuserData, &user_data, NULL);

	switch(user_data)
	  {
	    case YES:
		offset = wtof(modify_offset_textField);
		marcommand(SET_OFFSET,offset);
	    	XtUnmanageChild(define_offset_Dialog);
		break;
	    case NO:
	    	XtUnmanageChild(define_offset_Dialog);
		break;
	    default:
		break;
	  }

	/* Reset toggle button to Drive (not Define)
	 */
	if (sc_conf.uselift == 1) {
		XmToggleButtonSetState(define_twotheta_pushButton,False,False);
		XmToggleButtonSetState(drive_twotheta_pushButton,True,False);
	}
}

/* ARGSUSED */
void
strategy_help_activateCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	Unmanage_helpWindow();
	XtManageChild(strategy_helpWindow);

	raise_window(adx_helpDialog);
}

/* ARGSUSED */
void
method_callback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	int user_data;
	XmString m_XmNdirectory;
    	Arg args[2];
	char *dir;
	static int init_LOAD_METHOD, init_SAVE_METHOD, init_DELETE_METHOD;
	static int init=0;

	if (!init) {
		init=1;
		XtSetArg(args[0], XmNx, scr_width + METHOD_FSB_X);
		XtSetArg(args[1], XmNy, METHOD_FSB_Y);
		XtSetValues(load_method_fSB,args,2);
		XtSetValues(save_method_fSB,args,2);
		XtSetValues(delete_method_fSB,args,2);
	}

	XtVaGetValues(w, XmNuserData, &user_data, NULL);

	switch(user_data)
	  {
	    case LOAD_METHOD:
	    	raise_window(load_method_fSB);
		if (!init_LOAD_METHOD) {
			init_LOAD_METHOD = !init_LOAD_METHOD;

			/*
			XtSetArg(args[0], XmNdirectory, &m_XmNdirectory);
			XtGetValues(load_method_fSB, args, 1);
			dir = XmCvtXmStringToCT(m_XmNdirectory);
			fprintf(stderr,"Current dir is: %s\n",dir); fflush(stderr);
			XmStringFree(m_XmNdirectory);
			*/

			dir = XmTextFieldGetString(strategy_directory_textField);
			if (strcmp(dir,"")) {
				m_XmNdirectory = XmStringCreateSimple(dir);
				XtSetArg(args[0], XmNdirectory, m_XmNdirectory);
				XtSetValues(load_method_fSB,args,1);
				XmStringFree(m_XmNdirectory);
			}
			XtFree(dir);
		}
		break;
	    case SAVE_METHOD:
	    	raise_window(save_method_fSB);
		if (!init_SAVE_METHOD) {
			init_SAVE_METHOD = !init_SAVE_METHOD;
			dir = XmTextFieldGetString(strategy_directory_textField);
			if (strcmp(dir,"")) {
				m_XmNdirectory = XmStringCreateSimple(dir);
				XtSetArg(args[0], XmNdirectory, m_XmNdirectory);
				XtSetValues(save_method_fSB,args,1);
				XmStringFree(m_XmNdirectory);
			}
			XtFree(dir);
		}
		break;
	    case DELETE_METHOD:
	    	raise_window(delete_method_fSB);
		if (!init_DELETE_METHOD) {
			init_DELETE_METHOD = !init_DELETE_METHOD;
			dir = XmTextFieldGetString(strategy_directory_textField);
			if (strcmp(dir,"")) {
				m_XmNdirectory = XmStringCreateSimple(dir);
				XtSetArg(args[0], XmNdirectory, m_XmNdirectory);
				XtSetValues(delete_method_fSB,args,1);
				XmStringFree(m_XmNdirectory);
			}
			XtFree(dir);
		}
		break;
	    default:
		break;
	  }


}

/* ARGSUSED */
void
method_okCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	int user_data;
	char *str;
	Widget selection_widget;

	XtVaGetValues(w, XmNuserData, &user_data, NULL);


	switch(user_data)
	  {
	    case LOAD_METHOD:
		selection_widget = XmFileSelectionBoxGetChild (load_method_fSB,
			XmDIALOG_TEXT);
		str = XmTextFieldGetString(selection_widget);
		mvc_return = 1;
		if (load_XmText(runtext, str) < 0) {
			fprintf(stderr,"error: %s\n",error_msg);
			fflush(stderr);
		}
		mvc_return = 0;
	    	XtUnmanageChild(load_method_fSB);
		XtFree(str);
		break;
	    case SAVE_METHOD:
		selection_widget = XmFileSelectionBoxGetChild (save_method_fSB,
			XmDIALOG_TEXT);
		str = XmTextFieldGetString(selection_widget);
		if (save_XmText(runtext, str) < 0) {
			fprintf(stderr,"error: %s\n",error_msg);
			fflush(stderr);
		}
	    	XtUnmanageChild(save_method_fSB);
		XtFree(str);
		break;
	    case DELETE_METHOD:
		selection_widget = XmFileSelectionBoxGetChild (delete_method_fSB,
			XmDIALOG_TEXT);
		str = XmTextFieldGetString(selection_widget);
		if (unlink(str) == -1) {
			perror(str);
		}
		XtFree(str);
	    	XtUnmanageChild(delete_method_fSB);
		break;
	    default:
		break;
	  }
}

/* ARGSUSED */
void
method_applyCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	int user_data;

	XtVaGetValues(w, XmNuserData, &user_data, NULL);

	switch(user_data)
	  {
	    case LOAD_METHOD:
		break;
	    case SAVE_METHOD:
		break;
	    case DELETE_METHOD:
		break;
	    default:
		break;
	  }
}

/* ARGSUSED */
void
method_cancelCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	int user_data;

	XtVaGetValues(w, XmNuserData, &user_data, NULL);

	switch(user_data)
	  {
	    case LOAD_METHOD:
	    	XtUnmanageChild(load_method_fSB);
		break;
	    case SAVE_METHOD:
	    	XtUnmanageChild(save_method_fSB);
		break;
	    case DELETE_METHOD:
	    	XtUnmanageChild(delete_method_fSB);
		break;
	    default:
		break;
	  }
}

/* ARGSUSED */
void
method_helpCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	int user_data;

	XtVaGetValues(w, XmNuserData, &user_data, NULL);

	switch(user_data)
	  {
	    case LOAD_METHOD:
		fprintf(stderr,"HELP LOAD_METHOD\n"); fflush(stderr);
		break;
	    case SAVE_METHOD:
		fprintf(stderr,"HELP SAVE_METHOD\n"); fflush(stderr);
		break;
	    case DELETE_METHOD:
		fprintf(stderr,"HELP DELETE_METHOD\n"); fflush(stderr);
		break;
	    default:
		break;
	  }
}

/* ARGSUSED */
void
process_activateCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	int user_data;

	XtVaGetValues(w, XmNuserData, &user_data, NULL);
	switch(user_data)
	  {
	    case PROCESS_AUTOINDEX:
		system("ai_motif_gui &");
		break;
	    case PROCESS_DENZO:
		system("dz_motif_gui &");
		break;
	    case PROCESS_MOSFLM:
		system("mf_motif_gui &");
		break;
	    case PROCESS_XDS:
		system("xds_gui &");
		break;
	    default:
		break;
	  }
}


/* PF Start */

/* ARGSUSED */
void
pfstars_activateCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	static int init=1;
	Arg args[2];
	int user_data;

	XtVaGetValues(w, XmNuserData, &user_data, NULL);
	switch(user_data)
	  {
	    default:
		
		if (!init) {
			init=1;
			XtSetArg(args[0], XmNx, scr_width + PROJECTDIALOG_X);
			XtSetArg(args[1], XmNy, PROJECTDIALOG_Y);
			XtSetValues(stars_dialog,args,2);
		}
		if(stars_dialog == NULL)
		{
			fprintf(stderr,"(stars) process activate: ERROR: Would raise a NULL widget; ignoring\n");
			return;
		}
		raise_window(stars_dialog);
		break;
	  }
}


/* ARGSUSED */
void
stars_make_adsc_master_callback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
    	char	*cp;

	if(NULL == (cp = (char *) getenv("CCD_TAK_CLIENT_ADSC")))
	    cp = "adsc";
	marcommand_string(MAKE_MASTER, cp);
}

/* ARGSUSED */
void
stars_make_none_master_callback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	marcommand_string(MAKE_MASTER, "none");
}


/* ARGSUSED */
void
stars_new_master_activateCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	marcommand_string(MAKE_MASTER, saved_client_names[(int) client]);
}

/* ARGSUSED */
void
stars_help_activateCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
}

/* ARGSUSED */
void
stars_param_file_cb(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
}

/* ARGSUSED */
void
stars_spgrp_cb(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
}

/* ARGSUSED */
void
stars_i_prefix_cb(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
}

/* ARGSUSED */
void
stars_proc_dir_cb(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
}

/* ARGSUSED */
void
stars_data_dir_cb(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
}

/* ARGSUSED */
void
stars_close_callback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	XtUnmanageChild(stars_dialog);
}

/* PF End */
/* ARGSUSED */
void
display_activateCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	char *imagefile, *imagedir, prev_imagefile[128];
	int user_data;
	char xformstatusfile[256];
	char imfile[256];
	FILE *xformstatusfp;
	char *centerx_str, *centery_str;
	float center_x, center_y;

	imagedir  = XmTextFieldGetString(directory_textField);

	centerx_str = XmTextFieldGetString(strategy_beamx_textField);
	centery_str = XmTextFieldGetString(strategy_beamy_textField);
	if (iswhite(centerx_str) || iswhite(centery_str)) {
		center_x = beam_x;
		center_y = beam_y;
	}
	else {
		center_x = atof(centerx_str);
		center_y = atof(centery_str);
	}
	XtFree(centerx_str);
	XtFree(centery_str);

	XtVaGetValues(w, XmNuserData, &user_data, NULL);
	switch(user_data)
	  {
	    case FOLLOW_IMAGES:

		if ((center_x != -1000) && (center_y != 1000))
			sprintf(tmpstr,"PWD=%s ; export PWD ; cd %s ; adxv -beam_center %f %f -autoload &",
				imagedir,imagedir,center_x,center_y);
		else
			sprintf(tmpstr,"PWD=%s ; export PWD ; cd %s ; adxv -autoload &",
				imagedir,imagedir);

		system(tmpstr);
		break;
	    case CURRENT_IMAGE:

		if (getenv("XFORMSTATUSFILE") != NULL) {
			strcpy(xformstatusfile,getenv("XFORMSTATUSFILE"));
			xformstatusfp = fopen(xformstatusfile,"r");
			if (xformstatusfp == NULL) {
				sprintf(tmpstr,"Can not open XFORMSTATUSFILE: %s",
					xformstatusfile);
				emess(tmpstr);
				if ((center_x != -1000) && (center_y != 1000))
					sprintf(tmpstr,"adxv -beam_center %f %f &",
						center_x,center_y);
				else
					sprintf(tmpstr,"adxv &");
			}
			else {
				strcpy(imfile,"");
				fscanf(xformstatusfp,"%*d%s",imfile);
				if ((center_x != -1000) && (center_y != 1000))
					sprintf(tmpstr,"adxv -beam_center %f %f %s &",center_x,center_y,imfile);
				else
					sprintf(tmpstr,"adxv %s &",imfile);
				fclose(xformstatusfp);
			}
		}
		else {
			sprintf(tmpstr,
				"Warning: environment variable XFORMSTATUSFILE not set");
			emess(tmpstr);
			if ((center_x != -1000) && (center_y != 1000))
				sprintf(tmpstr,"adxv -beam_center %f %f &",
					center_x,center_y);
			else
				sprintf(tmpstr,"adxv &");
		}

#ifdef OLD
		imagefile = XmTextFieldGetString(image_textField);

		/* Check if current image is readable */

		strcpy(tmpstr,imagedir);
		strcat(tmpstr,imagefile);
		remove_white(tmpstr);
		if (is_file(tmpstr)) {
			sprintf(tmpstr,"PWD=%s ; export PWD ; cd %s ; adxv %s &",
				imagedir,imagedir,imagefile);
		}
		else {
			strcpy(prev_imagefile,imagefile);
			prev_image(prev_imagefile);
			strcpy(tmpstr,imagedir);
			strcat(tmpstr,prev_imagefile);
			remove_white(tmpstr);
			if (is_file(tmpstr)) {
				sprintf(tmpstr,"PWD=%s ; export PWD ; cd %s ; adxv %s &",
					imagedir,imagedir,prev_imagefile);
			}
			else {
				sprintf(tmpstr,"PWD=%s ; export PWD ; cd %s ; adxv %s &",
					imagedir,imagedir,imagefile);
			}
		}

		XtFree(imagefile);
#endif /* OLD */
		system(tmpstr);
		break;
	    case SELECT_IMAGE:
		if ((center_x != -1000) && (center_y != 1000))
			sprintf(tmpstr,"PWD=%s ; export PWD ; cd %s ; adxv -beam_center %f %f &",
				imagedir,imagedir,center_x,center_y);
		else
			sprintf(tmpstr,"PWD=%s ; export PWD ; cd %s ; adxv &",imagedir,imagedir);
		system(tmpstr);
		break;
	    default:
		break;
	  }
	XtFree(imagedir);
}

/* ARGSUSED */
void
main_destroyCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{

	exit(0);
}

/* Update contents of the Status Window 
 */
update_status(count)
int count; /* Number of times called */
{

	char buf[256], key[256], value[256];
	double atof();
	int i, current_run, current_frame, total_runs;
	char directory[64];
	char scanner_op_str[64];
	char *current_run_time(), *all_run_time();
	char current_adc[32], current_bin[32];
	char axis[64];

	static double prev_current_distance = -100;
	static double prev_current_phi= -100;
	static double prev_current_kappa= -100;
	static double prev_current_omega= -100;
	static double prev_current_offset = -100;
	static double prev_intensity = -100;
	static double prev_osc_width = -100;
	static double prev_exp_time = -100;
	static char prev_current_adc[32];
	static char prev_current_bin[32];
	static char prev_directory[64];
	static char prev_image_filename[64];
	static char prev_mode[16];
	static char prev_shutter[16];
	static char prev_scanner_op[64];
	static char prev_scanner_control[64];
	static char prev_axis[64];
	static int prev_percent;
	static int prev_image_compression;
	static char prev_dzngr[32];
	static int update_runs;
	static double	prev_wavelength = -100.;
	static double	prev_experiment_mode = 0;
	static double	prev_hslit = -1;
	static double	prev_vslit = -1;
	static double	prev_attenuator = -1;
	static char	prev_master[100];
	static Widget	prev_experiment_mode_widget = NULL;
	static int	prev_xl_hs = -1;
	static int	prev_xl_vs = -1;
	static int	prev_xl_guard_hs = -1;
	static int	prev_xl_guard_vs = -1;
	static double	prev_ion_up = -1.;
	static double	prev_ion_down = -1.;
	static double	prev_ion_beam = -1.;

	strcpy(directory,"");
	/*XmTextFieldSetString(completion_this_textField,"OK TEST");*/

	if (!strcmp(marstatusfile,""))
		return;

	if (marstatusfp != NULL) {
		fprintf(stderr,"Warning: marstatusfp not NULL...\n");
		fflush(stderr);
		fclose(marstatusfp);
	}
	else {
		marstatusfp = fopen(marstatusfile,"r");
		if (marstatusfp == NULL) {
			sprintf(buf,"Can not open status file: %s\n", marstatusfile);
			emess(buf);
			return;
		}
	}
	strcpy(scanner_op_str,"");

	while(fgets(buf,256,marstatusfp)!=NULL){

		/* Skip blank lines */
		if (iswhite(buf))
			continue;

		/* Get rid of trailing white space */
		while(isspace(buf[strlen(buf)-1]) )
			buf[strlen(buf)-1]=(char)NULL;

		if (!strncmp(buf,"end_of_status",strlen("end_of_status")))
			break;

		strcpy(key,"");
		strcpy(value,"");
		sscanf(buf,"%s%*[ \t]%[^\n]",key,value);
		if(!strncmp(key,"distance",8)){
			current_distance = atof(value);
			if (current_distance != prev_current_distance) {
				if (debug) {
					fprintf(stderr,"current_distance=%f\n",current_distance);
					fflush(stderr);
				}
				prev_current_distance = current_distance;
				sprintf(tmpstr,"%6.2f",current_distance);
				XmTextFieldSetString(distance_textField,tmpstr);
			}
		} else 
		if(!strncmp(key,"adc",3)){
			remove_white(value);
			strcpy(current_adc,value);
			if (strcmp(current_adc,prev_current_adc)) {
				if (debug) {
					fprintf(stderr,"current_adc=%s\n",current_adc);
					fflush(stderr);
				}
				strcpy(prev_current_adc,current_adc);
				if(sc_conf.t2k_detector == 0)
				{
				if (!strcmp(current_adc,"slow"))
					XmTextFieldSetString(speed_textField,"  Slow");
				else
				if (!strcmp(current_adc,"fast"))
					XmTextFieldSetString(speed_textField,"  Fast");
				else
					XmTextFieldSetString(speed_textField,"  ????");
				}
				else
				{
					if(0 == strcmp(current_bin, "no"))
						XmTextFieldSetString(speed_textField,"   Std");
					else
					{
						if(0 == strcmp(current_adc, "slow"))
							XmTextFieldSetString(speed_textField,"    SW");
						else
							XmTextFieldSetString(speed_textField,"    HW");
					}
				}
			}
		} else 
		if(!strncmp(key,"bin",3)){
			remove_white(value);
			strcpy(current_bin,value);
			if (strcmp(current_bin,prev_current_bin)) {
				if (debug) {
					fprintf(stderr,"current_bin=%s\n",current_bin);
					fflush(stderr);
				}
				strcpy(prev_current_bin,current_bin);
				if (!strcmp(current_bin,"no"))
					XmTextFieldSetString(binning_textField,
						"  None");
				else
				if (!strcmp(current_bin,"2x2"))
					XmTextFieldSetString(binning_textField,"   2x2");
				else
					XmTextFieldSetString(binning_textField,"  ????");
				if(sc_conf.t2k_detector == 1)
				{
					if(0 == strcmp(current_bin, "no"))
						XmTextFieldSetString(speed_textField,"   Std");
					else
					{
						if(0 == strcmp(current_adc, "slow"))
							XmTextFieldSetString(speed_textField,"    SW");
						else
							XmTextFieldSetString(speed_textField,"    HW");
					}
				}
			}
		} else 
		if(!strncmp(key,"phi",3)){
			current_phi = atof(value);
			if (sc_conf.constrain_phi == 180) {
				while(current_phi > 180.0)
					current_phi -= 360.0;
				while(current_phi < -180.0)
					current_phi += 360.0;
			}
			else
			if (sc_conf.constrain_phi == 0) {
			}
			else {
				while(current_phi > 360.0)
					current_phi -= 360.0;
				while(current_phi < 0.0)
					current_phi += 360.0;
			}
			if (current_phi != prev_current_phi) {
				if (debug) {
					fprintf(stderr,"current_phi=%f\n",current_phi);
					fflush(stderr);
				}
				prev_current_phi = current_phi;
				sprintf(tmpstr,"%6.2f",current_phi);
				XmTextFieldSetString(curr_phi_textField,tmpstr);
			}
		} else 
		if(!strncmp(key,"kappa",5)){
			current_kappa = atof(value);
			if (sc_conf.constrain_kappa == 180) {
				while(current_kappa > 180.0)
					current_kappa -= 360.0;
				while(current_kappa < -180.0)
					current_kappa += 360.0;
			}
			else
			if (sc_conf.constrain_kappa == 0) {
			}
			else {
				while(current_kappa > 360.0)
					current_kappa -= 360.0;
				while(current_kappa < 0.0)
					current_kappa += 360.0;
			}
			if (current_kappa != prev_current_kappa) {
				if (debug) {
					fprintf(stderr,"current_kappa=%f\n",current_kappa);
					fflush(stderr);
				}
				prev_current_kappa = current_kappa;
				sprintf(tmpstr,"%6.2f",current_kappa);
				XmTextFieldSetString(kappa_textField,tmpstr);
			}
		} else
		if(!strncmp(key,"omega",5)){
			current_omega = atof(value);
			if (sc_conf.constrain_omega == 180) {
				while(current_omega > 180.0)
					current_omega -= 360.0;
				while(current_omega < -180.0)
					current_omega += 360.0;
			}
			else
			if (sc_conf.constrain_omega == 0) {
			}
			else {
				while(current_omega > 360.0)
					current_omega -= 360.0;
				while(current_omega < 0.0)
					current_omega += 360.0;
			}
			if (current_omega != prev_current_omega) {
				if (debug) {
					fprintf(stderr,"current_omega=%f\n",current_omega);
					fflush(stderr);
				}
				prev_current_omega = current_omega;
				sprintf(tmpstr,"%6.2f",current_omega);
				XmTextFieldSetString(omega_textField,tmpstr);
			}
		} else
		if(!strncmp(key,"axis",4)){
			strcpy(axis,value);
			remove_white(axis);
			if (strcmp(axis,prev_axis)) {
				int argok;
    				Arg args[3];
				Widget parent;

				if (!strcmp(axis,"omega")) {
					XtManageChild(step_omega_label);
					XtUnmanageChild(step_phi_label);
					XtUnmanageChild(step_kappa_label);
				}
				else
				if (!strcmp(axis,"kappa")) {
					XtManageChild(step_kappa_label);
					XtUnmanageChild(step_phi_label);
					XtUnmanageChild(step_omega_label);
				}
				else {
					XtManageChild(step_phi_label);
					XtUnmanageChild(step_kappa_label);
					XtUnmanageChild(step_omega_label);
				}

				parent = XtParent(curr_phi_textField);
				strcpy(prev_axis,axis);
#ifdef OLD
    				XtSetArg(args[0], XmNborderColor, 
        				CONVERT(parent, "Grey20", 
        				XmRPixel, 0, &argok)); 

				XtSetValues(omega_textField,args,1);
				XtSetValues(kappa_textField,args,1);
				XtSetValues(curr_phi_textField,args,1);
#endif /* OLD */
    				XtSetArg(args[0], XmNtopShadowColor, 
        				CONVERT(parent, "Grey65", 
        				XmRPixel, 0, &argok)); 
    				XtSetArg(args[1], XmNbottomShadowColor, 
        				CONVERT(parent, "Black", 
        				XmRPixel, 0, &argok)); 

				XtSetValues(omega_textField,args,2);
				XtSetValues(kappa_textField,args,2);
				XtSetValues(curr_phi_textField,args,2);



    				XtSetArg(args[0], XmNforeground, 
        				CONVERT(parent, "Black", 
        				XmRPixel, 0, &argok)); 
				XtSetValues(status_label_omega,args,1);
				XtSetValues(status_label_kappa,args,1);
				XtSetValues(status_label_phi,args,1);

#ifdef OLD
    				XtSetArg(args[0], XmNborderColor, 
        				CONVERT(parent, "Red", 
        				XmRPixel, 0, &argok)); 
    				XtSetArg(args[1], XmNforeground, 
        				CONVERT(parent, "Red", 
        				XmRPixel, 0, &argok)); 
#endif /* OLD */
    				XtSetArg(args[0], XmNtopShadowColor, 
        				CONVERT(parent, "Red", 
        				XmRPixel, 0, &argok)); 
    				XtSetArg(args[1], XmNbottomShadowColor, 
        				CONVERT(parent, "Red", 
        				XmRPixel, 0, &argok)); 
    				XtSetArg(args[2], XmNforeground, 
        				CONVERT(parent, "Red", 
        				XmRPixel, 0, &argok)); 

				if (!strcmp(axis,"phi")) {
					XtSetValues(curr_phi_textField,args,2);
					XtSetValues(status_label_phi,&args[2],1);
				}
				else
				if (!strcmp(axis,"kappa")) {
					XtSetValues(kappa_textField,args,2);
					XtSetValues(status_label_kappa,&args[2],1);
				}
				else
				if (!strcmp(axis,"omega")) {
					XtSetValues(omega_textField,args,2);
					XtSetValues(status_label_omega,&args[2],1);
				}
				else {
					/*
					fprintf(stderr,"Bad axis: %s\n",axis);
					fflush(stderr);
					 */
				}
			}
		} else
		if(!strncmp(key,"lift",4)){
			current_offset = atof(value);
			if (current_offset != prev_current_offset) {
				if (debug) {
					fprintf(stderr,"current_offset=%f\n",current_offset);
					fflush(stderr);
				}
				prev_current_offset = current_offset;
				sprintf(tmpstr,"%6.2f",current_offset);
				XmTextFieldSetString(offset_textField,tmpstr);
			}
		} else 
		if(!strncmp(key,"osc_start",9)){
			/* do nothing */
		} else 
		if(!strncmp(key,"osc_end",7)){
			/* do nothing */
		} else 
		if(!strncmp(key,"exposure",8)){
			double exp_time;
			exp_time = atof(value);
			if (exp_time != prev_exp_time) {
				prev_exp_time = exp_time;
				if (debug) {
					fprintf(stderr,"exp_time=%f\n",exp_time);
					fflush(stderr);
				}
				if (exp_time > 999)
					sprintf(tmpstr,"%6.0f",exp_time);
				else
					sprintf(tmpstr,"%6.2f",exp_time);
				XmTextFieldSetString(exp_time_textField,tmpstr);
			}
		} else 
		if(!strncmp(key,"intensity",9)){
			beam_intensity = atof(value);
			if (beam_intensity != prev_intensity) {
				if (debug) {
					fprintf(stderr,"beam_intensity=%f\n",beam_intensity);
					fflush(stderr);
				}
#ifdef CHECK_WEAK_BEAM
				if (beam_intensity_0 > WEAK_BEAM) {
					if (beam_intensity < 0.5*beam_intensity_0) {
   						XmString xmstr;
						char beam_str[32];
    						Arg args[1];

						sprintf(beam_str,"%1.2f to %1.2f",
							beam_intensity_0,beam_intensity);
						xmstr = XmStringCreateSimple(beam_str);
						XtSetArg(args[0], XmNlabelString, xmstr);
						XtSetValues(nobeam_label2,args,1);
    						XmStringFree(xmstr);
						raise_window(nobeamDialog);
						marcommand(ABORT,0.0);
						sleep(1);
					}
				}
#endif /* CHECK_WEAK_BEAM */
				prev_intensity = beam_intensity;
				sprintf(tmpstr,"%6.2f",beam_intensity);
				XmTextFieldSetString(intensity_textField,tmpstr);
			}
		} else 
		if(!strncmp(key,"osc_width",9)){
			double osc_width;
			osc_width = atof(value);
			if (osc_width != prev_osc_width) {
				if (debug) {
					fprintf(stderr,"osc_width=%f\n",osc_width);
					fflush(stderr);
				}
				prev_osc_width = osc_width;
				sprintf(tmpstr,"%6.2f",osc_width);
				XmTextFieldSetString(delta_phi_textField,tmpstr);
			}
		} else 
		if(!strncmp(key,"dezinger",8)){
			/*
			char dzngr[32];
			remove_white(value);
			strcpy(dzngr,value);
			if (strcmp(dzngr,prev_dzngr) {
				if (debug) {
					fprintf(stderr,"dzngr=%s\n",dzngr);
					fflush(stderr);
				}
				strcpy(prev_dzngr,dzngr);
				if (!strcmp(dzngr,"no"))
					sprintf(tmpstr,"(%d)",dzngr);
				else
					sprintf(tmpstr," ");
					
				xmstr = XmStringCreateSimple(tmpstr);
				XtSetArg(args[0], XmNlabelString, xmstr);
				XtSetValues(dzngr_label,args,1);
    				XmStringFree(xmstr);
			}
			*/
		} else 
		if(!strncmp(key,"directory",9)){
			remove_white(value);
			strcpy(directory,value);
			if (strcmp(prev_directory,directory)) {
				if (debug) {
					fprintf(stderr,"directory=%s\n",directory);
					fflush(stderr);
				}
				if ((int)strlen(directory) > 2) {
					if (!strcmp(directory+strlen(directory)-2,"//"))
						directory[strlen(directory)-1] = 0;
				}
				strcpy(prev_directory,directory);
				/* OK */
				XmTextFieldSetString(directory_textField,directory);
				update_disk_space(count,directory);
			}
		} else 
		if(!strncmp(key,"current_filename",16)){
			remove_white(value);
			strcpy(image_filename,value);
			if (strcmp(prev_image_filename,image_filename)) {
				if (debug) {
					fprintf(stderr,"image_filename=%s\n",image_filename);
					fflush(stderr);
				}
				strcpy(prev_image_filename,image_filename);
				XmTextFieldSetString(image_textField,image_filename);
				update_runs = 1;
			}
		} else 
		if(!strncmp(key,"previous_filename",17)){
			remove_white(value);
			strcpy(image_prev_filename,value);
			/*
			if (strcmp(prev_image_prev_filename,
				image_prev_filename)) {
				if (debug) {
					fprintf(stderr,"image_prev_filename=%s\n",image_prev_filename);
					fflush(stderr);
				}
				strcpy(prev_image_prev_filename,image_prev_filename);
				XmTextFieldSetString(image_textField,image_prev_filename);
				update_runs = 1;
			}
			*/
		} else 
		if(!strncmp(key,"detector_percent_complete",25)){
			int percent = prev_percent; /* for slider */

			percent = atoi(value);
			if (percent != prev_percent) {	
				if (debug) {
					fprintf(stderr,"percent=%d\n",percent);
					fflush(stderr);
				}
				prev_percent = percent;
				XmScaleSetValue(expose_scale,percent);
				strcpy(prev_scanner_op,""); /* Tell status_message to redraw */
			}
		} else
		if(!strncmp(key,"detector_shutter",16)){
			remove_white(value);
			if (strcmp(value,prev_shutter)) {
   				XmString xmstr;
				Arg args[1];

				strcpy(prev_shutter,value);
				if (debug) {
					fprintf(stderr,"value=\"%s\" prev_shutter=\"%s\"\n",
						value,prev_shutter);
					fflush(stderr);
				}
				if(!strcmp(prev_shutter,"closed")) {

					xmstr = XmStringCreateSimple("Shutter Closed");
					XtSetArg(args[0], XmNlabelString, xmstr);
					XtSetValues(status_shutter_label,args,1);
    					XmStringFree(xmstr);
					if (show_xray_label == True) {
						raise_window(xray_off_label);
						raise_window(xray_off_label2);
						XtUnmanageChild(xray_on_label);
						XtUnmanageChild(xray_on_label2);
					}
				}
				else
					if(!strcmp(prev_shutter,"open")) {
	
					xmstr = XmStringCreateSimple("Shutter Open");
					XtSetArg(args[0], XmNlabelString, xmstr);
					XtSetValues(status_shutter_label,args,1);
    					XmStringFree(xmstr);
					if (show_xray_label == True) {
						raise_window(xray_on_label);
						raise_window(xray_on_label2);
						XtUnmanageChild(xray_off_label);
						XtUnmanageChild(xray_off_label2);
					}
				}
				else {
					xmstr = XmStringCreateSimple(" Shutter ????");
					XtSetArg(args[0], XmNlabelString, xmstr);
					XtSetValues(status_shutter_label,args,1);
    					XmStringFree(xmstr);
					if (show_xray_label == True) {
						XtUnmanageChild(xray_on_label);
						XtUnmanageChild(xray_on_label2);
						XtUnmanageChild(xray_off_label);
						XtUnmanageChild(xray_off_label2);
					 }
					/* oops */
				}
			}
		} else
		if(!strncmp(key,"detector_op",11)){
			int len;

			/* exposing, erasing, scanning or idle */
			if (strcmp(prev_scanner_op,value)) {

			if (debug) {
				fprintf(stderr,"detector_op=%s\n",value);
				fflush(stderr);
			}

			strcpy(prev_scanner_op,value);
			len = strlen(value);
			if (len < 36) {
				char new_value[64];

				for(i=0;i<=(38-len)/2;i++) 
					new_value[i] = ' ';
				new_value[i] = 0;
				strcat(new_value,value);
				XmTextFieldSetString(status_message,new_value);
			}
			else
				XmTextFieldSetString(status_message,value);

			if (!strcmp(value,"idle")) {
				beam_intensity_0 = 0;
				collecting = 0;
				XmTextFieldSetString(status_message,"CCD is Idle.");
				XmScaleSetValue(expose_scale,0);
				XmTextFieldSetString(completion_this_textField,"");
				XmTextFieldSetString(completion_all_textField,"");
			}
			}
		} else
		if(!strncmp(key,"wavelength",10)){
			if(sc_conf.pf_mod)
			{
				double cur_energy;
				wavelength = atof(value);
				if (wavelength != prev_wavelength)
				{
					sprintf(tmpstr,"%.5f",wavelength);
					XmTextFieldSetString(status_wavelength_textField, tmpstr);
					prev_wavelength = wavelength;
					cur_energy = EV_ANGSTROM / wavelength;
					sprintf(tmpstr,"%.1f", cur_energy);
					XmTextFieldSetString(status_energy_textField, tmpstr);
				}
			}
			else if(sc_conf.adsc_slit)
			{
				wavelength = atof(value);
				if (wavelength != prev_wavelength)
				{
					sprintf(tmpstr,"%.5f",wavelength);
					XmTextFieldSetString(status_adsc_slit_wavelength_textField, tmpstr);
					prev_wavelength = wavelength;
				}
			}
			else
			{
				wavelength = atoi(value);
				prev_wavelength = wavelength;
			}
		} else
		if(!strncmp(key,"manual_mode",11)){
				double	ix;
				ix = atoi(value);
				if(ix == 0) {
					XmToggleButtonSetState(gonio_off_pushButton,True,False);
				} else if(ix == 1) {
					XmToggleButtonSetState(gonio_on_pushButton,True,False);
				}
		} else
		if(!strncmp(key,"xl_ion_up",9)){
			if(sc_conf.adsc_slit) {
				double	x;
				x = atof(value);
				if(x != prev_ion_up)
				{
					prev_ion_up = x;
					sprintf(tmpstr," %.3f",x);
					XmTextFieldSetString(mc_up_ion_textField, tmpstr);
				}
			}
		} else
		if(!strncmp(key,"xl_ion_dn",9)){
			if(sc_conf.adsc_slit) {
				double	x;
				x = atof(value);
				if(x != prev_ion_down)
				{
					prev_ion_down = x;
					sprintf(tmpstr," %.3f",x);
					XmTextFieldSetString(mc_dn_ion_textField, tmpstr);
				}
			}
		} else
		if(!strncmp(key,"xl_ion_beam",11)){
			if(sc_conf.adsc_slit) {
				double	x;
				x = atof(value);
				if(x != prev_ion_beam)
				{
					prev_ion_beam = x;
					sprintf(tmpstr," %.3f",x);
					XmTextFieldSetString(mc_beam_ion_textField, tmpstr);
				}
			}
		} else
		if(!strncmp(key,"xl_hs",5)){
			if(sc_conf.adsc_slit) {
				int	ix;
				ix = atoi(value);
				if(ix >= 0 && ix != prev_xl_hs)
				{
					prev_xl_hs = ix;
					sprintf(tmpstr," %4d",ix);
					XmTextFieldSetString(mc_hs_textField, tmpstr);
				}
			}
		} else
		if(!strncmp(key,"xl_vs",5)){
			if(sc_conf.adsc_slit) {
				int	ix;
				ix = atof(value);
				if(ix >= 0 && ix != prev_xl_vs)
				{
					prev_xl_vs = ix;
					sprintf(tmpstr," %4d",ix);
					XmTextFieldSetString(mc_vs_textField, tmpstr);
				}
			}
		} else
		if(!strncmp(key,"xl_guard_hs",11)){
			if(sc_conf.adsc_4slit) {
				int	ix;
				ix = atoi(value);
				if(ix >= 0 && ix != prev_xl_guard_hs)
				{
					prev_xl_guard_hs = ix;
					sprintf(tmpstr," %4d",ix);
					XmTextFieldSetString(mc_guard_hs_textField, tmpstr);
				}
			}
		} else
		if(!strncmp(key,"xl_guard_vs",11)){
			if(sc_conf.adsc_4slit) {
				int	ix;
				ix = atof(value);
				if(ix >= 0 && ix != prev_xl_guard_vs)
				{
					prev_xl_guard_vs = ix;
					sprintf(tmpstr," %4d",ix);
					XmTextFieldSetString(mc_guard_vs_textField, tmpstr);
				}
			}
		} else
		if(!strncmp(key,"hslit",5)){
			if(sc_conf.pf_mod) {
				double	xx;
				xx = atof(value);
				if(xx >= -.9 && xx != prev_hslit)
				{
					prev_hslit = xx;
					sprintf(tmpstr," %.3f",xx);
					XmTextFieldSetString(status_hslit_textField, tmpstr);
					XmTextFieldSetString(strategy_hslit_textField, tmpstr);
				}
			}
		} else
		if(!strncmp(key,"vslit",5)){
			if(sc_conf.pf_mod) {
				double	xx;
				xx = atof(value);
				if(xx >= -.9 && xx != prev_vslit)
				{
					prev_vslit = xx;
					sprintf(tmpstr," %.3f",xx);
					XmTextFieldSetString(status_vslit_textField, tmpstr);
					XmTextFieldSetString(strategy_vslit_textField, tmpstr);
				}
			}
		} else
		if(!strncmp(key,"attenuator",10)){
			if(sc_conf.pf_mod) {
				double	xx;
				int	ix;
				xx = atof(value);
				ix = (int) (xx + .01);
				if(ix >= 0 && xx != prev_attenuator)
				{
					prev_attenuator = xx;
					strcpy(tmpstr, saved_atten_names[ix]);
					XmTextFieldSetString(status_attenuator_textField, tmpstr);
				}
			}
		} else
		if(!strncmp(key,"master",6)){
			if(sc_conf.pf_mod) {
				remove_white(value);
				if(0 != strcmp(prev_master, value))
				{
					strcpy(prev_master, value);
					XmTextFieldSetString(status_master_textField, value);
					XmTextFieldSetString(stars_master_textField, value);
				}
			}
		} else
		if(!strncmp(key,"experiment_mode",15)){
			if(sc_conf.pf_mod) {
				double	xx;
				xx = atof(value);
				if(xx != prev_experiment_mode)
				{
					if(prev_experiment_mode_widget == NULL)
					    XtUnmanageChild(status_label_em_other);
					else
					    XtUnmanageChild(prev_experiment_mode_widget);
					if(xx == 0)
					{
						XtManageChild(status_label_em_other);
						prev_experiment_mode_widget = (status_label_em_other);
					}
					else if(xx == 1)
					{
						XtManageChild(status_label_em_db);
						prev_experiment_mode_widget = (status_label_em_db);
					}
					else if(xx == 2)
					{
						XtManageChild(status_label_em_gsa);
						prev_experiment_mode_widget = (status_label_em_gsa);
					}
					else if(xx == 3)
					{
						XtManageChild(status_label_em_fbsa);
						prev_experiment_mode_widget = (status_label_em_fbsa);
					}
					else if(xx == 4)
					{
						XtManageChild(status_label_em_rbsa);
						prev_experiment_mode_widget = (status_label_em_rbsa);
					}
					else if(xx == 5)
					{
						XtManageChild(status_label_em_lm);
						prev_experiment_mode_widget = (status_label_em_lm);
					}
					else if(xx == 6)
					{
						XtManageChild(status_label_em_cc);
						prev_experiment_mode_widget = (status_label_em_cc);
					}
					else if(xx == 7)
					{
						XtManageChild(status_label_em_xafsm);
						prev_experiment_mode_widget = (status_label_em_xafsm);
					}
					else if(xx == 8)
					{
						XtManageChild(status_label_em_dc);
						prev_experiment_mode_widget = (status_label_em_dc);
					}
					else 
					{
						XtManageChild(status_label_em_other);
						prev_experiment_mode_widget = (status_label_em_other);
					}

					prev_experiment_mode = xx;
				}
			}
		} else
		if(!strncmp(key,"xl_up_hhs",9)){
			if(sc_conf.adsc_slit) {
				int	ix;
				ix = atoi(value);
				if(ix == 0)
					XmToggleButtonSetState(mc_h_up_halfslit_out_pushButton,True,False);
				else if(ix == 1)
					XmToggleButtonSetState(mc_h_up_halfslit_in_pushButton,True,False);
			}
		} else
		if(!strncmp(key,"xl_up_vhs",9)){
			if(sc_conf.adsc_slit) {
				int	ix;
				ix = atoi(value);
				if(ix == 0)
					XmToggleButtonSetState(mc_v_up_halfslit_out_pushButton,True,False);
				else if(ix == 1)
					XmToggleButtonSetState(mc_v_up_halfslit_in_pushButton,True,False);
			}
		} else
		if(!strncmp(key,"xl_dn_hhs",9)){
			if(sc_conf.adsc_slit) {
				int	ix;
				ix = atoi(value);
				if(ix == 0)
					XmToggleButtonSetState(mc_h_dn_halfslit_out_pushButton,True,False);
				else if(ix == 1)
					XmToggleButtonSetState(mc_h_dn_halfslit_in_pushButton,True,False);
			}
		} else
		if(!strncmp(key,"xl_dn_vhs",9)){
			if(sc_conf.adsc_slit) {
				int	ix;
				ix = atoi(value);
				if(ix == 0)
					XmToggleButtonSetState(mc_v_dn_halfslit_out_pushButton,True,False);
				else if(ix == 1)
					XmToggleButtonSetState(mc_v_dn_halfslit_in_pushButton,True,False);
			}
		} else
		if(!strncmp(key,"mode",4)){
			remove_white(value);
			if (strcmp(prev_mode,value)) {
   				XmString xmstr;
				Arg args[1];

				if (debug) {
					fprintf(stderr,"mode=%s\n",value);
					fflush(stderr);
				}
				strcpy(prev_mode,value);
				if (!strcmp(prev_mode,"time")) {
					xmstr = XmStringCreateSimple("Time:");
					XtSetArg(args[0], XmNlabelString, xmstr);
					XtSetValues(dose_time_label,args,1);
    					XmStringFree(xmstr);
				}
				else
				if (!strcmp(prev_mode,"dose")) {
					xmstr = XmStringCreateSimple("Dose:");
					XtSetArg(args[0], XmNlabelString, xmstr);
					XtSetValues(dose_time_label,args,1);
    					XmStringFree(xmstr);
				}
				else
				if (debug)
					fprintf(stderr,"Unknown Status Message: %s\n",buf);
			}
	  	}
		else
		if(!strncmp(key,"alert_msg",9)){
			static char prev_message[256];

			if (!iswhite(value)) {
				Arg args[2];

				if (strcmp(prev_message,value)) {
   					XmString xmstr;
					strcpy(prev_message,value);
					xmstr = XmStringCreateSimple(value);
					XtSetArg(args[0], XmNlabelString, xmstr);
					XtSetValues(alert_label,args,1);
    					XmStringFree(xmstr);
					raise_window(alertDialog);
				}
			}
		}
		else
		if(!strncmp(key,"beam_x",6)){
			beam_x = atof(value);
		} 
		else
		if(!strncmp(key,"beam_y",6)){
			beam_y = atof(value);
		} 
		else
		if(!strncmp(key,"compression",11)){
			/* do nothing */
		} 
		else {
		if (debug)
			fprintf(stderr,"Unknown status message: %s\n",buf);
		}
	}

	fclose(marstatusfp); marstatusfp = NULL;


	/* Disk space only needs to be updated about
	 * every minute (at the most) 
	 */

	if (!(count % ((60 * 1000)/TIMER_MSEC)) ||
	     (image_compression != prev_image_compression)) {
		prev_image_compression = image_compression;
		update_disk_space(count,directory);
	}

	/*
	sprintf(tmpstr,"%6s","122686");
	XmTextFieldSetString(maxI_textField,tmpstr);
	sprintf(tmpstr,"%6s","451");
	XmTextFieldSetString(avgI_textField,tmpstr);
	*/


	total_runs = 0;
	for(i=0; i <= MAX_RUNS; i++) {
		if ( Run[i].nframes > 0 )
			total_runs++;
	}

	if (update_runs) {
		update_runs = 0;
		
		if (!strcmp(prev_image_filename,""))
			current_run = get_run_number(image_filename);
		else
			current_run = get_run_number(prev_image_filename);
		
		if (total_runs > 0) {
			sprintf(tmpstr,"%4d",total_runs);
			/*XmTextFieldSetString(run_of_textField,tmpstr);*/

			if (current_run >= 0) {
				sprintf(tmpstr,"%4d",current_run);
				/*XmTextFieldSetString(run_textField,tmpstr);*/
				current_frame = get_frame_number(prev_image_filename);

			strcpy(tmpstr, current_run_time( current_run,
				current_frame, image_collect_mode, prev_intensity));

			XmTextFieldSetString(completion_this_textField,tmpstr);
			
			strcpy(tmpstr, all_run_time( current_run,
				current_frame, image_collect_mode, prev_intensity ));
			XmTextFieldSetString(completion_all_textField,tmpstr);
			

			}
			/*
			else
				XmTextFieldSetString(run_textField,"");
			*/
		}
		else {
			/*XmTextFieldSetString(run_textField,"");*/
			/*XmTextFieldSetString(run_of_textField,"");*/
		}
	}

#ifdef JUNK
#ifdef IRIX4
	text = XmStringCreate ("Idle", XmSTRING_DEFAULT_CHARSET);
#else
	text = XmStringCreateLocalized("Idle");
#endif /* IRIX4 */
	XtSetArg(args[0], XmNlabelString, text);
	XtSetValues(slider_label,args,1);
	XmStringFree(text);
#endif /* JUNK */
}

/* ARGSUSED */
void
restart_activateCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	char *run_str, *frame_str;
	int i, run_int, frame_int;
	char buf[4096];
	double get_dzratio();
	int change_wavelength;
	double wave;

	strcpy(buf,"");

	run_str = XmTextFieldGetString(restart_run_textfield);
	frame_str = XmTextFieldGetString(restart_frame_textfield);

	run_int = atoi(run_str);
	frame_int = atoi(frame_str);

	XtFree(run_str);
	XtFree(frame_str);

	if (1 || debug) {
		fprintf(stderr,"Restart run %d from frame %d\n",run_int,frame_int);
		fflush(stderr);
	}

	if ((frame_int < 0) || (frame_int > 9999)) {
		sprintf(error_msg,"\nBad Frame Number: %d.\n\nAborting Restart.",frame_int);
		post_error(error_msg);
		return;
	}

	for(i = 0;i <= MAX_RUNS; i++) {
		if (Run[i].number == run_int) {
			if ((frame_int >= Run[i].start) &&
			    (frame_int <= Run[i].start+Run[i].nframes))
			break;
		}
	}

	/*
	 *	If the run is not found and the run is > 100, then it may be
	 *	an MAD restart.  Need to check this.
	 */

	if(i > MAX_RUNS)
	{
	for(i = 0;i <= MAX_RUNS; i++) {
		if(Run[i].number != 0)
		  fprintf(stderr,"Run[%d].number: %d start: %d end: %d\n",i,Run[i].number, Run[i].start, Run[i].start + Run[i].nframes);
		if (Run[i].number == (run_int % 100)) {
			if ((frame_int >= Run[i].start) &&
			    (frame_int <= Run[i].start+Run[i].nframes))
			break;
		}
	}
	}

	if (i > MAX_RUNS) {
		sprintf(error_msg,"\nCould not find Run: %d Frame: %d.\n\nAborting Restart.",
			run_int,frame_int);
		post_error(error_msg);
		return;
	}

	marcommand(ABORT,0.0);
	sleep (2);

	beam_intensity_0 = beam_intensity;

	for( ; i <= MAX_RUNS; i++) {

		if (Run[i].nframes <= 0)
			continue;

		if ((int)strlen(buf) > (4096-1024)) { 
			if (!iswhite(buf) && (marcommandfp != NULL)) {
				fputs(buf,marcommandfp);
				fflush(marcommandfp);
			}
			strcpy(buf,"");
		}

		/* Send a Run */
		sprintf(buf+strlen(buf), "collect\n");
		sprintf(buf+strlen(buf), "distance %1.4f\n", Run[i].distance);
		sprintf(buf+strlen(buf), "lift %1.4f\n", Run[i].offset);
		if (Collect.mode==TIME_MODE) {
			sprintf(buf+strlen(buf), "mode time\n");
			sprintf(buf+strlen(buf), "time %1.4f\n", Run[i].exposure);
		}
		else {
			sprintf(buf+strlen(buf), "mode dose\n");
		  	sprintf(buf+strlen(buf), "step_size %7.3f\n",Collect.step_size);
		  	sprintf(buf+strlen(buf), "time 0.0\n");
		  	sprintf(buf+strlen(buf), "dose_per_step %1.4f\n", 
		   	Run[i].exposure);
                }
		sprintf(buf+strlen(buf), "wavelength %1.4f\n",Collect.wavelength);
		sprintf(buf+strlen(buf), "osc_width %1.4f\n", Run[i].delta_phi);
		sprintf(buf+strlen(buf), "axis %s\n", Run[i].axis);

		if (Run[i].number == (run_int % 100)) {
#ifndef OLD_RESTART
			sprintf(buf+strlen(buf), "restart_run %d\n",run_int);
			sprintf(buf+strlen(buf), "restart_image %d\n",frame_int);

			sprintf(buf+strlen(buf), "image_number %d\n", Run[i].start);
			sprintf(buf+strlen(buf), "n_images %d\n", Run[i].nframes);
			sprintf(buf+strlen(buf), "phi_start %1.4f\n", Run[i].phi);
			sprintf(buf+strlen(buf), "kappa_start %1.4f\n", Run[i].kappa);
			sprintf(buf+strlen(buf), "omega_start %1.4f\n", Run[i].omega);
#else
			sprintf(buf+strlen(buf), "image_number %d\n", frame_int);
			sprintf(buf+strlen(buf), "n_images %d\n", 
				Run[i].nframes - (frame_int - Run[i].start) );
			if (!strcmp(Run[i].axis,"kappa")) {
				sprintf(buf+strlen(buf), "kappa_start %1.4f\n", 
					Run[i].kappa + (frame_int - Run[i].start)*Run[i].delta_phi);
				sprintf(buf+strlen(buf), "phi_start %1.4f\n", Run[i].phi);
				sprintf(buf+strlen(buf), "omega_start %1.4f\n", Run[i].omega);
			}
			else
			if (!strcmp(Run[i].axis,"omega")) {
				sprintf(buf+strlen(buf), "omega_start %1.4f\n", 
					Run[i].omega + (frame_int - Run[i].start)*Run[i].delta_phi);
				sprintf(buf+strlen(buf), "phi_start %1.4f\n", Run[i].phi);
				sprintf(buf+strlen(buf), "kappa_start %1.4f\n", Run[i].kappa);
			}
			else
			if (!strcmp(Run[i].axis,"phi")) {
				sprintf(buf+strlen(buf), "phi_start %1.4f\n", 
					Run[i].phi + (frame_int - Run[i].start)*Run[i].delta_phi);
				sprintf(buf+strlen(buf), "kappa_start %1.4f\n", Run[i].kappa);
				sprintf(buf+strlen(buf), "omega_start %1.4f\n", Run[i].omega);
			}
			else {
				fprintf(stderr,"Unknown axis: \"%s\"\n",Run[i].axis); fflush(stderr);
				fprintf(stderr,"Assuming axis is phi\n"); fflush(stderr);

				sprintf(buf+strlen(buf), "phi_start %1.4f\n", 
					Run[i].phi + (frame_int - Run[i].start)*Run[i].delta_phi);
				sprintf(buf+strlen(buf), "kappa_start %1.4f\n", Run[i].kappa);
				sprintf(buf+strlen(buf), "omega_start %1.4f\n", Run[i].omega);
			}
#endif /* OLD_RESTART */
		}
		else {
			sprintf(buf+strlen(buf), "image_number %d\n", Run[i].start);
			sprintf(buf+strlen(buf), "n_images %d\n", Run[i].nframes);
			sprintf(buf+strlen(buf), "phi_start %1.4f\n", Run[i].phi);
			sprintf(buf+strlen(buf), "kappa_start %1.4f\n", Run[i].kappa);
			sprintf(buf+strlen(buf), "omega_start %1.4f\n", Run[i].omega);
		}


		if((!strncmp(Run[i].dzngr,"n",1))||
		   (!strncmp(Run[i].dzngr,"N",1))||
		   (!strncmp(Run[i].dzngr,"0",1))) {
			sprintf(buf+strlen(buf), "de_zinger 0\n");
		}
		else {
			double dzratio;

			dzratio = get_dzratio(Run[i].dzngr);

			sprintf(buf+strlen(buf), "de_zinger 1\n");
			sprintf(buf+strlen(buf), "dzratio %f\n",dzratio);
		}

		sprintf(buf+strlen(buf), "directory %s\n",Collect.directory);
		sprintf(buf+strlen(buf), "image_prefix %s_%d\nimage_suffix %s\n",
			Collect.prefix, Run[i].number, Collect.suffix );
		if (!iswhite(Run[i].blstr))
			sprintf(buf+strlen(buf), "blcmd %s\n",Run[i].blstr);

		sprintf(buf+strlen(buf), "bin %d\n",Collect.bin);
		if(sc_conf.t2k_detector == 1)
		{
			if(Collect.bin == 1)
				sprintf(buf+strlen(buf), "adc 0\n");
			else
				sprintf(buf+strlen(buf), "adc %d\n",Collect.adc);
		}
		else
		{
			sprintf(buf+strlen(buf), "adc %d\n",Collect.adc);
		}

		if (Collect.anomalous == 1) {
			sprintf(buf+strlen(buf), "anomalous 1\n");
			sprintf(buf+strlen(buf), "wedge %d\n",Collect.wedge);
		}
		sprintf(buf+strlen(buf), "center %f %f\n",Collect.center_x,Collect.center_y);
		sprintf(buf+strlen(buf), "outfile_type %d\n",Collect.outfile_type);
		sprintf(buf+strlen(buf), "output_raw %d\n",Collect.output_raw);
		sprintf(buf+strlen(buf), "no_transform %d\n",Collect.no_transform);

		if (Collect.dk_before_run == 1) {
			sprintf(buf+strlen(buf), "dk_before_run %d\n", 1);
		}
		else {
			sprintf(buf+strlen(buf), "dk_before_run %d\n", 0);
		}

		if (Collect.repeat_dark == 1) {
			sprintf(buf+strlen(buf), "repeat_dark 1\n");
			sprintf(buf+strlen(buf), "darkinterval %d\n",
				Collect.darkinterval);
		}
		else {
			sprintf(buf+strlen(buf), "repeat_dark 0\n");
		}
		switch  (Collect.compression) 
		{
			case COMP_NONE:
				sprintf(buf+strlen(buf), "compress none\n");
				break;
			case COMP_Z:
				sprintf(buf+strlen(buf), "compress .Z\n");
				break;
			case COMP_PCK:
				sprintf(buf+strlen(buf), "compress .pck\n");
				break;
			default:
				sprintf(buf+strlen(buf), "compress none\n");
				break;
		}


		if (XmToggleButtonGetState(mad_option1_toggleButton) == True) {
			/* Never Change Energy */
			change_wavelength=0;
		}
		else
		if (XmToggleButtonGetState(mad_option2_toggleButton) == True) {
			/* Change Energy Each Run */
			sprintf(buf+strlen(buf), "mad run\n");
			change_wavelength=1;
		}
		else
		if (XmToggleButtonGetState(mad_option3_toggleButton) == True) {
			/* Change Energy Each Anomalous Wedge */
			sprintf(buf+strlen(buf), "mad wedge\n");
			change_wavelength=1;
		}
		else
		if (XmToggleButtonGetState(mad_option4_toggleButton) == True) {
			/* Change Energy Each N frames */
			int nf;
			nf = TextFieldGetInt(mad_nframes_textField);
			if (nf < 0 || nf > 10000) {
				fprintf(stderr,"warning: N frames = %d, set to %d\n",nf,0);
				nf = 0;
			}
			sprintf(buf+strlen(buf), "mad frames %d\n",nf);
			change_wavelength=1;
		}
		if (change_wavelength) {
			sprintf(buf+strlen(buf), "mad_wave ");
			if (XmToggleButtonGetState(enable_wavelength1_toggleButton) == True) {
				wave = TextFieldGetFloat(wavelength1_textField);
				if (wave > 0.0) {
					sprintf(buf+strlen(buf), "%1.6f ",wave);
				}
			}
			if (XmToggleButtonGetState(enable_wavelength2_toggleButton) == True) {
				wave = TextFieldGetFloat(wavelength2_textField);
				if (wave > 0.0) {
					sprintf(buf+strlen(buf), "%1.6f ",wave);
				}
			}
			if (XmToggleButtonGetState(enable_wavelength3_toggleButton) == True) {
				wave = TextFieldGetFloat(wavelength3_textField);
				if (wave > 0.0) {
					sprintf(buf+strlen(buf), "%1.6f ",wave);
				}
			}
			if (XmToggleButtonGetState(enable_wavelength4_toggleButton) == True) {
				wave = TextFieldGetFloat(wavelength4_textField);
				if (wave > 0.0) {
					sprintf(buf+strlen(buf), "%1.6f ",wave);
				}
			}
			if (XmToggleButtonGetState(enable_wavelength5_toggleButton) == True) {
				wave = TextFieldGetFloat(wavelength5_textField);
				if (wave > 0.0) {
					sprintf(buf+strlen(buf), "%1.6f ",wave);
				}
			}
			sprintf(buf+strlen(buf), "\n");
		}
	}


	if (!iswhite(buf) && (marcommandfp != NULL)) {
		strcat(buf,"eoc\n");
		
		fputs(buf,marcommandfp);
		fflush(marcommandfp);
		collecting = 1;
	}

	/*XtUnmanageChild(restartRun_dialog);*/
}

/* ARGSUSED */
void
main_mapCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{

	if (debug) {
		fprintf(stderr,"CAlled main_mapCallback...\n");
		fflush(stderr);
	}
}

/* ARGSUSED */
void
close_mc_activateCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{

	XtUnmanageChild(manual_controlDialog);
}

/* ARGSUSED */
void
strategy_close_activateCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	
	XtUnmanageChild(strategyDialog);
}

/* ARGSUSED */
void
close_snap_activateCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{

	XtUnmanageChild(snapshotDialog);
}

/* ARGSUSED */
void
close_status_activateCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{

	XtUnmanageChild(statusDialog);
}

/* ARGSUSED */
void
main_createCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	static int init;
	Screen *screen; 
	Arg args[2];

	if (debug) {
		fprintf(stderr,"Called main_createCallback....\n");
		fflush(stderr);
	}

	if (!init) {
		init=1;
		screen = XtScreen(bulletinBoard);
		scr_width = WidthOfScreen(screen);
		scr_height = HeightOfScreen(screen);
		if (debug) {
			fprintf(stderr,"Screen is %d x %d pixels\n",scr_width,scr_height);
			fflush(stderr);
		}
		/*init_adx(); */
		/*
		XtSetArg(args[0], XmNx, scr_width + MAIN_X-500);
		XtSetArg(args[1], XmNy, MAIN_Y+400);
		XtSetValues(bulletinBoard,args,2);
		*/

		/*XtMoveWidget(bulletinBoard, scr_width + MAIN_X-500,MAIN_Y+600);*/
	}
}

/* ARGSUSED */
void
stopnow_activateCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	static int init=0;
	Arg args[4];
	int dest_x, dest_y;
	Dimension m_XmNx, m_XmNy, m_XmNwidth, m_XmNheight;

	if (!init) {
		init=1;
		XtSetArg(args[0], XmNx, 450);
		XtSetArg(args[1], XmNy, 450);
		XtSetValues(abortDialog,args,2);
	}
	raise_window(abortDialog);

	XtVaGetValues(pushButton18,
		XmNx, &m_XmNx,
		XmNy, &m_XmNy,
		XmNwidth, &m_XmNwidth,
		XmNheight, &m_XmNheight,
		NULL);

	dest_x = m_XmNx + m_XmNwidth/2;
	dest_y = m_XmNy + m_XmNheight/2;

	/*XWarpPointer(display, None, window, 0, 0, 0, 0, dest_x, dest_y);*/
	
	XWarpPointer(display, None, XtWindow(pushButton18),
		0, 0, 0, 0, m_XmNwidth/2, m_XmNheight/2);
}

/* ARGSUSED */
void
stopnexti_activateCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	static int init=0;
	Arg args[4];
	int dest_x, dest_y;
	Dimension m_XmNx, m_XmNy, m_XmNwidth, m_XmNheight;

	if (!init) {
		init=1;
		XtSetArg(args[0], XmNx, 400);
		XtSetArg(args[1], XmNy, 400);
		XtSetValues(stopDialog,args,2);
	}
	raise_window(stopDialog);

	XtVaGetValues(pushButton5,
		XmNx, &m_XmNx,
		XmNy, &m_XmNy,
		XmNwidth, &m_XmNwidth,
		XmNheight, &m_XmNheight,
		NULL);

	dest_x = m_XmNx + m_XmNwidth/2;
	dest_y = m_XmNy + m_XmNheight/2;

	/*XWarpPointer(display, None, window, 0, 0, 0, 0, dest_x, dest_y);*/
	
	XWarpPointer(display, None, XtWindow(pushButton5),
		0, 0, 0, 0, m_XmNwidth/2, m_XmNheight/2);
}

/* ARGSUSED */
void
status_activateCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	static int init=0;
	Arg args[2];

	if (!init) {
		init=1;
		XtSetArg(args[0], XmNx, scr_width + STATUSDIALOG_X);
		XtSetArg(args[1], XmNy, STATUSDIALOG_Y);
		XtSetValues(statusDialog,args,2);
	}
	raise_window(statusDialog);
}

/* ARGSUSED */
void
version_activateCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{

	raise_window(versionDialog);
}

/* ARGSUSED */
void
newline_activateCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{

	XmProcessTraversal (w, XmTRAVERSE_NEXT_TAB_GROUP);
}

/* PF Start */

/* ARGSUSED */
void
mc_atten_activateCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	marcommand(SET_ATTENUATOR, (double)((int) client));
}

/* PF End */

/* ADSC_SLIT Start */

void
mc_v_up_halfslit_out_armCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	marcommand(XL_UP_VHS, 0.0);
}

void
mc_v_up_halfslit_in_armCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	marcommand(XL_UP_VHS, 1.0);
}

void
mc_h_up_halfslit_out_armCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	marcommand(XL_UP_HHS, 0.0);
}

void
mc_h_up_halfslit_in_armCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	marcommand(XL_UP_HHS, 1.0);
}

void
mc_v_dn_halfslit_out_armCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	marcommand(XL_DN_VHS, 0.0);
}

void
mc_v_dn_halfslit_in_armCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	marcommand(XL_DN_VHS, 1.0);
}

void
mc_h_dn_halfslit_out_armCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	marcommand(XL_DN_HHS, 0.0);
}

void
mc_h_dn_halfslit_in_armCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	marcommand(XL_DN_HHS, 1.0);
}

void
mc_vs_armCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
}

void
mc_hs_armCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
}
void
mc_vs_activateCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
}

void
mc_hs_activateCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
}
void
mc_vs_apply_Callback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	double	val;

	if (XmToggleButtonGetState(mc_vs_drive_pushButton) == True)
		val = wtof(mc_vs_textField);
	else
	{
		XmToggleButtonSetState(mc_vs_drive_pushButton,True,False);
		XmToggleButtonSetState(mc_vs_zero_pushButton,False,False);
		if(sc_conf.pf_mod)
			val = -1;
		else
			val = 0;
	}
		
	if(sc_conf.pf_mod)
		marcommand(VS, val);
	else
		marcommand(XL_VS, val);
}

void
mc_hs_apply_Callback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	double	val;

	if (XmToggleButtonGetState(mc_hs_drive_pushButton) == True)
		val = wtof(mc_hs_textField);
	else
	{
		XmToggleButtonSetState(mc_hs_drive_pushButton,True,False);
		XmToggleButtonSetState(mc_hs_zero_pushButton,False,False);
		if(sc_conf.pf_mod)
			val = -1;
		else
			val = 0;
	}
		
	if(sc_conf.pf_mod)
		marcommand(HS, val);
	else
		marcommand(XL_HS, val);
}

void
mc_guard_vs_armCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
}

void
mc_guard_hs_armCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
}
void
mc_guard_vs_activateCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
}

void
mc_guard_hs_activateCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
}
void
mc_guard_vs_apply_Callback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	double	val;

	if (XmToggleButtonGetState(mc_guard_vs_drive_pushButton) == True)
		val = wtof(mc_guard_vs_textField);
	else
	{
		XmToggleButtonSetState(mc_guard_vs_drive_pushButton,True,False);
		XmToggleButtonSetState(mc_guard_vs_zero_pushButton,False,False);
		if(sc_conf.pf_mod)
			val = -1;
		else
			val = 0;
	}
		
	if(sc_conf.pf_mod)
		marcommand(VS, val);
	else
		marcommand(XL_GUARD_VS, val);
}

void
mc_guard_hs_apply_Callback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	double	val;

	if (XmToggleButtonGetState(mc_guard_hs_drive_pushButton) == True)
		val = wtof(mc_guard_hs_textField);
	else
	{
		XmToggleButtonSetState(mc_guard_hs_drive_pushButton,True,False);
		XmToggleButtonSetState(mc_guard_hs_zero_pushButton,False,False);
		if(sc_conf.pf_mod)
			val = -1;
		else
			val = 0;
	}
		
	if(sc_conf.pf_mod)
		marcommand(HS, val);
	else
		marcommand(XL_GUARD_HS, val);
}

/* ADSC_SLIT End */

/* PF_MOD Start */

void
mc_em_dc_apply_Callback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	marcommand(EM, 8.0);
}

void
mc_em_cc_apply_Callback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	marcommand(EM, 6.0);
}

void
mc_em_lm_apply_Callback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	marcommand(EM, 5.0);
}

void
mc_em_xafsm_apply_Callback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	marcommand(EM, 7.0);
}

/* PF_MOD End */

/* ARGSUSED */
void
open_shutter_activateCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{

	marcommand(OPEN_SHUTTER, 0.0);
}

/* ARGSUSED */
void
close_shutter_activateCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	marcommand(CLOSE_SHUTTER, 0.0);
}

/* ARGSUSED */
void
strategy_restart_activateCb(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	char run_str[16], *frame_str;
	int run_int= -1, frame_int;

	/*run_str = XmTextFieldGetString(run_textField);*/
	/*sscanf(run_str,"%d",&run_int);*/
	run_int = get_run_number(image_filename);
	sprintf(run_str,"%d",run_int);
	if ((run_int < 0) || (run_int > MAX_RUNS))
		sprintf(run_str,"1");
	XmTextFieldSetString(restart_run_textfield,run_str);
	/*XtFree(run_str);*/

	frame_str = XmTextFieldGetString(image_textField);
	frame_int = get_frame_number(frame_str);
	if ((frame_int < 0) || (frame_int > 999))
		frame_int = 1;
	sprintf(frame_str,"%d",frame_int);
	XmTextFieldSetString(restart_frame_textfield,frame_str);
	XtFree(frame_str);

	raise_window(restartRun_dialog);
}

/* ARGSUSED */
void
versionclose_activateCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{

	XtUnmanageChild(versionDialog);
}

/* ARGSUSED */
void
mc_help_activateCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	Unmanage_helpWindow();
	XtManageChild(manualcontrol_helpWindow);

	raise_window(adx_helpDialog);
}

/* ARGSUSED */
void
status_help_activateCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	Unmanage_helpWindow();
	XtManageChild(status_helpWindow);

	raise_window(adx_helpDialog);
}

/*      Function Name: AdxVerifyNumericCB
 *      Description:   Used as the XmNmodifyVerify callback on a text
 *             or text field widget. Allows only numeric characters
 *             to be entered [decimal point and sign allowed].
 *      Arguments:     Widget     w:  the widget calling the function.
 *             XtPointer	client:  unused
 *             XtPointer	call:  pointer to XmTextVerifyCallbackStruct
 */

/* ARGSUSED */
void
AdxVerifyNumericCB ARGLIST((w, client, call))
UARG( Widget, w)
UARG( XtPointer, client)
GRA( XtPointer, call)
{
	XmTextVerifyCallbackStruct *theVerifyCB;
	XmTextBlock textBlock;	 /* the text to be inserted */
	XmTextPosition startPos;
	char *wstr;
 
	theVerifyCB = (XmTextVerifyCallbackStruct *)call;
	textBlock = theVerifyCB->text;
	startPos =  theVerifyCB->startPos;

	if (textBlock->length == 1) {
		/*
		if (textBlock->ptr[0] == 'u') {
			XtCallActionProc(w,"delete-to-start-of-line",theVerifyCB->event,NULL,0);
			theVerifyCB->doit = False;
		}	
		if (textBlock->ptr[0] == 'h') {
			XtCallActionProc(w,"delete-previous-character",theVerifyCB->event,NULL,0);
			theVerifyCB->doit = False;
		}	
		*/
		if ( !isascii(textBlock->ptr[0] )) {
			theVerifyCB->doit = False;
		}
		if ( !isdigit(textBlock->ptr[0]) ) {
			wstr = (char *)XmTextGetString(w);
			if ((startPos==0) && ((textBlock->ptr[0] == '-') || (textBlock->ptr[0] == '+')) )
				;
			else
			if ((textBlock->ptr[0] == '.') && (strchr(wstr,'.') == NULL))
				;
			else
			theVerifyCB->doit = False;
			XtFree(wstr);
		}
	}
    /*
     * keyboard bell will be rung  by default
     */
}

/* ARGSUSED */
void
AdxVerifyAlphaNumericCB ARGLIST((w, client, call))
UARG( Widget, w)
UARG( XtPointer, client)
GRA( XtPointer, call)
{
	XmTextVerifyCallbackStruct *theVerifyCB;
	XmTextBlock textBlock;	 /* the text to be inserted */
	XmTextPosition startPos;
 
	theVerifyCB = (XmTextVerifyCallbackStruct *)call;
	textBlock = theVerifyCB->text;
	startPos =  theVerifyCB->startPos;

	if (textBlock->length == 1) {
		/*
		if (textBlock->ptr[0] == 'u') {
			XtCallActionProc(w,"delete-to-start-of-line",theVerifyCB->event,NULL,0);
			theVerifyCB->doit = False;
		}	
		if (textBlock->ptr[0] == 'h') {
			XtCallActionProc(w,"delete-previous-character",theVerifyCB->event,NULL,0);
			theVerifyCB->doit = False;
		}	
		*/
		if ( !isascii(textBlock->ptr[0] )) {
			theVerifyCB->doit = False;
		}
	}
}

/* ARGSUSED */
/* AOK */
void
text_modifyVerifyCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	XmTextVerifyCallbackStruct *vcs=(XmTextVerifyCallbackStruct*)call;
	XmTextPosition currInsert, newInsert, startPos, endPos;
	int i, reason, strlength, textlength;
	int current_line, current_column, current_field;
	int next_column, next_field;
	char *tstr, *textptr, lastchar;
        char space[2], spaces[2*M_MAX_CHAR+1], field_str[32];
	static char prev_char;

	/* debug = 1;/* OK */

	if (debug) {
		fprintf(stderr,"Called text_modifyVerifyCallback()...\n");
		fflush(stderr);
	}

	if (mvc_return==1)
		return;

	strcpy(space," ");

	for(i=0;i<(2*MAX_CHAR);i++)
		spaces[i] = SPACE_CHAR;

	reason     = vcs->reason;
	currInsert = vcs->currInsert;
	newInsert  = vcs->newInsert;
	startPos   = vcs->startPos;
	endPos     = vcs->endPos;
	textptr    = (vcs->text)->ptr;
	textlength = (vcs->text)->length;

	if (textlength > 1)
	{
		/*
		static char cc[2];
		static XmTextVerifyCallbackStruct myvcs;
		char p_char=' ';

		myvcs.text = (XmTextBlock)malloc(sizeof(XmTextBlockRec));
		while(textptr && *textptr) {

			cc[0] = *textptr;
			cc[1] = 0;

			if (isspace(p_char) && isspace(cc[0])) {
				textptr++;
				continue;
			}

			myvcs.reason = 20;
			myvcs.currInsert = XmTextGetInsertionPosition(w);
			myvcs.newInsert = XmTextGetInsertionPosition(w);
			myvcs.startPos = XmTextGetInsertionPosition(w);
			myvcs.endPos = XmTextGetInsertionPosition(w);
			(myvcs.text)->ptr = cc;
			(myvcs.text)->length = 1;
			(myvcs.text)->format = (vcs->text)->format;

			myvcs.doit = True;
    			myvcs.event = vcs->event;
			text_modifyVerifyCallback(w, client, &myvcs);
			p_char = cc[0];
			textptr++;
		}
		free(myvcs.text);
		*/
		vcs->doit = False;
		return;
	}


	current_line = find_row(w, startPos);
	current_column = find_column(w, startPos);
	current_field = find_field(current_column);

	if (debug) {
		fprintf(stderr,"Line: %d Column: %d Field: %d\n",
			current_line,current_column,current_field);
		fflush(stderr);
		fprintf(stderr,"reason: %d length: %d\n", reason,textlength); 
		fprintf(stderr,"startPos: %d endPos: %d currInsert: %d newInsert: = %d\n",
			startPos,endPos,currInsert,newInsert); 
	}

	if (textlength == 1) {
		if ( !isascii(textptr[0] )) {
			vcs->doit = False;
			prev_char = textptr[0];
			return;
		}

		if ((beamline_mode==True)&&(current_field==(n_fields-1)))
			;
		else
		if ( !isdigit(textptr[0]) ) {
			if (textptr[0] == 'w' || textptr[0] == 'W')
				textptr[0] = ' ';
			else
			if ((textptr[0] == '-') || (textptr[0] == '+') || (textptr[0] == '.') ||
			    (textptr[0] == ' ') || (textptr[0] == '\t') || (textptr[0] == '\n'))
				;
			else 
			if (textptr[0] == 'O') { /* Open Line Above */
				if (current_field == 8) {
					textptr[0] = 'o';
				}
				else {
					mvc_return=1;
					spaces[MAX_CHAR-1] = '\n';
					spaces[MAX_CHAR] = 0;
					XmTextReplace(w,find_index(w, current_line, 0),
						find_index(w, current_line, 0),spaces);
					XmTextSetInsertionPosition(w, find_index(w, current_line, 3));
					for(i=0;i<n_fields;i++)
						clean_up(w, current_line+1, i);
					mvc_return=0;
					vcs->doit = False;
					prev_char = textptr[0];
					return;
				}
			}
			else 
			if (textptr[0] == 'o') { /* Open Line Below */
				int findex, fcol;
				if (current_field == 8) {
					;
				}
				else {
					mvc_return=1;

					fcol=find_column(w,(findex=find_index(w, current_line, -1)))+1;

					if (debug) {
						fprintf(stderr,"fcol = %d MAX_CHAR=%d\n",fcol,MAX_CHAR);
						fflush(stderr);
					}

					if (fcol < MAX_CHAR)
						spaces[MAX_CHAR-fcol-1] = '\n';
					else
						spaces[0] = '\n';
					spaces[MAX_CHAR+MAX_CHAR-fcol] = 0;
					if (debug) {
						fprintf(stderr,"Replace with \"%s\" (%d)\n",
							spaces,strlen(spaces));
						fflush(stderr);
					}
					XmTextReplace(w,findex, findex,spaces);
					for(i=0;i<n_fields;i++)
						clean_up(w, current_line, i);
					XmTextSetInsertionPosition(w, find_index(w, current_line+1, 3));
					mvc_return=0;
					vcs->doit = False;
					prev_char = textptr[0];
					return;
				}
			}
			else
			if ((textptr[0] == 'D') ||
			   ((textptr[0] == 'd') && (prev_char == 'd'))) { /* Delete Line */
				mvc_return=1;
				if (debug) {
					fprintf(stderr,"Replace: %d to %d\n",
						find_index(w, current_line, 0),
						find_index(w, current_line, -1)+1);
					fflush(stderr);
				}
				tstr = (char *)XmTextGetString(w);
				strlength = strlen(tstr);
				XtFree(tstr);

				if (strlength <= find_index(w, current_line, -1)) {
					XmTextReplace(w,find_index(w, current_line, 0),
						strlength,"");
				}
				else {
					XmTextReplace(w,find_index(w, current_line, 0),
						find_index(w, current_line, -1)+1,"");
				}
				if ((find_index(w, current_line, -1) <= find_index(w, current_line, 3)) &&
				    (current_line > 0))
					XmTextSetInsertionPosition(w, find_index(w, current_line-1, 3));
				else
					XmTextSetInsertionPosition(w, find_index(w, current_line, 3));
				tstr = (char *)XmTextGetString(w);
				strlength = strlen(tstr);
				XtFree(tstr);

				if (debug) {
					fprintf(stderr,"strlen=%d\n",strlength);
					fflush(stderr);
				}
				if (strlength < 3) {
					XmTextReplace(w, 0, 0, "   ");
					XmTextSetInsertionPosition(w, 3);
				}

				mvc_return=0;
				prev_char = 0;
				vcs->doit = False;
				return;
			}
			else
			if (textptr[0] == 'h') {
				if (current_field == 8) {
					;
				}
				else {
					mvc_return=1;
					/*XmTextSetInsertionPosition(w, XmTextGetInsertionPosition(w)-1);*/
					/*XtCallActionProc(w,"backward-character",vcs->event,NULL,0);*/

					if (adjust_position(w, startPos-1, XK_Left) == 1)
						XtCallActionProc(w,"backward-character",vcs->event,NULL,0);

					mvc_return=0;
					vcs->doit = False;
					return;
				}
			}
			else
			if (textptr[0] == 'l') {
				mvc_return=1;
				/*XmTextSetInsertionPosition(w, XmTextGetInsertionPosition(w)+1);*/
				/*XtCallActionProc(w,"forward-character",vcs->event,NULL,0);*/
				if (adjust_position(w, startPos+1, XK_Right) == 1)
					XtCallActionProc(w,"forward-character",vcs->event,NULL,0);
				mvc_return=0;
				vcs->doit = False;
				return;
			}
			else
			if (textptr[0] == 'k') {
				if (current_field == 8) {
					;
				}
				else {
					mvc_return=1;
					XtCallActionProc(w,"previous-line",vcs->event,NULL,0);
					/*
					if (current_line > 0)
						XmTextSetInsertionPosition(w,
							find_index(w, current_line-1, current_column));
				 	*/
					mvc_return=0;
					vcs->doit = False;
					return;
				}
			}
			else
			if (textptr[0] == 'j') {
				mvc_return=1;
				XtCallActionProc(w,"next-line",vcs->event,NULL,0);
				/*
				XmTextSetInsertionPosition(w,
					find_index(w, current_line+1, current_column));
				 */
				mvc_return=0;
				vcs->doit = False;
				return;
			}
			else
			if (textptr[0] == 'b') { /* Back to previous field */
				/*
				mvc_return=1;
				XtCallActionProc(w,"backward-word",vcs->event,NULL,0);
				mvc_return=0;
				vcs->doit = False;
				return;
				*/

				mvc_return=1;
				/* Move to previous field */
				if (current_field > 0) {
					XmTextSetInsertionPosition(w,
						find_index(w, current_line,
						fld[current_field-1].col_end)+1);
				}
				else { /* Move to previous line */
					XtCallActionProc(w,"previous-line",vcs->event,NULL,0);
				}
				mvc_return=0;
				vcs->doit = False;
				return;
			}
			else
			if ((current_field == 8) && (strchr("kappaomegaphi",textptr[0]) != NULL)) {
					;
			}
			else
			if ((current_field == 11) && (strchr("YNyn/",textptr[0]) != NULL)) {
					;
			}
			else {
				vcs->doit = False;
				prev_char = textptr[0];
				return;
			}
		}
		prev_char = textptr[0];
	}


	/* There are 4 things the user could have done:
	 *
	 * 1. Typed any character except delete.
	 * 2. Typed the delete character.
	 * 3. Selected some text and then typed (1).
	 * 4. Selected some text and then typed (2).
	 *
	 */
	if (textlength > 0) {	
		lastchar = textptr[textlength-1]; 
		if (textlength > (endPos-startPos) ) {
				;			/* Case 1 */
		}
		else {
			/*spaces[endPos-startPos] = 0;	/* Case 3 */
			if (debug) {
				fprintf(stderr,"endPos = %d END OF LINE = %d\n",
					endPos,find_index(w, current_line, -1));
				fflush(stderr);
			}
			/*spaces[find_column(w,endPos)-find_column(w,startPos)]=0;*/
			if (find_index(w, current_line, -1)  < endPos) {
				endPos = find_index(w, current_line, -1);
			}
			if (startPos == endPos) {
				vcs->doit = False;
				return;
			}
			spaces[endPos-startPos]=0;
			spaces[0] = lastchar;
			mvc_return=1;
			XmTextReplace(w,startPos,endPos,spaces);
			if (debug) {
				fprintf(stderr,"replace %d to %d with \"%s\"\n",
					startPos,endPos,spaces);
				fflush(stderr);
			}
			if(find_column(w,endPos) > fld[current_field].col_end) {
				XmTextSetInsertionPosition(w,
					find_index(w, current_line,
					fld[current_field].col_end)+1);
			}
			mvc_return=0;
			vcs->doit = False;
			no_white(w, current_line, current_field);


			if (is_blank(w, current_line)) { /* OK */
				XmTextReplace(w,find_index(w, current_line, 0),
					find_index(w, current_line, -1)+1,"");
				XmTextSetInsertionPosition(w, find_index(w, current_line, 3));
			}


			return;
		}
	}
	else { 						/* Cases 2 & 4 */
		if (debug) {
			fprintf(stderr,"Case 2 & 4...\n");
			fflush(stderr);
		}
		mvc_return=1;

		if ((startPos == find_index(w, current_line, 0)) && 
		    (endPos == (find_index(w, current_line, -1)+1))) {
			XmTextReplace(w,startPos,endPos,"");
		}
		else {
			tstr = (char *)XmTextGetString(w);

			if ((find_column(w,startPos) == 0) && (endPos == strlen(tstr))) {
				XmTextReplace(w,find_index(w, current_line, 0),
					strlen(tstr)-1,"   ");
					if (current_line > 0)
						current_line--;
					if (startPos > 0)
						endPos = startPos-1;
					else
						endPos = 0;
			}
			else {
				if (endPos >= strlen(tstr))
					endPos = strlen(tstr) - 1;
				tstr[endPos]=0;
		    		/*if ((tstr[startPos] == '\n')) {*/
		    		if ((tstr[startPos] == ' ') || (tstr[startPos] == '\n')) { /* OK */
					startPos--;
					endPos--;
					tstr[endPos]=0;
				}
				if (tstr[startPos] != '\n') {
					strreplace(tstr+startPos,' ');
					XmTextReplace(w,startPos,endPos,tstr+startPos);
				}
				else {
					startPos++;
					endPos++;
				}
				if (endPos < find_index(w, current_line,
						fld[0].col_end)+1)
					endPos = find_index(w, current_line,
                                                fld[0].col_end)+1;
					
			}
			XtFree(tstr);
		}

		/*Set current insertion position to end of current field */
		if (find_column(w,endPos) > fld[current_field].col_end) {
			XmTextSetInsertionPosition(w,
				find_index(w, current_line,
				fld[current_field].col_end)+1);
		}
		else {
			XmTextSetInsertionPosition(w,endPos);
		}
		/* 
		XmTextSetInsertionPosition(w, 
			find_index(w, current_line, fld[current_field].col_end)+1);
		 */

		mvc_return=0;
		vcs->doit = False;
		extract_field(w,field_str,current_line,current_field);
		if (!iswhite(field_str)) {
			no_white(w, current_line, current_field);
		}
		return;
	}

#ifdef NOT_USED
		extract_field(w, field_str,current_line, current_field);
		if (iswhite(field_str)) {
			/* Move to previous field */
			if (current_field > 0) {
				XmTextSetInsertionPosition(w,
					find_index(w, current_line,
					fld[current_field-1].col_end)+1);
			}
			else { /* Move to previous line */
				XtCallActionProc(w,"previous-line",vcs->event,NULL,0);
			}
			mvc_return=0;
			vcs->doit = False;
			return;
		}

		if (debug) {
			fprintf(stderr,"Delete from %d to %d \n",startPos,endPos);
			fflush(stderr);
		}
			/*
			if (current_line < 1) {
				XmTextSetInsertionPosition(w,
					find_index(w, 1, fld[0].col_end)+1);
			}
			else
			*/
		if (debug) {
			fprintf(stderr,"current_line = %d Ins = %d End = %d %d\n",
				current_line,
				find_index(w, current_line+1, fld[0].col_end)+1,
				find_index(w, current_line, -1),
				find_index(w, current_line+1, -1));
			fflush(stderr);
		}

		if ((find_index(w, current_line+1, fld[0].col_end)+1) >=
			find_index(w, current_line+1, -1)) {
			if (debug) {
				fprintf(stderr,"find_index OOPS...\n");
				fflush(stderr);
			}
			XmTextSetInsertionPosition(w,
				find_index(w, current_line-1, fld[0].col_end)+1);
		}
		else {
			if (debug) {
				fprintf(stderr,"Set insertion to %d\n",
					find_index(w, current_line+1, fld[0].col_end)+1);
				fflush(stderr);
			}
			XmTextSetInsertionPosition(w,
				find_index(w, current_line+1, fld[0].col_end)+1);
		}
			 
		mvc_return=0;
		return;

		for(i=0;i<(2*MAX_CHAR);i++)
		spaces[i] = SPACE_CHAR;
		/*spaces[endPos-startPos] = 0;	/* Case 3 */
		if (debug) {
			fprintf(stderr,"endPos = %d END OF LINE = %d\n",
				endPos,find_index(w, current_line, -1));
			fflush(stderr);
		}
		/*spaces[find_column(w,endPos)-find_column(w,startPos)]=0;*/
		if (find_index(w, current_line, -1)  < endPos) {
			endPos = find_index(w, current_line, -1);
		}
		if (debug) {
			fprintf(stderr,"EndPos = %d\n",endPos);
			fflush(stderr);
		}
		spaces[endPos-startPos]=0;
		/*spaces[0] = lastchar;*/
		mvc_return=1;
		XmTextReplace(w,startPos,endPos,spaces);
		if (debug) {
			fprintf(stderr,"REplace %d to %d with \"%s\"\n",
				startPos,endPos,spaces);
			fflush(stderr);
		}
		if(find_column(w,endPos) > fld[current_field].col_end) {
			XmTextSetInsertionPosition(w,
				find_index(w, current_line,
				fld[current_field].col_end)+1);
		}
		mvc_return=0;
		vcs->doit = False;
		no_white(w, current_line, current_field);
		return;
	
	 /*Set current insertion position to end of current field */
	if (find_column(w,endPos) > fld[current_field].col_end) {
		XmTextSetInsertionPosition(w,
			find_index(w, current_line,
			fld[current_field].col_end)+1);
	}
	else
		XmTextSetInsertionPosition(w,endPos);

	/*XmTextSetInsertionPosition(w,startPos);*/
	/*XmTextClearSelection (w, XtLastTimestampProcessed(display) );*/
	mvc_return=0;
	vcs->doit = False;
	extract_field(w,field_str,current_line,current_field);
	if (!iswhite(field_str))
		no_white(w, current_line, current_field);
	return;

#endif /* NOT_USED */

	tstr = (char *)XmTextGetString(w);
	strlength = strlen(tstr);
	if (debug) {
		fprintf(stderr,"STRLEN=%d\n",strlength);
		fflush(stderr);
	}
	XtFree(tstr);

	if (((lastchar == ' ') && ((beamline_mode==False)||(current_field<(n_fields-1)))) ||
		(lastchar == '\t')) {

		if ((current_column) > fld[n_fields-1].col_end) {
			if (debug) {
				fprintf(stderr,"END OF COL9...\n");
				fflush(stderr);
			}
			vcs->doit = False;
			clean_up(w, current_line, current_field);
			return;
		}

		if ((next_field = current_field + 1) >= n_fields)
			next_field = n_fields-1;

		mvc_return=1;
		vcs->doit = False;
		next_column = find_index(w, current_line,
			fld[next_field].col_end);

		if (strlength >= next_column) { /* Just move to next column */
			XmTextSetInsertionPosition(w, next_column+1);
		}
		else {
			/* Move to end of string */
			spaces[next_column-strlength+1] = 0;
			XmTextInsert(w,strlength,spaces);
			XmTextSetInsertionPosition(w,next_column+1);
		}
		mvc_return=0;
		clean_up(w, current_line, current_field);
		return;	
	}
	if ((lastchar == '\n')) { /* NEWLINE */
		int outlen;

		outlen = find_index(w,current_line,0) + MAX_CHAR + 3;

		mvc_return=1;
		vcs->doit = False;
		if (strlength > outlen) { 
			int filler;
			/* Just move to next line */
			if (debug) {
				fprintf(stderr,"Move to next line.\n");
				fflush(stderr);
			}
			XmTextSetInsertionPosition(w,
				find_index(w, current_line+1,fld[0].col_end+1));
		}
		else {
			int filler ,jindex;

			/* Move to end of string */
			if (debug) {
				fprintf(stderr,"Move to end of string. w=%d\n",w);
				fflush(stderr);
				fprintf(stderr,"current_column=%d\n",current_column);
				fprintf(stderr,"startPos=%d strlength=%d\n",startPos,strlength);
				fflush(stderr);
			}
			
			filler = outlen - strlength;

			jindex = MAX_CHAR - (strlength - find_index(w,current_line,0)) - 1;
			spaces[jindex] = '\n';
			spaces[jindex+1] = ' ';
			spaces[jindex+2] = ' ';
			spaces[jindex+3] = ' ';
			spaces[jindex+4] = 0;
			if (debug) {
				fprintf(stderr,"insert %d char at %d. w=%d\n",
					strlen(spaces),strlength,w);
				fflush(stderr);
			}
			/*XmTextInsert(w,startPos,spaces);*/ /* OK */
			XmTextInsert(w,strlength,spaces);
			/*XmTextSetInsertionPosition(w,(current_line+1)*MAX_CHAR+2);*/
			XmTextSetInsertionPosition(w,
				find_index(w,current_line+1,fld[0].col_end+1));
			if (debug) {
				fprintf(stderr,"find_index(%d,0) = %d w=%d\n",
					current_line+1,find_index(w,current_line+1,0),w);
				fflush(stderr);
			}
/*
			XmTextInsert(w, XmTextGetInsertionPosition (w), "   ");
			XmTextSetInsertionPosition(w,find_index(w,current_line+1,-1));
*/
		}
		mvc_return=0;
		
		for(i=0;i<n_fields;i++)
			clean_up(w, current_line, i);
			
		return;
	}

	if (isascii(lastchar)) {

		/* We are at end of text field. Shift left and insert text */
		if (current_column > fld[current_field].col_end) {
			mvc_return=1;
			
			extract_field(w, field_str,current_line, current_field);

			field_str[FIELD_LENGTH(current_field)] = lastchar;
			field_str[FIELD_LENGTH(current_field)+1] = 0;
			 
			XmTextReplace(w,find_index(w,current_line,fld[current_field].col_start),
				find_index(w,current_line,fld[current_field].col_end+1),&field_str[1]);
			vcs->doit = False;
			 
			mvc_return=0;
			return;
		}
		/* At start of text field - Shift Right and insert */
		if (current_column == fld[current_field].col_start) {
			mvc_return=1;

			extract_field(w, &field_str[1],
				current_line, current_field);
			
			field_str[0] = lastchar;
			field_str[FIELD_LENGTH(current_field)] = 0;
			 
			XmTextReplace(w,
				find_index(w,current_line,
					fld[current_field].col_start),
				find_index(w,current_line,
					fld[current_field].col_end+1),field_str);
			vcs->doit = False;
			 
			mvc_return=0;
			return;
		}
		/* Here we are inserting text somewhere in the text field.
		 * If there is white space to the right, then shift right
		 * and insert text. If there is white space to the left
		 * then shift left and insert. If there is no space left or
		 * right then ???
		 */
		mvc_return=1;

		extract_field(w, field_str,current_line, current_field);

		if (field_str[strlen(field_str)-1] == ' ') {
			/* White space at end of string.
			 * Delete white space char and continue.
			 */
			XmTextReplace(w,
				find_index(w,current_line,
					fld[current_field].col_end),
				find_index(w,current_line,
					fld[current_field].col_end+1),"");
			vcs->doit = True;
			mvc_return=0;
			return;
		}
		else
		if (field_str[0] == ' ') {
			/* White space at beginning of string.
			 * Delete white space char and continue.
			 */
			XmTextReplace(w,
				find_index(w,current_line,
					fld[current_field].col_start),
				find_index(w,current_line,
					fld[current_field].col_start+1),"");
			vcs->doit = True;
			vcs->currInsert -= 1;
			vcs->newInsert -= 1;
			vcs->startPos -= 1;
			vcs->endPos -= 1;
			/*XmTextSetInsertionPosition(w,XmTextGetInsertionPosition (w)-1);*/
			 
			mvc_return=0;
			return;
		}
		else {
			/* Field is full...
			 * Delete last char and continue.
			 */
			XmTextReplace(w,find_index(w,current_line,
				fld[current_field].col_end),
			find_index(w,current_line,
				fld[current_field].col_end+1),"");
			vcs->doit = True;
			mvc_return=0;
			return;
		}
	}
}

/* ARGSUSED */
void
abort_activateCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	int user_data;
	char	buf[256], *cp;

	XtVaGetValues(w, XmNuserData, &user_data, NULL);

	switch(user_data)
	  {
	    case STOP_YES:
		if(NULL != (cp = (char *)getenv("CCD_BLSERVER")))
		{
			sprintf(buf, "kill -s SIGUSR1 %s", cp);
			system(buf);
		}
	    	XtUnmanageChild(abortDialog);
		break;
	    case STOP_NO:
	    	XtUnmanageChild(abortDialog);
		break;
	    default:
		break;
	  }
}

/* ARGSUSED */
void
error_Dialog_activateCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	XtUnmanageChild(error_Dialog);
}

/* ARGSUSED */
void
strategy_time_armCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
   	XmString xmstr;
	Arg args[1];

	if (debug) {
		fprintf(stderr,"Called strategy_time_armCallback...\n");
		fflush(stderr);
	}
	xmstr = XmStringCreateSimple("Time");
	XtSetArg(args[0], XmNlabelString, xmstr);
	XtSetValues(strategy_time_dose_label,args,1);
	XmStringFree(xmstr);
}

/* ARGSUSED */
#ifdef NOT_USED
void
strategy_time_valueChangedCb(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
}
#endif /* NOT_USED */

/* ARGSUSED */
void
strategy_dose_armCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
   	XmString xmstr;
	Arg args[1];

	if (debug) {
		fprintf(stderr,"Called strategy_dose_armCallback...\n");
		fflush(stderr);
	}
	xmstr = XmStringCreateSimple("Dose");
	XtSetArg(args[0], XmNlabelString, xmstr);
	XtSetValues(strategy_time_dose_label,args,1);
	XmStringFree(xmstr);
}

/* ARGSUSED */
void
snapshot_openhelpCB(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	Unmanage_helpWindow();
	XtManageChild(snapshot_helpWindow);

	raise_window(adx_helpDialog);
}

void
df_OK_activateCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{

	XtUnmanageChild(diskfullDialog);
}

update_disk_space (count, directory)
int count;
char *directory;
{
	int i;
	int n_mb; /* Number of megabytes free */
	int n_im; /* Number of images free */
	double compression_ratio=1;
	int N; /* Number of files per each image */
	int current_run;

	if (!isdir(directory)) {
		XmTextFieldSetString(disk_space_mb_textField," -");
		XmTextFieldSetString(disk_space_images_textField," -");
		return;
	}

	n_mb = disk_free(directory);

	if ( n_mb < 999999)
		sprintf(tmpstr,"%6d",n_mb);
	else
		sprintf(tmpstr,"%d",999999);
	XmTextFieldSetString(disk_space_mb_textField,tmpstr);

	/* Calculate # of images which can fit */
	switch  (image_compression) 
	{
		case COMP_NONE:
			compression_ratio = 1.0;
			break;
		case COMP_Z:
			compression_ratio = 2.0;
			break;
		case COMP_PCK:
			compression_ratio = 2.0;
			break;
		default:
			break;
	}


	current_run = get_run_number(image_filename);

	if (current_run < 0) {
		N = 1;
	}
	else {

		for(i=0; i <= MAX_RUNS; i++) {
			if (Run[i].number == current_run) {
			    current_run = i;
			    break;
			}
		}
		if ( i > MAX_RUNS) {
			current_run = 0;
		}


		if((!strncmp(Run[current_run].dzngr,"n",1))||
		   (!strncmp(Run[current_run].dzngr,"N",1))||
		   (!strncmp(Run[current_run].dzngr,"0",1))) {
			/* No De-Zingering */

			if (Collect.output_raw == 1) 
				N = 2;
			else
				N = 1;
		}
		else {
			/* De-Zingering */

			if (Collect.output_raw == 1) 
				N = 3;
			else
				N = 1;
		}

		if (Collect.no_transform == 1)
			N -= 1;
	}


	if (N <= 1)
		N = 1;

	if (image_bin_mode == 2) { /* 2x2 binning */
		compression_ratio *= 2.0;
	}
	if (outfile_type == 1) { /* 32 bit output */
		compression_ratio /= 2.0;
	}

	/* Scale by 0.9 to account for dark currents */

	if (configuration == CONFIG_1x1)
		n_im = (int)((double)0.9 * n_mb * 1024.0*1024 * compression_ratio / (2*1152.0*1152.0 * N));
	else
		n_im = (int)((double)0.9 * n_mb * 1024.0*1024 * compression_ratio / (2*2304.0*2304.0 * N));


	if (n_im > 999999)
		sprintf(tmpstr,"%d",999999);
	else
		sprintf(tmpstr,"%6d",n_im);
	XmTextFieldSetString(disk_space_images_textField,tmpstr);

	if (debug) {
		fprintf(stderr,"n_mb=%d compression_ratio=%f\n",n_mb,compression_ratio);
		fprintf(stderr,"Space for %d images...\n",n_im);
		fflush(stderr);
	}

	if ((n_im <= 10) && (collecting == 1)) {
		int argok;
		static int prev_post_time= -10000;
		static int init=0;
		Arg args[2];
   		XmString xmstr;

		/* Display the disk space warning once every 60
		 * minutes (at the most).
		 */

		if ((abs(prev_post_time - (count*TIMER_MSEC)/1000) > 60*60)) {

		prev_post_time = (count*TIMER_MSEC)/1000;

		sprintf(error_msg,"%s",directory); 
		xmstr = XmStringCreateSimple(error_msg);
		XtSetArg(args[0], XmNlabelString, xmstr);
		XtSetValues(disk_full_label1,args,1);
    		XmStringFree(xmstr);

		sprintf(error_msg,"Free Space: %d Mb (%d Image%c)",n_mb,n_im,n_im==1?' ':'s'); 
		xmstr = XmStringCreateSimple(error_msg);
		XtSetArg(args[0], XmNlabelString, xmstr);
		XtSetValues(disk_full_label2,args,1);
    		XmStringFree(xmstr);

		if (!init) {
			init=1;
			XtSetArg(args[0], XmNx, scr_width + DISKFULL_DIALOG_X);
			XtSetArg(args[1], XmNy, DISKFULL_DIALOG_Y);
			XtSetValues(diskfullDialog,args,2);
		}
		raise_window(diskfullDialog);
		}
	}
}

/* ARGSUSED */
void
mcinfo_OK_activateCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{

	XtUnmanageChild(mcinfoDialog);
}

/* ARGSUSED */
void
dist_drive_armCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{

	/*
	if (XmToggleButtonGetState(drive_distance_pushButton) == True) {
		raise_window(mcinfoDialog);
	}
	 */
}

/* ARGSUSED */
void
dist_define_armCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{

	/*
	if (XmToggleButtonGetState(define_distance_pushButton) == True) {
		raise_window(mcinfoDialog);
	}
	 */
}

/* ARGSUSED */
void
phi_define_armCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{

	/*
	if (XmToggleButtonGetState(define_phi_pushButton) == True) {
		raise_window(mcinfoDialog);
	}
	 */
}

/* ARGSUSED */
void
phi_drive_armCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{

	/*
	if (XmToggleButtonGetState(drive_phi_pushButton) == True) {
		raise_window(mcinfoDialog);
	}
	 */
}

/* ARGSUSED */
void
offset_drive_armCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{

	/*
	if (XmToggleButtonGetState(drive_twotheta_pushButton) == True) {
		raise_window(mcinfoDialog);
	}
	 */
}

/* ARGSUSED */
void
offset_define_armCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{

	/*
	if (XmToggleButtonGetState(define_twotheta_pushButton) == True) {
		raise_window(mcinfoDialog);
	}
	 */
}

/* ARGSUSED */
void
text_deleteAll(wid, client, call)
Widget wid;
XtPointer client;
XtPointer call;
{
	Widget w = runtext;
	static int prev_mvc_return;

	if (debug) {
		fprintf(stderr,"Called text_deleteAll()...\n");
		fflush(stderr);
	}

	prev_mvc_return = mvc_return;
	mvc_return=1;

	if (debug) {
		fprintf(stderr,"CAlled text_deleteAll\n");
		fflush(stderr);
	}

	XmTextReplace(w, 0, XmTextGetLastPosition(w), "   ");
	/*XmTextReplace(w, 0, 0, "   ");*/

	mvc_return=prev_mvc_return;
}

/* ARGSUSED */
void
text_deleteLine(wid, client, call)
Widget wid;
XtPointer client;
XtPointer call;
{
	int i, findex, fcol, strlength;
	Widget w = runtext;
        char spaces[2*M_MAX_CHAR+1];
	XmTextPosition currInsert, newInsert, startPos, endPos;
	int current_line;
	static int prev_mvc_return;
	char *tstr;

	if (debug) {
		fprintf(stderr,"CAlled text_deleteLine\n");
		fflush(stderr);
	}
	for(i=0;i<(2*MAX_CHAR);i++)
		spaces[i] = SPACE_CHAR;

	prev_mvc_return = mvc_return;
	mvc_return=1;

	startPos = XmTextGetInsertionPosition(w);
	current_line = find_row(w, startPos);

	if (debug) {
		fprintf(stderr,"Replace: %d to %d\n",
			find_index(w, current_line, 0),
			find_index(w, current_line, -1)+1);
		fflush(stderr);
	}
	tstr = (char *)XmTextGetString(w);
	strlength = strlen(tstr);
	XtFree(tstr);

	if (strlength <= find_index(w, current_line, -1)) {
		XmTextReplace(w,find_index(w, current_line, 0),
			strlength-1,"");
	}
	else {
		XmTextReplace(w,find_index(w, current_line, 0),
			find_index(w, current_line, -1)+1,"");
	}
	if ((find_index(w, current_line, -1) <= find_index(w, current_line, 3)) &&
	    (current_line > 0))
		XmTextSetInsertionPosition(w, find_index(w, current_line-1, 3));
	else
		XmTextSetInsertionPosition(w, find_index(w, current_line, 3));
	tstr = (char *)XmTextGetString(w);
	strlength = strlen(tstr);

	if (debug) {
		fprintf(stderr,"strlen=%d\n",strlength);
		fflush(stderr);
	}
	if (strlength < 3) {
		XmTextReplace(w, 0, 0, "   ");
		XmTextSetInsertionPosition(w, 3);
	}
	XtFree(tstr);

	mvc_return = prev_mvc_return;
	return;
}

/* ARGSUSED */
void
text_insertAfter(wid, client, call)
Widget wid;
XtPointer client;
XtPointer call;
{
	int i, findex, fcol;
	Widget w = runtext;
        char spaces[2*M_MAX_CHAR+1];
	XmTextPosition currInsert, newInsert, startPos, endPos;
	int current_line;
	static int prev_mvc_return;

	if (debug) {
		fprintf(stderr,"Called text_insertAfter\n");
		fflush(stderr);
	}

	for(i=0;i<(2*MAX_CHAR);i++)
		spaces[i] = SPACE_CHAR;

	prev_mvc_return = mvc_return;
	mvc_return=1;

	startPos = XmTextGetInsertionPosition(w);
	current_line = find_row(w, startPos);
	fcol=find_column(w,(findex=find_index(w, current_line, -1)))+1;

	if (debug) {
		fprintf(stderr,"fcol = %d MAX_CHAR=%d\n",fcol,MAX_CHAR);
		fflush(stderr);
	}

	if (fcol < MAX_CHAR)
		spaces[MAX_CHAR-fcol-1] = '\n';
	else
		spaces[0] = '\n';
	spaces[MAX_CHAR+MAX_CHAR-fcol] = 0;
	if (debug) {
		fprintf(stderr,"Replace with \"%s\" (%d)\n",
			spaces,strlen(spaces));
		fflush(stderr);
	}
	XmTextReplace(w,findex, findex,spaces);
	for(i=0;i<n_fields;i++)
		clean_up(w, current_line, i);
	XmTextSetInsertionPosition(w, find_index(w, current_line+1, 3));
	mvc_return=prev_mvc_return;
	return;
}

/* ARGSUSED */
void
text_insertBefore(wid, client, call)
Widget wid;
XtPointer client;
XtPointer call;
{
	static int prev_mvc_return;
	int i;
        char spaces[2*M_MAX_CHAR+1];
	int current_line;
	Widget w = runtext;
	XmTextPosition startPos;

	if (debug) {
		fprintf(stderr,"CAlled text_insertBefore\n");
		fflush(stderr);
	}
	prev_mvc_return = mvc_return;
	mvc_return=1;

	for(i=0;i<(2*MAX_CHAR);i++)
		spaces[i] = SPACE_CHAR;

	spaces[MAX_CHAR-1] = '\n';
	spaces[MAX_CHAR] = 0;

	startPos = XmTextGetInsertionPosition(w);
	current_line = find_row(w, startPos);

	XmTextReplace(w,find_index(w, current_line, 0),
		find_index(w, current_line, 0),spaces);
	XmTextSetInsertionPosition(w, find_index(w, current_line, 3));
	for(i=0;i<n_fields;i++)
		clean_up(w, current_line+1, i);
	mvc_return=0;

	mvc_return=prev_mvc_return;
	return;
}

/* ARGSUSED */
void
strat_run_Callback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	static int prev_mvc_return;
	int user_data;
	XmTextPosition startPos;
	int current_line;

	XtVaGetValues(w, XmNuserData, &user_data, NULL);

	prev_mvc_return = mvc_return;
	mvc_return=1;

	startPos = XmTextGetInsertionPosition(runtext);
	current_line = find_row(runtext, startPos);

	switch(user_data)
	  {
	    case 1:
		insert_field(runtext,"1",current_line,0);
		break;
	    case 2:
		insert_field(runtext,"2",current_line,0);
		break;
	    case 3:
		insert_field(runtext,"3",current_line,0);
		break;
	    case 4:
		insert_field(runtext,"4",current_line,0);
		break;
	    case 5:
		insert_field(runtext,"5",current_line,0);
		break;
	    case 6:
		insert_field(runtext,"6",current_line,0);
		break;
	    case 7:
		insert_field(runtext,"7",current_line,0);
		break;
	    default:
		break;
	  }
	mvc_return=prev_mvc_return;
}

/* ARGSUSED */
void
strat_start_Callback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	int user_data;
	static int prev_mvc_return;
	XmTextPosition startPos;
	int current_line;

	prev_mvc_return = mvc_return;
	mvc_return=1;

	startPos = XmTextGetInsertionPosition(runtext);
	current_line = find_row(runtext, startPos);

	XtVaGetValues(w, XmNuserData, &user_data, NULL);


	switch(user_data)
	  {
	    case 1:
		insert_field(runtext,"001",current_line,1);
		break;
	    case 30:
		insert_field(runtext,"030",current_line,1);
		break;
	    case 45:
		insert_field(runtext,"045",current_line,1);
		break;
	    case 60:
		insert_field(runtext,"060",current_line,1);
		break;
	    case 90:
		insert_field(runtext,"090",current_line,1);
		break;
	    case 180:
		insert_field(runtext,"180",current_line,1);
		break;
	    default:
		break;
	  }
	mvc_return=prev_mvc_return;
}

/* ARGSUSED */
void
strat_total_Callback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	int user_data;
	static int prev_mvc_return;
	XmTextPosition startPos;
	int current_line;

	prev_mvc_return = mvc_return;
	mvc_return=1;

	startPos = XmTextGetInsertionPosition(runtext);
	current_line = find_row(runtext, startPos);

	XtVaGetValues(w, XmNuserData, &user_data, NULL);

	switch(user_data)
	  {
	    case 1:
		insert_field(runtext,"1",current_line,2);
		break;
	    case 30:
		insert_field(runtext,"30",current_line,2);
		break;
	    case 45:
		insert_field(runtext,"45",current_line,2);
		break;
	    case 60:
		insert_field(runtext,"60",current_line,2);
		break;
	    case 90:
		insert_field(runtext,"90",current_line,2);
		break;
	    case 180:
		insert_field(runtext,"180",current_line,2);
		break;
	    default:
		break;
	  }
	mvc_return=prev_mvc_return;
}

/* ARGSUSED */
void
strat_distance_Callback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	int user_data;
	static int prev_mvc_return;
	XmTextPosition startPos;
	int current_line;

	prev_mvc_return = mvc_return;
	mvc_return=1;

	startPos = XmTextGetInsertionPosition(runtext);
	current_line = find_row(runtext, startPos);

	XtVaGetValues(w, XmNuserData, &user_data, NULL);

	switch(user_data)
	  {
	    case 30:
		insert_field(runtext,"30.00",current_line,3);
		break;
	    case 40:
		insert_field(runtext,"40.00",current_line,3);
		break;
	    case 50:
		insert_field(runtext,"50.00",current_line,3);
		break;
	    case 60:
		insert_field(runtext,"60.00",current_line,3);
		break;
	    case 70:
		insert_field(runtext,"70.00",current_line,3);
		break;
	    case 80:
		insert_field(runtext,"80.00",current_line,3);
		break;
	    case 100:
		insert_field(runtext,"100.00",current_line,3);
		break;
	    case 120:
		insert_field(runtext,"120.00",current_line,3);
		break;
	    case 150:
		insert_field(runtext,"150.00",current_line,3);
		break;
	    case 200:
		insert_field(runtext,"200.00",current_line,3);
		break;
	    default:
		break;
	  }
	mvc_return=prev_mvc_return;
}

/* ARGSUSED */
void
strat_offset_Callback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	int user_data;
	static int prev_mvc_return;
	XmTextPosition startPos;
	int current_line;

	prev_mvc_return = mvc_return;
	mvc_return=1;

	startPos = XmTextGetInsertionPosition(runtext);
	current_line = find_row(runtext, startPos);

	XtVaGetValues(w, XmNuserData, &user_data, NULL);

	switch(user_data)
	  {
	    case 0:
		insert_field(runtext,"0.00",current_line,4);
		break;
	    case 50:
		insert_field(runtext,"50.00",current_line,4);
		break;
	    case 100:
		insert_field(runtext,"100.00",current_line,4);
		break;
	    case 150:
		insert_field(runtext,"150.00",current_line,4);
		break;
	    default:
		break;
	  }
	mvc_return=prev_mvc_return;
}

/* ARGSUSED */
void
strat_phi_Callback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	int user_data;
	static int prev_mvc_return;
	XmTextPosition startPos;
	int current_line;

	prev_mvc_return = mvc_return;
	mvc_return=1;

	startPos = XmTextGetInsertionPosition(runtext);
	current_line = find_row(runtext, startPos);

	XtVaGetValues(w, XmNuserData, &user_data, NULL);

	switch(user_data)
	  {
	    case 0:
		insert_field(runtext,"0.00",current_line,5);
		break;
	    case 45:
		insert_field(runtext,"45.00",current_line,5);
		break;
	    case 90:
		insert_field(runtext,"90.00",current_line,5);
		break;
	    case 135:
		insert_field(runtext,"135.00",current_line,5);
		break;
	    case 180:
		insert_field(runtext,"180.00",current_line,5);
		break;
	    case 225:
		insert_field(runtext,"225.00",current_line,5);
		break;
	    case 270:
		insert_field(runtext,"270.00",current_line,5);
		break;
	    case 315:
		insert_field(runtext,"315.00",current_line,5);
		break;
	    case -135:
		insert_field(runtext,"-135.00",current_line,5);
		break;
	    case -90:
		insert_field(runtext,"-90.00",current_line,5);
		break;
	    case -45:
		insert_field(runtext,"-45.00",current_line,5);
		break;
	    default:
		break;
	  }
	mvc_return=prev_mvc_return;
}

/* ARGSUSED */
void
strat_deltaphi_Callback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	int user_data;
	float f_user_data;
	static int prev_mvc_return;
	XmTextPosition startPos;
	int current_line;

	prev_mvc_return = mvc_return;
	mvc_return=1;

	startPos = XmTextGetInsertionPosition(runtext);
	current_line = find_row(runtext, startPos);

	XtVaGetValues(w, XmNuserData, &user_data, NULL);

	f_user_data = user_data / 100.0;

	switch(user_data)
	  {
	    case 0:
		insert_field(runtext,"0.00",current_line,9);
		break;
	    case 10:
		insert_field(runtext,"0.10",current_line,9);
		break;
	    case 20:
		insert_field(runtext,"0.20",current_line,9);
		break;
	    case 50:
		insert_field(runtext,"0.50",current_line,9);
		break;
	    case 100:
		insert_field(runtext,"1.00",current_line,9);
		break;
	    case 200:
		insert_field(runtext,"2.00",current_line,9);
		break;
	    default:
		break;
	  }
	mvc_return=prev_mvc_return;
}

/* ARGSUSED */
void
strat_time_Callback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	int user_data;
	static int prev_mvc_return;
	XmTextPosition startPos;
	int current_line;

	prev_mvc_return = mvc_return;
	mvc_return=1;

	startPos = XmTextGetInsertionPosition(runtext);
	current_line = find_row(runtext, startPos);

	XtVaGetValues(w, XmNuserData, &user_data, NULL);

	switch(user_data)
	  {
	    case 10:
		insert_field(runtext,"10",current_line,10);
		break;
	    case 30:
		insert_field(runtext,"30",current_line,10);
		break;
	    case 60:
		insert_field(runtext,"60",current_line,10);
		break;
	    case 120:
		insert_field(runtext,"120",current_line,10);
		break;
	    case 300:
		insert_field(runtext,"300",current_line,10);
		break;
	    case 600:
		insert_field(runtext,"600",current_line,10);
		break;
	    case 1200:
		insert_field(runtext,"1200",current_line,10);
		break;
	    case 3600:
		insert_field(runtext,"3600",current_line,10);
		break;
	    default:
		break;
	  }
	mvc_return=prev_mvc_return;
}

/* ARGSUSED */
void
strat_dzngr_Callback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	int user_data;
	static int prev_mvc_return;
	XmTextPosition startPos;
	int current_line;

	prev_mvc_return = mvc_return;
	mvc_return=1;

	startPos = XmTextGetInsertionPosition(runtext);
	current_line = find_row(runtext, startPos);

	XtVaGetValues(w, XmNuserData, &user_data, NULL);

	switch(user_data)
	  {
	    case 0:
		insert_field(runtext,"N",current_line,11);
		break;
	    case 1:
		insert_field(runtext,"Y",current_line,11);
		break;
	    case 2:
		insert_field(runtext,"1/2",current_line,11);
		break;
	    case 4:
		insert_field(runtext,"1/4",current_line,11);
		break;
	    case 8:
		insert_field(runtext,"1/8",current_line,11);
		break;
	    case 16:
		insert_field(runtext,"1/16",current_line,11);
		break;
	    case 32:
		insert_field(runtext,"1/32",current_line,11);
		break;
	    case 64:
		insert_field(runtext,"1/64",current_line,11);
		break;
	    default:
		break;
	  }
	mvc_return=prev_mvc_return;
}

/* ARGSUSED */
void
mc_distance_Callback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	int user_data;
	char distance[64];

	XtVaGetValues(w, XmNuserData, &user_data, NULL);

	sprintf(distance,"%d.00",user_data);

	XmTextFieldSetString(modify_distance_textField,distance);
	XmTextSetInsertionEnd(modify_distance_textField);
}

/* ARGSUSED */
void
mc_phi_Callback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	int user_data;
	char phi[64];

	XtVaGetValues(w, XmNuserData, &user_data, NULL);

	sprintf(phi,"%d.00",user_data);

	XmTextFieldSetString(modify_phi_textField,phi);
	XmTextSetInsertionEnd(modify_phi_textField);
}

/* ARGSUSED */
void
mc_offset_Callback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	int user_data;
	char offset[64];

	XtVaGetValues(w, XmNuserData, &user_data, NULL);

	sprintf(offset,"%d.00",user_data);

	XmTextFieldSetString(modify_offset_textField,offset);
	XmTextSetInsertionEnd(modify_offset_textField);
}

/* ARGSUSED */
void
snap_distance_Callback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	int user_data;
	char distance[64];

	XtVaGetValues(w, XmNuserData, &user_data, NULL);

	sprintf(distance,"%d.00",user_data);

	XmTextFieldSetString(snap_distance_textField,distance);
	XmTextSetInsertionEnd(snap_distance_textField);
}

/* ARGSUSED */
void
snap_offset_Callback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	int user_data;
	char offset[64];

	XtVaGetValues(w, XmNuserData, &user_data, NULL);

	sprintf(offset,"%d.00",user_data);

	XmTextFieldSetString(snap_offset_textField,offset);
	XmTextSetInsertionEnd(snap_offset_textField);
}

/* ARGSUSED */
void
snap_phi_Callback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	int user_data;
	char phi[64];

	XtVaGetValues(w, XmNuserData, &user_data, NULL);

	sprintf(phi,"%d.00",user_data);

	XmTextFieldSetString(snap_phi_textField,phi);
	XmTextSetInsertionEnd(snap_phi_textField);
}

/* ARGSUSED */
void
snap_deltaphi_Callback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	int user_data;
	char step[64];

	XtVaGetValues(w, XmNuserData, &user_data, NULL);

	sprintf(step,"%1.2f",user_data/100.0);

	XmTextFieldSetString(snap_step_size_textField,step);
	XmTextSetInsertionEnd(snap_step_size_textField);
}

/* ARGSUSED */
void
snap_time_Callback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	int user_data;
	char time[64];

	XtVaGetValues(w, XmNuserData, &user_data, NULL);

	sprintf(time,"%d",user_data);

	XmTextFieldSetString(snap_exposure_time_textField,time);
	XmTextSetInsertionEnd(snap_exposure_time_textField);
}

/* ARGSUSED */
void
mc_apply_Callback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	int user_data;
	static int init_distance_dialog=0;
	static int init_phi_dialog=0;
	static int init_kappa_dialog=0;
	static int init_omega_dialog=0;
	static int init_offset_dialog=0;
	Dimension m_XmNx, m_XmNy, m_XmNwidth, m_XmNheight;
	Arg args[2];
	double distance, phi, kappa, omega, twotheta;
	char	tbuf[20];
	double	energy;

	XtVaGetValues(w, XmNuserData, &user_data, NULL);

	switch(user_data)
	  {
	    case MC_DISTANCE:

		if (!init_distance_dialog) {
			init_distance_dialog=1;
			XtSetArg(args[0], XmNx, 500);
			XtSetArg(args[1], XmNy, 500);
			XtSetValues(define_distance_Dialog,args,2);
		}

		distance = wtof(modify_distance_textField);
		if (sc_conf.usedistance == 0) { 
			marcommand(SET_DISTANCE, distance);
			return;
		}
		if ((distance < Limit.distmin) || (distance > Limit.distmax) ) {
			sprintf(error_msg,"\nAttempt to %s Distance to %1.2f. This value is out of Range.\n\nOperation has been aborted.\n\nMinimum Distance: %6.2f\nMaximum Distance: %6.2f",
			(XmToggleButtonGetState(define_distance_pushButton) == True)?"Define":"Drive",
			distance,Limit.distmin,Limit.distmax);

			post_error(error_msg);
			return;
		}
		if (XmToggleButtonGetState(define_distance_pushButton) == True) {
			Window window;
			int dest_x, dest_y;

			if (sc_conf.usedistance == 0) { 
				marcommand(SET_DISTANCE, distance);
			}
			else {
				raise_window(define_distance_Dialog);
				window  = XtWindow(define_distance_Dialog);
	
				XtVaGetValues(pushButton2,
					XmNx, &m_XmNx,
					XmNy, &m_XmNy,
					XmNwidth, &m_XmNwidth,
					XmNheight, &m_XmNheight,
					NULL);

				dest_x = m_XmNx + m_XmNwidth/2;
				dest_y = m_XmNy + m_XmNheight/2;

				XWarpPointer(display, None, window, 0, 0, 0, 0, dest_x, dest_y);
			}
		}
		else {
			marcommand(DRIVE_DISTANCE, distance);
		}
		break;
	    case MC_PHI:
	    
		if (!init_phi_dialog) {
			init_phi_dialog=1;
			XtSetArg(args[0], XmNx, 500);
			XtSetArg(args[1], XmNy, 500);
			XtSetValues(define_phi_Dialog,args,2);
		}

		phi = wtof(modify_phi_textField);
		if (XmToggleButtonGetState(define_phi_pushButton) == True) {
			int dest_x, dest_y;
			Window window;

			if (sc_conf.usephi == 0) { 
				marcommand(SET_PHI, phi);
			}
			else {
#ifdef CHESS_CCD
				marcommand(SET_PHI, phi);
#else
				raise_window(define_phi_Dialog);
				window  = XtWindow(define_phi_Dialog);
				XtVaGetValues(pushButton11,
					XmNx, &m_XmNx,
					XmNy, &m_XmNy,
					XmNwidth, &m_XmNwidth,
					XmNheight, &m_XmNheight,
					NULL);
	
				dest_x = m_XmNx + m_XmNwidth/2;
				dest_y = m_XmNy + m_XmNheight/2;
				XWarpPointer(display, None, window, 0, 0, 0, 0, dest_x, dest_y);
#endif /* CHESS_CCD */
			}
		}
		else {
			marcommand(DRIVE_PHI, phi);
		}
		break;
	    case MC_KAPPA:
	    
		if (!init_kappa_dialog) {
			init_kappa_dialog=1;
			XtSetArg(args[0], XmNx, 500);
			XtSetArg(args[1], XmNy, 500);
			XtSetValues(define_kappa_Dialog,args,2);
		}

		kappa = wtof(modify_kappa_textField);
		if (XmToggleButtonGetState(define_kappa_pushButton) == True) {
			int dest_x, dest_y;
			Window window;

			if (sc_conf.usekappa == 0) { 
				marcommand(SET_KAPPA, kappa);
			}
			else {
				raise_window(define_kappa_Dialog);
				window  = XtWindow(define_kappa_Dialog);
				XtVaGetValues(pushButton11,
					XmNx, &m_XmNx,
					XmNy, &m_XmNy,
					XmNwidth, &m_XmNwidth,
					XmNheight, &m_XmNheight,
					NULL);
	
				dest_x = m_XmNx + m_XmNwidth/2;
				dest_y = m_XmNy + m_XmNheight/2;
				XWarpPointer(display, None, window, 0, 0, 0, 0, dest_x, dest_y);
			}
		}
		else {
			marcommand(DRIVE_KAPPA, kappa);
		}
		break;
	    case MC_OMEGA:
	    
		if (!init_omega_dialog) {
			init_omega_dialog=1;
			XtSetArg(args[0], XmNx, 500);
			XtSetArg(args[1], XmNy, 500);
			XtSetValues(define_omega_Dialog,args,2);
		}

		omega = wtof(modify_omega_textField);
		if (XmToggleButtonGetState(define_omega_pushButton) == True) {
			int dest_x, dest_y;
			Window window;

			if (sc_conf.useomega == 0) { 
				marcommand(SET_OMEGA, omega);
			}
			else {
				raise_window(define_omega_Dialog);
				window  = XtWindow(define_omega_Dialog);
				XtVaGetValues(pushButton11,
					XmNx, &m_XmNx,
					XmNy, &m_XmNy,
					XmNwidth, &m_XmNwidth,
					XmNheight, &m_XmNheight,
					NULL);
	
				dest_x = m_XmNx + m_XmNwidth/2;
				dest_y = m_XmNy + m_XmNheight/2;
				XWarpPointer(display, None, window, 0, 0, 0, 0, dest_x, dest_y);
			}
		}
		else {
			marcommand(DRIVE_OMEGA, omega);
		}
		break;
	    case MC_WAVELENGTH:
	    
		wavelength = wtof(modify_wavelength_textField);
		energy = EV_ANGSTROM / wavelength;
		sprintf(tbuf,"%.1f", energy);
		XmTextFieldSetString( mc_modify_energy_textField, tbuf);
		if (XmToggleButtonGetState(define_wavelength_pushButton) == True) {
			marcommand(SET_WAVELENGTH, wavelength);
		}
		else {
			marcommand(DRIVE_WAVELENGTH, wavelength);
		}
		break;
	    case MC_ENERGY:
	    
		wavelength = EV_ANGSTROM / wtof(mc_modify_energy_textField);
		sprintf(tbuf,"%.5f", wavelength);
		XmTextFieldSetString( modify_wavelength_textField, tbuf);
		if (XmToggleButtonGetState(define_wavelength_pushButton) == True) {
			marcommand(SET_WAVELENGTH, wavelength);
		}
		else {
			marcommand(DRIVE_WAVELENGTH, wavelength);
		}
		break;
	    case MC_OFFSET:

		if (!init_offset_dialog) {
			init_offset_dialog=1;
			XtSetArg(args[0], XmNx, 500);
			XtSetArg(args[1], XmNy, 500);
			XtSetValues(define_offset_Dialog,args,2);
		}

		if (debug) {
			fprintf(stderr,"Called modify_twotheta_activateCallback...\n");
			fflush(stderr);
		}
		twotheta = wtof(modify_offset_textField);

		if (sc_conf.uselift == 0) { 
			marcommand(SET_OFFSET, twotheta);
			return;
		}

		if ((twotheta < Limit.liftmin) || (twotheta > Limit.liftmax) ) {
			if ((Limit.liftmin == 0.0) && (Limit.liftmax == 0.0)) 
			sprintf(error_msg,"\nThis CCD does not support this operation.");
			else
			sprintf(error_msg,"\nAttempt to %s Offset to %1.2f. This value is out of Range.\n\nOperation has been aborted.\n\nMinimum Offset: %6.2f\nMaximum Offset: %6.2f",
			(XmToggleButtonGetState(define_twotheta_pushButton) == True)?"Define":"Drive",
			twotheta,Limit.liftmin,Limit.liftmax);

			post_error(error_msg);
			return;
		}

		if (XmToggleButtonGetState(define_twotheta_pushButton) == True) {
			Window window;
			int dest_x, dest_y;

			if (sc_conf.uselift == 0) { 
				marcommand(SET_OFFSET, twotheta);
			}
			else {
				raise_window(define_offset_Dialog);
				window  = XtWindow(define_offset_Dialog);
				XtVaGetValues(pushButton12,
					XmNx, &m_XmNx,
					XmNy, &m_XmNy,
					XmNwidth, &m_XmNwidth,
					XmNheight, &m_XmNheight,
					NULL);
	
				dest_x = m_XmNx + m_XmNwidth/2;
				dest_y = m_XmNy + m_XmNheight/2;
				XWarpPointer(display, None, window, 0, 0, 0, 0, dest_x, dest_y);
			}
		}
		else {
			marcommand(DRIVE_OFFSET,twotheta);
		}
		break;
	  }
}

/* ARGSUSED */
void
nobeam_OK_activateCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{

	XtUnmanageChild(nobeamDialog);
}

/* ARGSUSED */
void
nobeam_Restart_activateCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	int current_run, current_frame;

	XtUnmanageChild(nobeamDialog);

	current_run = get_run_number(image_filename);
	current_frame = get_frame_number(image_filename);

	TextFieldSetInt(restart_run_textfield,current_run);
	TextFieldSetInt(restart_frame_textfield,current_frame);
	restart_activateCallback(w, NULL, NULL);
}

/* ARGSUSED */
#ifdef NOT_USED
void
weakbeam_Abort_activateCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
}
#endif /* NOT_USED */

/* ARGSUSED */
void
weakbeam_Abort_activateCb(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{

	XtUnmanageChild(weakbeamDialog);
}

/* ARGSUSED */
void
weakbeam_Collect_activateCb(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
	char *runstr = (char *)XmTextGetString(runtext);

	collect_runs(runstr);

	XtUnmanageChild(weakbeamDialog);
	XtFree(runstr);
}

/* ARGSUSED */
#ifdef NOT_USED
void
weakbeam_Collect_activCb(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
}
#endif /* NOT_USED */

char ls_command[80];

void
localsite_activateCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
	FILE *fp;
	char local_config_file[256];
	char str[256], label_label[80], button_label[80];
   	XmString xmstr;
	Arg args[2];
	/*char *getenv();*/
	static int init=0;

	if (!init) {
		init=1;
		XtSetArg(args[0], XmNx, scr_width + LOCALDIALOG_X);
		XtSetArg(args[1], XmNy, LOCALDIALOG_Y);
		XtSetValues(localSiteDialog,args,2);
	}

	strcpy(label_label,"");
	strcpy(button_label,"");
	if (getenv("MARHOME") != NULL) {
		strcpy(local_config_file,getenv("MARHOME"));
		strcat(local_config_file,"/tables/localsite.config");
		fp = fopen(local_config_file,"r");
		if (fp == NULL) {
			/*
			sprintf(str,"Can not open local site config file: %s\n", local_config_file);
			emess(str);
			 */
			return;
		}
		fgets(label_label,80,fp);
		fgets(button_label,80,fp);
		fgets(ls_command,80,fp);
		fclose(fp);

		raise_window(localSiteDialog);

		if (!strcmp(label_label,"")) {
			XtUnmanageChild(localSite_label1);
		}
		else {
			raise_window(localSite_label1);
			xmstr = XmStringCreateSimple(label_label);
			XtSetArg(args[0], XmNlabelString, xmstr);
			XtSetValues(localSite_label1,args,1);
    			XmStringFree(xmstr);
		}

		if (!strcmp(button_label,"")) {
			XtUnmanageChild(localSite_button1);
		}
		else {
			raise_window(localSite_button1);
			xmstr = XmStringCreateSimple(button_label);
			XtSetArg(args[0], XmNlabelString, xmstr);
			XtSetValues(localSite_button1,args,1);
    			XmStringFree(xmstr);
		}
	}
}

#ifdef NOT_USED
void
localsize_OK_activateCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{

	XtUnmanageChild(localSiteDialog);
}
#endif /* NOT_USED */

void
localsite_command(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{

	system(ls_command);
}

void
localsite_OK_activateCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{

	XtUnmanageChild(localSiteDialog);
}

void
project_spgrp_cb(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
project_i_prefix_cb(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
	char *str;

	str = XmTextFieldGetString(w);
	XmTextFieldSetString(strategy_image_prefix_textField,str);
	XtFree(str);
}

void
project_help_activateCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
	Unmanage_helpWindow();
	XtManageChild(project_helpWindow);

	raise_window(adx_helpDialog);
}

void
project_activateCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
	static int init=0;
	Arg args[2];

	if (!init) {
		init=1;
		XtSetArg(args[0], XmNx, scr_width + PROJECTDIALOG_X);
		XtSetArg(args[1], XmNy, PROJECTDIALOG_Y);
		XtSetValues(project_dialog,args,2);
	}
	raise_window(project_dialog);
}

void
project_param_file_cb(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
	char *str;

	str = XmTextFieldGetString(w);
	XmTextFieldSetString(optimize_param_file_textField,str);
	XtFree(str);
}

void
project_data_dir_cb(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
	char *str;

	str = XmTextFieldGetString(w);
	XmTextFieldSetString(strategy_directory_textField,str);
	XtFree(str);
}

void
project_proc_dir_cb(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{

}

void
project_close_callback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
	char *str;

	str = XmTextFieldGetString(project_data_dir_textField);
	XmTextFieldSetString(strategy_directory_textField,str);
	XtFree(str);

	str = XmTextFieldGetString(project_i_prefix_textField);
	XmTextFieldSetString(strategy_image_prefix_textField,str);
	XtFree(str);

	XtUnmanageChild(project_dialog);
}

void
optimize_help_Callback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
	Unmanage_helpWindow();
	XtManageChild(optimize_helpWindow);

	raise_window(adx_helpDialog);
}

void
optimize_apply_callback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
	int user_data;
	Arg Args[10];
	int i, item_count;
	XmString *items;
	char *str, *param_file, *proc_directory;
	char *res1, *res2, *resmax, *maxrun;
	char merge[64];
	int max_runs;
	/*char *getenv();*/
	char bigarg[2048];

	XtVaGetValues(w, XmNuserData, &user_data, NULL);

	proc_directory = XmTextFieldGetString(project_proc_dir_textField);
	param_file = XmTextFieldGetString(optimize_param_file_textField);

	switch(user_data)
	  {
	    case OPTIMIZE_INDEX:
		if ((char *)getenv("MARHOME") == NULL) {
			fprintf(stderr,"Environment variable MARHOME not set.\n");
			fflush(stderr);
			return;
		}
		sprintf(tmpstr,"PWD=%s ; export PWD ; cd %s ; %s/motif_gui_com/Denzo_quick_index.com %s &",
			proc_directory,proc_directory,(char *)getenv("MARHOME"),param_file);

		system(tmpstr);

		/*XtFree(str);*/
		break;
	    case OPTIMIZE_CALCULATE:

		str = XmTextFieldGetString(optimize_param_file_textField);
		XtFree(str);

		resmax = XmTextFieldGetString(optimize_resmax_textField);
		res1 = XmTextFieldGetString(optimize_res1_textField);
		res2 = XmTextFieldGetString(optimize_res2_textField);
		maxrun = XmTextFieldGetString(optimize_maxrunsize_textField);
		if (XmToggleButtonGetState(optimize_merge_yes) == True) 
			strcpy(merge,"1");
		else
			strcpy(merge,"0");
		
		strcpy(bigarg,resmax); strcat(bigarg, " ");
		strcat(bigarg,res1); strcat(bigarg, " ");
		strcat(bigarg,res2); strcat(bigarg, " ");
		strcat(bigarg,maxrun); strcat(bigarg, " ");
		strcat(bigarg,merge); strcat(bigarg, " ");

		strcat(bigarg,param_file); strcat(bigarg, " ");

		XtSetArg(Args[0], XmNitemCount, &item_count);
		XtGetValues(optimize_param_file_list, Args, 1);
		XtSetArg(Args[0], XmNitems, &items);
		XtGetValues(optimize_param_file_list, Args, 1);

		for(i=0;i<item_count;i++) {
			str =  XmCvtXmStringToCT (items[i]);
			strcat(bigarg,str); strcat(bigarg, " ");
			XtFree(str);
		}

		if ((char *)getenv("MARHOME") == NULL) {
			fprintf(stderr,"Environment variable MARHOME not set.\n");
			fflush(stderr);
			return;
		}
		sprintf(tmpstr,"PWD=%s ; export PWD ; cd %s ; %s/motif_gui_com/Denzo_optimal_run.com %s &",
			proc_directory,proc_directory,(char *)getenv("MARHOME"),bigarg);

		system(tmpstr);

		XtFree(res1);
		XtFree(res2);
		XtFree(resmax);
		XtFree(maxrun);

		XtSetSensitive(optimize_apply_Pushbutton1,False);
		calculating_strategy=1;

		break;
	    default:
		break;
	  }
	XtFree(proc_directory);
	XtFree(param_file);

}

void
optimize_close_callback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{

	XtUnmanageChild(optimize_dialog);
}

void
optimize_delete_list_cb(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
	int position_count, *position_list;

	if (XmListGetSelectedPos (optimize_param_file_list, &position_list, &position_count) == True) {
		XmListDeletePositions (optimize_param_file_list, position_list, position_count);
		XtFree((char *)position_list);
	}
}

void
optimize_list_ss_cb(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
optimize_list_bs_cb(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
optimize_list_ms_cb(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
optimize_cancel_cb(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{

	XtUnmanageChild(optimize_add_fSB);

}

void
optimize_add_load(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
	char *str;
	Widget selection_widget;
	XmString items[1];

	selection_widget = XmFileSelectionBoxGetChild (optimize_add_fSB,
		XmDIALOG_TEXT);
	str = XmTextFieldGetString(selection_widget);
	items[0] = XmStringCreateSimple(str);
	XmListAddItems (optimize_param_file_list, items, 1, 0);
    	XmStringFree(items[0]);
	XtFree(str);
}

void
optimize_add_list_cb(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
	raise_window(optimize_add_fSB);
}

void
bs_Callback(w, client_data, call_data)
Widget w;
XtPointer client_data;
XtPointer call_data;
{
	XmListCallbackStruct *lcs=(XmListCallbackStruct*)call_data;
	char selection[256];
   	char *string;
	char tag[32];
	static int prev_mvc_return;
	XmTextPosition startPos;
	int current_line;

	XmStringGetLtoR(lcs->item, XmSTRING_OS_CHARSET, &string);

	sscanf(string,"%s",tag);

	prev_mvc_return = mvc_return;
	mvc_return=1;
	startPos = XmTextGetInsertionPosition(runtext);
	current_line = find_row(runtext, startPos);
	insert_field_bl(runtext,tag,current_line,12);
	mvc_return=0;
}

#ifdef NOT_USED

void
fclist_activateCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
wavelength_activateCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
file_load_activateCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
savewindow_vCCb(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
AdxvVerifyNumericCB(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
Beam_X_Arrow_Cb(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
Beam_Y_Arrow_Cb(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
default_Callback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
show_settings_cb(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
saveWindowClose(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
exitDialogCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
image_dA_resizeCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
beam_y_activateCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
SubAutomaticCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
fcapply_activateCalback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
ShowBackgroundCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
pixelsize_activateCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
settingWindowClose(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
LineSampleCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
ms_Callback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
lineWindow_exposeCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
image_dA_inputCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
edit_background_cb(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
savefile_Callback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
image_dA_exposeCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
mag_histo_Callback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
beam_x_activateCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
contrast_vcCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
nl_activateCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
file_save_activateCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
fclist_activateCalback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
PlotmodeCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
mag_sigma_Callback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
image_dA_createCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
ScaleCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
magnifyWindow_exposeCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
savewindow_armCb(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
backgroundWindowClose(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
contrast_dragCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
saveformat_armCb(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
MagnificationCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
cmin_activateCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
ss_Callback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
BeamCenterUnitsCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
propertyWindowClose(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
fc_sortCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
NcolorsCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
nl(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
show_histogram_cb(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
lw_activateCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
distance_activateCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
ovf_activateCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
LineInterpCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
ShowOvfCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
show_properties_cb(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
show_mhistogram_cb(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
image_dA_destroyCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
MagnifyCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
es_Callback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
show_ihistogram_cb(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
ShowSpotsCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
ColorCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
SubFileCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
InvertCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
cmax_activateCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
color_exposeCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
bgsub_Callback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
fcclose_activateCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
lw_arrow_cb(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
lw_Arrow_Cb(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
cr_activateCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
RingsCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

#endif /* NOT_USED */

/* PF Start */

void
strat_energy_Callback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
	int user_data;
	static int prev_mvc_return;
	XmTextPosition startPos;
	int current_line;
	char	tbuf[30];

	prev_mvc_return = mvc_return;
	mvc_return=1;

	startPos = XmTextGetInsertionPosition(runtext);
	current_line = find_row(runtext, startPos);

	XtVaGetValues(w, XmNuserData, &user_data, NULL);

	switch(user_data)
	  {
	    case 0:
		XtUnmanageChild(strategy_energy_label);
		XtManageChild(strategy_wave_label);
		break;
	    case 1:
		insert_field(runtext, XmTextFieldGetString(status_energy_textField), current_line, 5);
		break;
	    default:
		break;
	  }
	mvc_return=prev_mvc_return;
}

void
strat_wave_Callback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
	int user_data;
	static int prev_mvc_return;
	XmTextPosition startPos;
	int current_line;
	char	tbuf[30];

	prev_mvc_return = mvc_return;
	mvc_return=1;

	startPos = XmTextGetInsertionPosition(runtext);
	current_line = find_row(runtext, startPos);

	XtVaGetValues(w, XmNuserData, &user_data, NULL);

	switch(user_data)
	  {
	    case 0:
		XtUnmanageChild(strategy_wave_label);
		XtManageChild(strategy_energy_label);
		break;
	    case 1:
		insert_field(runtext, XmTextFieldGetString(status_wavelength_textField), current_line, 5);
		break;
	    default:
		break;
	  }
	mvc_return=prev_mvc_return;
}

/* PF End */

void
strat_kappa_Callback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
	int user_data;
	static int prev_mvc_return;
	XmTextPosition startPos;
	int current_line;

	prev_mvc_return = mvc_return;
	mvc_return=1;

	startPos = XmTextGetInsertionPosition(runtext);
	current_line = find_row(runtext, startPos);

	XtVaGetValues(w, XmNuserData, &user_data, NULL);

	switch(user_data)
	  {
	    case 0:
		insert_field(runtext,"0.00",current_line,6);
		break;
	    case 45:
		insert_field(runtext,"45.00",current_line,6);
		break;
	    case 90:
		insert_field(runtext,"90.00",current_line,6);
		break;
	    case 135:
		insert_field(runtext,"135.00",current_line,6);
		break;
	    case 180:
		insert_field(runtext,"180.00",current_line,6);
		break;
	    case 225:
		insert_field(runtext,"225.00",current_line,6);
		break;
	    case 270:
		insert_field(runtext,"270.00",current_line,6);
		break;
	    case 315:
		insert_field(runtext,"315.00",current_line,6);
		break;
	    case -135:
		insert_field(runtext,"-135.00",current_line,6);
		break;
	    case -90:
		insert_field(runtext,"-90.00",current_line,6);
		break;
	    case -45:
		insert_field(runtext,"-45.00",current_line,6);
		break;
	    default:
		break;
	  }
	mvc_return=prev_mvc_return;
}

void
strat_omega_Callback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
	int user_data;
	static int prev_mvc_return;
	XmTextPosition startPos;
	int current_line;

	prev_mvc_return = mvc_return;
	mvc_return=1;

	startPos = XmTextGetInsertionPosition(runtext);
	current_line = find_row(runtext, startPos);

	XtVaGetValues(w, XmNuserData, &user_data, NULL);

	switch(user_data)
	  {
	    case 0:
		insert_field(runtext,"0.00",current_line,7);
		break;
	    case 45:
		insert_field(runtext,"45.00",current_line,7);
		break;
	    case 90:
		insert_field(runtext,"90.00",current_line,7);
		break;
	    case 135:
		insert_field(runtext,"135.00",current_line,7);
		break;
	    case 180:
		insert_field(runtext,"180.00",current_line,7);
		break;
	    case 225:
		insert_field(runtext,"225.00",current_line,7);
		break;
	    case 270:
		insert_field(runtext,"270.00",current_line,7);
		break;
	    case 315:
		insert_field(runtext,"315.00",current_line,7);
		break;
	    case -135:
		insert_field(runtext,"-135.00",current_line,7);
		break;
	    case -90:
		insert_field(runtext,"-90.00",current_line,7);
		break;
	    case -45:
		insert_field(runtext,"-45.00",current_line,7);
		break;
	    default:
		break;
	  }
	mvc_return=prev_mvc_return;
}

void
strat_axis_Callback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
	int user_data;
	static int prev_mvc_return;
	XmTextPosition startPos;
	int current_line;

	prev_mvc_return = mvc_return;
	mvc_return=1;

	startPos = XmTextGetInsertionPosition(runtext);
	current_line = find_row(runtext, startPos);

	XtVaGetValues(w, XmNuserData, &user_data, NULL);

	switch(user_data)
	  {
	    case 0:
		insert_field(runtext,"phi",current_line,8);
		break;
	    case 1:
		insert_field(runtext,"kappa",current_line,8);
		break;
	    case 2:
		insert_field(runtext,"omega",current_line,8);
		break;
	    default:
		break;
	  }
	mvc_return=prev_mvc_return;
}

void
kappa_drive_armCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{

	/*
	if (XmToggleButtonGetState(drive_kappa_pushButton) == True) {
		raise_window(mcinfoDialog);
	}
	 */
}

void
modify_kappa_activateCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
	double kappa;
	Window window;
	Dimension m_XmNx, m_XmNy, m_XmNwidth, m_XmNheight;
	int dest_x=104, dest_y=169;
	static int init=0;
	Arg args[2];
    
	if (!init) {
		init=1;
		XtSetArg(args[0], XmNx, 500);
		XtSetArg(args[1], XmNy, 500);
		XtSetValues(define_kappa_Dialog,args,2);
	}

	if (debug) {
		fprintf(stderr,"Called modify_kappa_activateCallback...\n");
		fflush(stderr);
	}

	kappa = wtof(w);

	if (XmToggleButtonGetState(define_kappa_pushButton) == True) {
		if (sc_conf.usekappa == 0) { 
			marcommand(SET_KAPPA, kappa);
		}
		else {
			raise_window(define_kappa_Dialog);
			window  = XtWindow(define_kappa_Dialog);
			XtVaGetValues(pushButton11,
				XmNx, &m_XmNx,
				XmNy, &m_XmNy,
				XmNwidth, &m_XmNwidth,
				XmNheight, &m_XmNheight,
				NULL);

			dest_x = m_XmNx + m_XmNwidth/2;
			dest_y = m_XmNy + m_XmNheight/2;
			XWarpPointer(display, None, window, 0, 0, 0, 0, dest_x, dest_y);
		}
	}
	else {
		marcommand(DRIVE_KAPPA, kappa);
	}

}

void
omega_define_armCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{

	/*
	if (XmToggleButtonGetState(define_omega_pushButton) == True) {
		raise_window(mcinfoDialog);
	}
	 */
}

void
modify_omega_activateCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
	double omega;
	Window window;
	Dimension m_XmNx, m_XmNy, m_XmNwidth, m_XmNheight;
	int dest_x=104, dest_y=169;
	static int init=0;
	Arg args[2];
    
	if (!init) {
		init=1;
		XtSetArg(args[0], XmNx, 500);
		XtSetArg(args[1], XmNy, 500);
		XtSetValues(define_omega_Dialog,args,2);
	}

	if (debug) {
		fprintf(stderr,"Called modify_omega_activateCallback...\n");
		fflush(stderr);
	}

	omega = wtof(w);

	if (XmToggleButtonGetState(define_omega_pushButton) == True) {
		if (sc_conf.useomega == 0) { 
			marcommand(SET_OMEGA, omega);
		}
		else {
			raise_window(define_omega_Dialog);
			window  = XtWindow(define_omega_Dialog);
			XtVaGetValues(pushButton11,
				XmNx, &m_XmNx,
				XmNy, &m_XmNy,
				XmNwidth, &m_XmNwidth,
				XmNheight, &m_XmNheight,
				NULL);

			dest_x = m_XmNx + m_XmNwidth/2;
			dest_y = m_XmNy + m_XmNheight/2;
			XWarpPointer(display, None, window, 0, 0, 0, 0, dest_x, dest_y);
		}
	}
	else {
		marcommand(DRIVE_OMEGA, omega);
	}
}

void
omega_drive_armCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{

	/*
	if (XmToggleButtonGetState(drive_omega_pushButton) == True) {
		raise_window(mcinfoDialog);
	}
	 */
}

void
kappa_define_armCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{

	/*
	if (XmToggleButtonGetState(define_kappa_pushButton) == True) {
		raise_window(mcinfoDialog);
	}
	 */
}

void
mc_kappa_Callback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
	int user_data;
	char kappa[64];

	XtVaGetValues(w, XmNuserData, &user_data, NULL);

	sprintf(kappa,"%d.00",user_data);

	XmTextFieldSetString(modify_kappa_textField,kappa);
	XmTextSetInsertionEnd(modify_kappa_textField);
}

void
mc_omega_Callback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
	int user_data;
	char omega[64];

	XtVaGetValues(w, XmNuserData, &user_data, NULL);

	sprintf(omega,"%d.00",user_data);

	XmTextFieldSetString(modify_omega_textField,omega);
	XmTextSetInsertionEnd(modify_omega_textField);
}

void
define_kappa_activateCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
	int user_data;
	double kappa;

	XtVaGetValues(w, XmNuserData, &user_data, NULL);

	switch(user_data)
	  {
	    case YES:
		kappa = wtof(modify_kappa_textField);
		marcommand(SET_KAPPA,kappa);
	    	XtUnmanageChild(define_kappa_Dialog);
		break;
	    case NO:
	    	XtUnmanageChild(define_kappa_Dialog);
		break;
	    default:
		break;
	  }

	/* Reset toggle button to Drive (not Define)
	 */
	if (sc_conf.usekappa == 1) {
		XmToggleButtonSetState(define_kappa_pushButton,False,False);
		XmToggleButtonSetState(drive_kappa_pushButton,True,False);
	}
}

void
define_omega_activateCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
	int user_data;
	double omega;

	XtVaGetValues(w, XmNuserData, &user_data, NULL);

	switch(user_data)
	  {
	    case YES:
		omega = wtof(modify_omega_textField);
		marcommand(SET_OMEGA,omega);
	    	XtUnmanageChild(define_omega_Dialog);
		break;
	    case NO:
	    	XtUnmanageChild(define_omega_Dialog);
		break;
	    default:
		break;
	  }

	/* Reset toggle button to Drive (not Define)
	 */
	if (sc_conf.useomega == 1) {
		XmToggleButtonSetState(define_omega_pushButton,False,False);
		XmToggleButtonSetState(drive_omega_pushButton,True,False);
	}
}

#ifdef NOT_USED
void
strategy_dezinger_off(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    dezinger=False;
}

void
strategy_dezinger_on(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    dezinger=True;
}
#endif /* NOT_USED */

void
optstrat_activateCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
	static int init=0;
	Arg args[2];

	if (debug) {
		fprintf(stderr,"Called optstrat_activateCallback\n");
		fflush(stderr);
	}

	if (!init) {
		init=1;
		XtSetArg(args[0], XmNx, scr_width + OPTIMIZEDIALOG_X);
		XtSetArg(args[1], XmNy, OPTIMIZEDIALOG_Y);
		XtSetValues(optimize_dialog,args,2);
	}
	raise_window(optimize_dialog);
}

#ifdef NOT_USED
void
straegy_auto_activateCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    /*XmAnyCallbackStruct *acs=(XmAnyCallbackStruct*)call_data;*/
}
#endif /* NOT_USED */

void
project_new_callback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
	PARAMETER par[MAX_PARAMETERS+1];
	char *data_directory, *proc_directory;
	char *image_prefix;
	char *param_file;
	char *spgp;
	char tmpstr[256];
	char filename[256];
	int spgp_number;

	if (load_blank_file(par) == 1)
		return;

	data_directory = XmTextFieldGetString(project_data_dir_textField);
	proc_directory = XmTextFieldGetString(project_proc_dir_textField);
	image_prefix = XmTextFieldGetString(project_i_prefix_textField);
	param_file = XmTextFieldGetString(project_param_file_textField);
	spgp = XmTextFieldGetString(project_spgrp_textField);

	fprintf(stderr,"data_directory = %s\n",data_directory);
	fprintf(stderr,"proc_directory = %s\n",proc_directory);
	fprintf(stderr,"image_prefix = %s\n",image_prefix);
	fprintf(stderr,"param_file = %s\n",param_file);
	fprintf(stderr,"spgp = %s\n",spgp);

	modify_parameter_file(par,"Image_Dir",data_directory,"");
	modify_parameter_file(par,"Working_Dir",proc_directory,"");
	modify_parameter_file(par,"Image_Prefix",image_prefix,"");
	modify_parameter_file(par,"Space_Group_Name",spgp,"");

	if (strcmp(spgp,"")) {
		spgp_number = get_space_group_number(spgp);
		sprintf(tmpstr,"%d",spgp_number);
		modify_parameter_file(par,"Space_group_number",tmpstr,"");
	}

	strcpy(filename,proc_directory);
	if(filename[strlen(filename)-1] != '/')
		strcat(filename,"/");
	strcat(filename,param_file);
	fprintf(stderr,"New Parameter File is: %s\n",filename); fflush(stderr);
	write_parameter_file(filename,par);

	XmTextFieldSetString(strategy_directory_textField,data_directory);
	XmTextFieldSetString(strategy_image_prefix_textField,image_prefix);
	XmTextFieldSetString(snap_directory_textField,data_directory);

	XtFree(data_directory);
	XtFree(proc_directory);
	XtFree(image_prefix);
	XtFree(param_file);
	XtFree(spgp);

}

void
project_prev_callback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
	PARAMETER par[MAX_PARAMETERS+1];
	char *data_directory, *proc_directory;
	char *image_prefix;
	char *param_file;
	char *spgp;
	char filename[256];
	int index;
	int spgp_number;

	proc_directory = XmTextFieldGetString(project_proc_dir_textField);
	param_file = XmTextFieldGetString(project_param_file_textField);

	if (!strcmp(proc_directory,"")) {
		fprintf(stderr,"Processing Directory is BLANK.\n");
		fflush(stderr);
		return;
	}
	strcpy(filename,proc_directory);
	if(filename[strlen(filename)-1] != '/')
		strcat(filename,"/");
	strcat(filename,param_file);
	fprintf(stderr,"Old Parameter File is: %s\n",filename); fflush(stderr);

	XmTextFieldSetString(optimize_param_file_textField,param_file); /* OK */

	if (read_parameter_file(filename,par) == -1)
		return;

	index = find_tag(par, "Image_Dir");
	if (index >= 0) {
		XmTextFieldSetString(project_data_dir_textField,par[index].val);
	}
	index = find_tag(par, "Working_Dir");
	if (index >= 0) {
		if (!strcmp(proc_directory,""))
			XmTextFieldSetString(project_proc_dir_textField,par[index].val);
	}
	index = find_tag(par, "Image_Prefix");
	if (index >= 0) {
		XmTextFieldSetString(project_i_prefix_textField,par[index].val);
	}
	index = find_tag(par, "Space_Group_Name");
	if (index >= 0) {
		XmTextFieldSetString(project_spgrp_textField,par[index].val);
		spgp_number = get_space_group_number(par[index].val);
		sprintf(tmpstr,"%d",spgp_number);
		modify_parameter_file(par,"Space_group_number",tmpstr,"");
	}

	XtFree(param_file);
	XtFree(proc_directory);
}

/* Erase Lamp OK PushButton */
void
alert_OK_activateCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{

	XtUnmanageChild(alertDialog);
}

void
strategy_anomyes_armCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XtSetSensitive(label18,True);
    XtSetSensitive(label29,True);
    XtSetSensitive(strategy_wedge_textField,True);

    /* In Mad window */
    XtSetSensitive(label97,True);
    XtSetSensitive(mad_option3_toggleButton,True);
}

void
strategy_anomno_armCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XtSetSensitive(label18,False);
    XtSetSensitive(label29,False);
    XtSetSensitive(strategy_wedge_textField,False);
    XmToggleButtonSetState(strategy_anomyes_toggleButton,True,False);
    XmToggleButtonSetState(strategy_anomno_toggleButton,False,False);

    /* In Mad window */
    XtSetSensitive(label97,False);
    XtSetSensitive(mad_option3_toggleButton,False);
}

/* PF Start */

void
mc_autoal_start_activateCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
	double	slits;

	slits = wtof(mc_autoal_slit_textField);
	marcommand(AUTOALIGN, slits);
	
}

void
mc_autoal_stop_activateCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
	marcommand(AUTOALIGN, 0.0);
}

void
mc_autoal_undo_activateCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
	marcommand(AUTOALIGN, -1.0);
}

void
strategy_autoalyes_armCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
strategy_autoalno_armCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
strategy_autoaleveryyes_armCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
strategy_autoaleveryno_armCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
}

void
mc_autoal_slit_activateCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
	XmAnyCallbackStruct *acs=(XmAnyCallbackStruct*)call_data;

	if (debug) {
		fprintf(stderr,"Called mc_autoal_slit_activateCallback...\n");
		fflush(stderr);
	}
}

/* PF End */
void
options_close_activateCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
	XmAnyCallbackStruct *acs=(XmAnyCallbackStruct*)call_data;

	XtUnmanageChild(optionsDialog);
}

void
options_help_activateCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
	Unmanage_helpWindow();
	XtManageChild(options_helpWindow);

	raise_window(adx_helpDialog);
}

void
options_darkinterval_valueChangedCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
	XmAnyCallbackStruct *acs=(XmAnyCallbackStruct*)call_data;
	if (XmToggleButtonGetState(options_darkinterval_toggleButton) == True) {
		XtSetSensitive(options_darkinterval_textField,True);
		XtSetSensitive(label32,True);
		XmToggleButtonSetState(options_darkstored_toggleButton,False,False);
	}
	else {
		XtSetSensitive(options_darkinterval_textField,False);
		XtSetSensitive(label32,False);
	}
}

void
snap_axisPhi_armCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmAnyCallbackStruct *acs=(XmAnyCallbackStruct*)call_data;

	XtManageChild(snap_label_start_phi);
	XtManageChild(snap_label_delta_phi);
	XtUnmanageChild(snap_label_start_omega);
	XtUnmanageChild(snap_label_delta_omega);

	TextFieldSetFloat(snap_phi_textField,current_phi);
}

void
snap_axisOmega_armCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmAnyCallbackStruct *acs=(XmAnyCallbackStruct*)call_data;

	XtManageChild(snap_label_start_omega);
	XtManageChild(snap_label_delta_omega);
	XtUnmanageChild(snap_label_start_phi);
	XtUnmanageChild(snap_label_delta_phi);

	TextFieldSetFloat(snap_phi_textField,current_omega);
}

adxv_running() 
{
	char buf[256];
	FILE *ptr;
#ifdef sgi
	char ps_str[] = "/bin/ps -ef";
#else
#ifdef Alpha
	char ps_str[] = "/bin/ps";
#else
	char ps_str[] = "/bin/ps";
#endif 
#endif 

	fprintf(stderr,"DEBUG: Checking if adxv is running with: \"%s\"\n",ps_str); fflush(stderr);
	
	if ((ptr = popen(ps_str, "r")) != NULL) {
		while (fgets(buf, 256, ptr) != NULL) {
			if (debug) {
				fprintf(stderr,"DEBUG: Checking ps output: %s\n",buf); fflush(stderr);
			}
			if (strstr(buf,"adxv") != NULL) {
				fprintf(stderr,"DEBUG: Found adxv:\n\t%s\n",buf); fflush(stderr);
				fprintf(stderr,"adxv already running.\n");
				fflush(stderr);
				pclose(ptr);
				return 1;
			}
			if (debug) {
				fprintf(stderr,"DEBUG: adxv not found yet\n"); fflush(stderr);
			}
		}
	}
	else {
		fprintf(stderr,"DEBUG: popen() FAILED. Start adxv manually\n"); fflush(stderr);
		return 1;
	}
	pclose(ptr);
	fprintf(stderr,"DEBUG: Adxv Not Running\n"); fflush(stderr);
	return 0;
}

void
gonio_home_activateCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
	marcommand(HOME, 0.0);

}

void
gonio_manual_activateCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
	int user_data;
	XtVaGetValues(w, XmNuserData, &user_data, NULL);

	switch(user_data)
	  {
	    case GONIO_MANUAL:
		XtSetSensitive(gonio_home_pushbutton,False);
		marcommand(GON_MANUAL, 1.0);
		break;
	    case GONIO_COMPUTER:
		XtSetSensitive(gonio_home_pushbutton,True);
		marcommand(GON_MANUAL, 0.0);
		break;
	    default:
		break;
	  }
}

void
saveraw_no_armCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
	XmToggleButtonSetState(options_xform_yes,True,False);
	XmToggleButtonSetState(options_xform_no,False,False);

}

void
xform_no_armCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
	XmToggleButtonSetState(options_saveraw_yes,True,False);
	XmToggleButtonSetState(options_saveraw_no,False,False);
}

void
strategy_MAD_activateCb(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{

	raise_window(madDialog);
}

void
mad_close_activateCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{

	XtUnmanageChild(madDialog);
}

void
mad_help_activateCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
	Unmanage_helpWindow();
	XtManageChild(mad_helpWindow);

	raise_window(adx_helpDialog);
}

void
mad_energy_activateCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
	int user_data;
	double energy, wavelength;
	double energy_to_wavelength(), wavelength_to_energy();

	XtVaGetValues(w, XmNuserData, &user_data, NULL);

	switch(user_data)
	  {
	    case 1:
	    	energy = TextFieldGetFloat(energy1_textField);
		TextFieldSetFloat(energy1_textField,energy);
		wavelength = energy_to_wavelength(energy);
		TextFieldSetFloat6(wavelength1_textField,wavelength);
		break;
	    case 2:
	    	energy = TextFieldGetFloat(energy2_textField);
		TextFieldSetFloat(energy2_textField,energy);
		wavelength = energy_to_wavelength(energy);
		TextFieldSetFloat6(wavelength2_textField,wavelength);
		break;
	    case 3:
	    	energy = TextFieldGetFloat(energy3_textField);
		TextFieldSetFloat(energy3_textField,energy);
		wavelength = energy_to_wavelength(energy);
		TextFieldSetFloat6(wavelength3_textField,wavelength);
		break;
	    case 4:
	    	energy = TextFieldGetFloat(energy4_textField);
		TextFieldSetFloat(energy4_textField,energy);
		wavelength = energy_to_wavelength(energy);
		TextFieldSetFloat6(wavelength4_textField,wavelength);
		break;
	    case 5:
	    	energy = TextFieldGetFloat(energy5_textField);
		TextFieldSetFloat(energy5_textField,energy);
		wavelength = energy_to_wavelength(energy);
		TextFieldSetFloat6(wavelength5_textField,wavelength);
		break;
	    default:
	    	fprintf(stderr,"Bad Switch: %d\n", user_data); fflush(stderr);
		break;
	  }
}

void
mad_wavelength_activateCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
	int user_data;
	double energy, wavelength;
	double energy_to_wavelength(), wavelength_to_energy();

	XtVaGetValues(w, XmNuserData, &user_data, NULL);

	switch(user_data)
	  {
	    case 1:
	    	wavelength = TextFieldGetFloat(wavelength1_textField);
		TextFieldSetFloat6(wavelength1_textField,wavelength);
		energy = wavelength_to_energy(wavelength);
		TextFieldSetFloat(energy1_textField,energy);
		break;
	    case 2:
	    	wavelength = TextFieldGetFloat(wavelength2_textField);
		TextFieldSetFloat6(wavelength2_textField,wavelength);
		energy = wavelength_to_energy(wavelength);
		TextFieldSetFloat(energy2_textField,energy);
		break;
	    case 3:
	    	wavelength = TextFieldGetFloat(wavelength3_textField);
		TextFieldSetFloat6(wavelength3_textField,wavelength);
		energy = wavelength_to_energy(wavelength);
		TextFieldSetFloat(energy3_textField,energy);
		break;
	    case 4:
	    	wavelength = TextFieldGetFloat(wavelength4_textField);
		TextFieldSetFloat6(wavelength4_textField,wavelength);
		energy = wavelength_to_energy(wavelength);
		TextFieldSetFloat(energy4_textField,energy);
		break;
	    case 5:
	    	wavelength = TextFieldGetFloat(wavelength5_textField);
		TextFieldSetFloat6(wavelength5_textField,wavelength);
		energy = wavelength_to_energy(wavelength);
		TextFieldSetFloat(energy5_textField,energy);
		break;
	    default:
	    	fprintf(stderr,"Bad Switch: %d\n", user_data); fflush(stderr);
		break;
	  }
}

void
mad_energy_losingFocusCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
	mad_energy_activateCallback(w, client_data, call_data);
}


void
mad_wavelength_losingFocusCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
	mad_wavelength_activateCallback(w, client_data, call_data);
}

void
mad_energy_armCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
	int user_data;
	int state;

	XtVaGetValues(w, XmNuserData, &user_data, NULL);

	state = !XmToggleButtonGetState(w);
	switch(user_data)
	  {
	    case 1:
		XtSetSensitive(energy1_textField,state);
		XtSetSensitive(wavelength1_textField,state);
		break;
	    case 2:
		XtSetSensitive(energy2_textField,state);
		XtSetSensitive(wavelength2_textField,state);
		break;
	    case 3:
		XtSetSensitive(energy3_textField,state);
		XtSetSensitive(wavelength3_textField,state);
		break;
	    case 4:
		XtSetSensitive(energy4_textField,state);
		XtSetSensitive(wavelength4_textField,state);
		break;
	    case 5:
		XtSetSensitive(energy5_textField,state);
		XtSetSensitive(wavelength5_textField,state);
		break;
	    default:
	    	fprintf(stderr,"Bad Switch: %d\n", user_data); fflush(stderr);
		break;
	  }
}

void
adx_closehelpCB(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
	XtUnmanageChild(adx_helpDialog);
}

Unmanage_helpWindow()
{
	XtUnmanageChild(manualcontrol_helpWindow);
	XtUnmanageChild(optimize_helpWindow);
	XtUnmanageChild(strategy_helpWindow);
	XtUnmanageChild(snapshot_helpWindow);
	XtUnmanageChild(status_helpWindow);
	XtUnmanageChild(project_helpWindow);
	XtUnmanageChild(options_helpWindow);
	XtUnmanageChild(mad_helpWindow);
	XtUnmanageChild(config_site_helpWindow);
}


void
text_motionVerifyCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
	
	if (debug) {
		fprintf(stderr,"Called text_motionVerifyCallback\n");
		fflush(stderr);
	}
}

void
junk2(w, unused, event, continue_to_dispatch) 
Widget w;		/* Widget */
XtPointer unused;	/* Closure */
XEvent *event;		/* Event */
Boolean *continue_to_dispatch; /* Continue to dispatch */
{
	int x, y, startPos;
	int current_line, current_column, current_field;
        char field_str[32];
	int nspace=0;
	char *sel;
	int mycol;
	void junk3();

	if (debug) {
		fprintf(stderr,"Called junk2()\n");
	}

	x = event->xbutton.x;
	y = event->xbutton.y;

	/*
	sel = XmTextGetSelection(w);
	if (sel != NULL)
		free(sel);
	 */

	startPos = XmTextXYToPos(w, x, y);
	current_line = find_row(w, startPos);
	current_column = find_column(w, startPos);

	if (find_column(w, startPos+1) == current_column)
		current_column--;

	current_field = find_field(current_column);

	if (startPos == XmTextXYToPos(w, x-10, y)) {
		int i, jindex;
        	char spaces[256];
		int strlength;
		char *tstr = (char *)XmTextGetString(w);
		strlength = strlen(tstr);
		XtFree(tstr);

		for(i=0;i<256;i++)
			spaces[i] = SPACE_CHAR;

		current_field = find_field2(current_column);

		if (current_field == (n_fields-1))
			return;

		mvc_return=1;
		current_field++;
		current_column = find_column(w, startPos);
		jindex = find_index(w, current_line, 0) + fld[current_field].col_end + 1 - startPos;
		spaces[jindex] = 0;
		XmTextInsert(w,strlength,spaces);
		current_column = fld[current_field].col_end+1;
		XmTextSetInsertionPosition(w, 
			find_index(w, current_line, fld[current_field].col_end+1));
		mvc_return=0;
		junk3(1234, find_index(w, current_line, fld[current_field].col_end+1), 0, 0) ;
		return;
	}



	extract_field(w, field_str, current_line, current_field);

	mycol = current_column - fld[current_field].col_start;
	if (mycol >= 0 && mycol < (fld[current_field].col_end - fld[current_field].col_start + 1)) {
		if (!isspace(field_str[mycol]) || (current_field == 12)) {
			return;
		}
	}
	if (current_column > fld[current_field].col_end) {
		if (!iswhite(field_str))
		while (field_str[strlen(field_str)-1-nspace] == ' ')
			nspace++;
		/*XmTextSetInsertionPosition(w, fld[current_field].col_end+1-nspace);*/
		XmTextSetInsertionPosition(w, find_index(w, current_line, fld[current_field].col_end+1-nspace));
		junk3(1234, find_index(w, current_line, fld[current_field].col_end+1-nspace), 0, 0) ;
	}
	else {
		if (iswhite(field_str)) {
			XmTextSetInsertionPosition(w, find_index(w, current_line, fld[current_field].col_end+1));
			junk3(1234, find_index(w, current_line, fld[current_field].col_end+1), 0, 0) ;
		}
		else {
		while (field_str[nspace] == ' ')
			nspace++;
		/*XmTextSetInsertionPosition(w, fld[current_field].col_start+nspace);*/
		XmTextSetInsertionPosition(w, find_index(w, current_line, fld[current_field].col_start+nspace));
		junk3(1234, find_index(w, current_line, fld[current_field].col_start+nspace), 0, 0);
		}
	}
}

void
junk2a(w, unused, event, continue_to_dispatch) 
Widget w;		/* Widget */
XtPointer unused;	/* Closure */
XEvent *event;		/* Event */
Boolean *continue_to_dispatch; /* Continue to dispatch */
{
	int startPos;
	int current_line, current_column, current_field;
        char field_str[32];
	int nspace=0;
	char *sel;
	int mycol;
        KeySym keysym;
	int direction;

	if (debug) {
		fprintf(stderr,"Called junk2a()\n");
	}


	XLookupString(&(event->xkey), NULL, 0, &keysym, NULL);

	if ((keysym != XK_Left) && (keysym != XK_Right))
		return;



	direction = keysym;

	startPos = XmTextGetInsertionPosition(w);

	adjust_position(w, startPos, direction);
}

void
junk3(w, unused, event, continue_to_dispatch) 
Widget w;		/* Widget */
XtPointer unused;	/* Closure */
XEvent *event;		/* Event */
Boolean *continue_to_dispatch; /* Continue to dispatch */
{
	int x, y, startPos;
	int current_line, current_column, current_field;
        char field_str[32];
	int nspace=0;
	char *sel;
	int mycol;
	static int prev_mvc_return;
	static int prev_startPos=0;
	char *s1;

	if (debug) {
		fprintf(stderr,"Called junk3()\n");
	}

	if (((int)w == 1234) && ((int)event == 0) && ((int)continue_to_dispatch == 0)) {
		if (((int)unused > 0) && ((int)unused < 10000)) {
			prev_startPos = (int)unused;
		}
		return;
	}

	s1 = (char *)XmTextGetString(w);


	x = event->xbutton.x;
	y = event->xbutton.y;
	startPos = XmTextXYToPos(w, x, y);

	if (prev_startPos > strlen(s1)) {
		XtFree(s1);
		prev_startPos = startPos;
		return;
	}

	current_line = find_row(w, prev_startPos);
	current_column = find_column(w, prev_startPos);
	current_field = find_field(current_column);

	if (is_blank(w, current_line)) {
		prev_startPos = startPos;
		return;
	}

	prev_mvc_return = mvc_return;
	clean_up(w, current_line, current_field);
	mvc_return=prev_mvc_return;
	
	prev_startPos = startPos;

	XtFree(s1);
}

adjust_position(w, startPos, direction)
Widget w;		/* Widget */
int startPos;
int direction;
{
	int current_line, current_column, current_field;
        char field_str[32];
	int nspace=0;
	int mycol;

	current_line = find_row(w, startPos);
	current_column = find_column(w, startPos);
	current_field = find_field(current_column);
	

	extract_field(w, field_str, current_line, current_field);

	mycol = current_column - fld[current_field].col_start;
	if (mycol >= 0 && mycol < (fld[current_field].col_end - fld[current_field].col_start + 2)) {
		if (!isspace(field_str[mycol])) {
			return 1;
		}
	}
	if ((current_column > (fld[current_field].col_end) && (direction == XK_Right))) {
		if (current_field < (n_fields-1))
			current_field++;

		extract_field(w, field_str, current_line, current_field);
		while (field_str[nspace] == ' ')
			nspace++;
		XmTextSetInsertionPosition(w, find_index(w, current_line, fld[current_field].col_start+nspace));
	}
	else
	if ((current_column <= (fld[current_field].col_start)) && (direction == XK_Right)) {
		extract_field(w, field_str, current_line, current_field);
		while (field_str[nspace] == ' ')
			nspace++;
		XmTextSetInsertionPosition(w, find_index(w, current_line, fld[current_field].col_start+nspace));
	}
	else {
		if (current_field > 0)
			current_field--;
		while (field_str[strlen(field_str)-1-nspace] == ' ')
			nspace++;
		XmTextSetInsertionPosition(w, find_index(w, current_line, fld[current_field].col_end+1-nspace));
	}

	return 0;
}
is_blank(w, line)
Widget w;
int line;
{
	char str[256];
	int tstrlength;
	int linelength;
	char *tstr = (char *)XmTextGetString(w);

	tstrlength = strlen(tstr);
	linelength = fld[n_fields-1].col_end - fld[0].col_start + 1;

	if (linelength > (tstrlength - find_index(w,line,0) - 1))
		linelength = tstrlength - find_index(w,line,0) - 1;

	if (linelength < 1) {
		XtFree(tstr);
		return 1;
	}

	strncpy(str, tstr + find_index(w,line,0), linelength);
	str[linelength] = 0;

	XtFree(tstr);

	if (iswhite(str)) {
		return 1;
	}
	else
		return 0;
}

void
configsite_config_Callback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
	XmAnyCallbackStruct *acs=(XmAnyCallbackStruct*)call_data;

	write_configurable_file();
}

void
configsite_help_activateCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
	XmAnyCallbackStruct *acs=(XmAnyCallbackStruct*)call_data;

	XtManageChild(config_site_helpWindow);
	raise_window(adx_helpDialog);
}

void
configsite_close_activateCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmAnyCallbackStruct *acs=(XmAnyCallbackStruct*)call_data;
    XtUnmanageChild(configsiteDialog);
}

void
strategy_configSite_activateCb(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmAnyCallbackStruct *acs=(XmAnyCallbackStruct*)call_data;
    raise_window(configsiteDialog);
}

void
strategy_configCCD_activateCb(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmAnyCallbackStruct *acs=(XmAnyCallbackStruct*)call_data;
    raise_window(optionsDialog);
}

void
options_darkstored_valueChangedCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmAnyCallbackStruct *acs=(XmAnyCallbackStruct*)call_data;
    static int prev_darkrun, prev_darkinterval;


	if (XmToggleButtonGetState(options_darkstored_toggleButton) == True) {
		prev_darkrun = XmToggleButtonGetState(options_darkrun_toggleButton);
		prev_darkinterval = XmToggleButtonGetState(options_darkinterval_toggleButton);
		XmToggleButtonSetState(options_darkinterval_toggleButton,False,False);
		XmToggleButtonSetState(options_darkrun_toggleButton,False,False);
		XtSetSensitive(options_darkinterval_textField,False);
		XtSetSensitive(label32,False);
	}
	else {
		if (prev_darkrun == True) {
			XmToggleButtonSetState(options_darkrun_toggleButton,True,False);
		}
		if (prev_darkinterval == True) {
			XmToggleButtonSetState(options_darkinterval_toggleButton,True,False);
			XtSetSensitive(options_darkinterval_textField,True);
			XtSetSensitive(label32,True);
		}
	}
}

void
options_darkrun_valueChangedCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmAnyCallbackStruct *acs=(XmAnyCallbackStruct*)call_data;

	if (XmToggleButtonGetState(options_darkrun_toggleButton) == True) {
		XmToggleButtonSetState(options_darkstored_toggleButton,False,False);
	}
}

void
wavelength_drive_armCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmAnyCallbackStruct *acs=(XmAnyCallbackStruct*)call_data;
}

/* PF Start */

void
energy_drive_armCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmAnyCallbackStruct *acs=(XmAnyCallbackStruct*)call_data;
}

/* PF End */

void
mc_wavelength_Callback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
	XmAnyCallbackStruct *acs=(XmAnyCallbackStruct*)call_data;

	int user_data;
	char wavelength[64];

	XtVaGetValues(w, XmNuserData, &user_data, NULL);

	sprintf(wavelength,"%1.4f",user_data/10000.0);

	XmTextFieldSetString(modify_wavelength_textField,wavelength);
	XmTextSetInsertionEnd(modify_wavelength_textField);
}

void
modify_wavelength_activateCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
	XmAnyCallbackStruct *acs=(XmAnyCallbackStruct*)call_data;
	char tbuf[20];

	double wavelength;
    
	if (debug) {
		fprintf(stderr,"Called modify_omega_activateCallback...\n");
		fflush(stderr);
	}

	wavelength = wtof(w);
	if(sc_conf.pf_mod)
	{
		sprintf(tbuf,"%.1f", EV_ANGSTROM / wavelength);
		XmTextFieldSetString( mc_modify_energy_textField, tbuf);
	}

	if (XmToggleButtonGetState(define_wavelength_pushButton) == True) {
		marcommand(SET_WAVELENGTH, wavelength);
	}
	else {
		marcommand(DRIVE_WAVELENGTH, wavelength);
	}
}

/* PF Start */

void
mc_modify_energy_activateCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
	XmAnyCallbackStruct *acs=(XmAnyCallbackStruct*)call_data;
	double wavelength;
	char tbuf[20];

	if (debug) {
		fprintf(stderr,"Called modify_omega_activateCallback...\n");
		fflush(stderr);
	}

	wavelength = EV_ANGSTROM / wtof(w);
	sprintf(tbuf,"%.5f", wavelength);
	XmTextFieldSetString( modify_wavelength_textField, tbuf);

	if (XmToggleButtonGetState(define_wavelength_pushButton) == True) {
		marcommand(SET_WAVELENGTH, wavelength);
	}
	else {
		marcommand(DRIVE_WAVELENGTH, wavelength);
	}
}

/* PF End */

void
wavelength_define_armCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmAnyCallbackStruct *acs=(XmAnyCallbackStruct*)call_data;
}

void
energy_define_armCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmAnyCallbackStruct *acs=(XmAnyCallbackStruct*)call_data;
}

void
MoreSigmaCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmAnyCallbackStruct *acs=(XmAnyCallbackStruct*)call_data;
}

void
infoWindowClose(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmAnyCallbackStruct *acs=(XmAnyCallbackStruct*)call_data;
}

void
closehelpCB(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmAnyCallbackStruct *acs=(XmAnyCallbackStruct*)call_data;
}

void
SliceVerifyNumericCB(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmAnyCallbackStruct *acs=(XmAnyCallbackStruct*)call_data;
}

void
show_header_cb(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmAnyCallbackStruct *acs=(XmAnyCallbackStruct*)call_data;
}

void
hkl_y_activateCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmAnyCallbackStruct *acs=(XmAnyCallbackStruct*)call_data;
}

void
hkl_x_activateCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmAnyCallbackStruct *acs=(XmAnyCallbackStruct*)call_data;
}

void
predWindowClose(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmAnyCallbackStruct *acs=(XmAnyCallbackStruct*)call_data;
}

void
MorePeaksCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmAnyCallbackStruct *acs=(XmAnyCallbackStruct*)call_data;
}

void
statWindowClose(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmAnyCallbackStruct *acs=(XmAnyCallbackStruct*)call_data;
}

void
MinSpacingCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmAnyCallbackStruct *acs=(XmAnyCallbackStruct*)call_data;
}

void
InvertdaCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmAnyCallbackStruct *acs=(XmAnyCallbackStruct*)call_data;
}

void
show_predictions_cb(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmAnyCallbackStruct *acs=(XmAnyCallbackStruct*)call_data;
}

void
show_statistics_cb(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmAnyCallbackStruct *acs=(XmAnyCallbackStruct*)call_data;
}

void
PeakSearchCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmAnyCallbackStruct *acs=(XmAnyCallbackStruct*)call_data;
}

void
openhelpCB(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmAnyCallbackStruct *acs=(XmAnyCallbackStruct*)call_data;
}

void
PredsCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmAnyCallbackStruct *acs=(XmAnyCallbackStruct*)call_data;
}

void
spotaction_armCb(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmAnyCallbackStruct *acs=(XmAnyCallbackStruct*)call_data;
}

void
FixSettingsCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmAnyCallbackStruct *acs=(XmAnyCallbackStruct*)call_data;
}

void
hkl_activateCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmAnyCallbackStruct *acs=(XmAnyCallbackStruct*)call_data;
}

void
HKLUnitsCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmAnyCallbackStruct *acs=(XmAnyCallbackStruct*)call_data;
}

void
strategy_MADyes_armCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmAnyCallbackStruct *acs=(XmAnyCallbackStruct*)call_data;
    XtSetSensitive(madDialog,True);
    raise_window(madDialog);
}

void
strategy_MADno_armCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmAnyCallbackStruct *acs=(XmAnyCallbackStruct*)call_data;
    XtSetSensitive(madDialog,False);
    XtUnmanageChild(madDialog);
}

void
mad_anom_wedge_armCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmAnyCallbackStruct *acs=(XmAnyCallbackStruct*)call_data;
    /*
    XtSetSensitive(label18,True);
    XtSetSensitive(label29,True);
    XtSetSensitive(strategy_wedge_textField,True);
    XmToggleButtonSetState(strategy_anomyes_toggleButton,True,False);
    XmToggleButtonSetState(strategy_anomno_toggleButton,False,False);
    */
}

void
mad_anom_wedge_disarmCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmAnyCallbackStruct *acs=(XmAnyCallbackStruct*)call_data;
    /*
    XtSetSensitive(label18,False);
    XtSetSensitive(label29,False);
    XtSetSensitive(strategy_wedge_textField,False);
    */
}

void
mad_anom_wedge_valueChangedCallback(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmAnyCallbackStruct *acs=(XmAnyCallbackStruct*)call_data;
}
