cat ccd_dc_defs.h
#include	<stdio.h>
#include	"../incl/ccdconv.h"
#include	"../incl/esd.h"
#include	"../incl/esd_com.h"
#include	"../incl/ccddefs.h"
#include	"../incl/ccdsys.h"
#include	<errno.h>
#include	<signal.h>
#include	<math.h>

#ifndef VMS
#include	<sys/types.h>
#include	<sys/time.h>
#include	<sys/socket.h>
#include	<netinet/in.h>
#else
#include	<types.h>
#include	<time.h>
#include	<socket.h>
#include	<in.h>
#include	"../incl/vms_select.h"
#endif /* VMS */

#ifdef VMS
#define	GOOD_STATUS	1
#define	BAD_STATUS	2
#else
#define	GOOD_STATUS	0
#define	BAD_STATUS	1
#endif /* VMS */

#define	CCD_N_CTRL		"CCD_N_CTRL"

#define	CCD_DET_OK		0
#define	CCD_DET_RETRY		1
#define	CCD_DET_FATAL		2
#define	CCD_DET_NOTCONNECTED	3
#define	CCD_DET_DISCONNECTED	4

#define	CCD_BL_OK		10
#define	CCD_BL_RETRY		11
#define	CCD_BL_FATAL		12
#define	CCD_BL_NOTCONNECTED	13
#define	CCD_BL_DISCONNECTED	14

#define	MAXREMARK	100
#define	BLCMDMAX	256

struct mdc_command {
		int	cmd_used;	/* 0 if this queue entry unused */
		struct mdc_command *cmd_next;	/* next command in queue */
		int	cmd_no;		/* the command number/this command */
		int	cmd_err;	/* 1 if there is an error */
		float	cmd_value;	/* a value field, if appropriate */
		float	cmd_col_dist;	/* distance for data collection */
		float	cmd_col_lift;	/* lift value for data collection */
		float	cmd_col_phis;	/* phi start for data collection */
		float	cmd_col_omegas;	/* omega start for data collection */
		float	cmd_col_kappas;	/* kappa start for data collection */
		float	cmd_col_osc_width;  /* oscillation width/image */
		int	cmd_col_axis;	/* 1 for phi, 0 for omega */
		int	cmd_col_newdark;    /* 1 for a new dark current image, else 0 */
		int	cmd_col_anom;	    /* 1 for anomalous data */
		int	cmd_col_wedge;	    /* wedge (#frames per batch) size for anom data */
		int	cmd_col_n_images;   /* number of images to collect */
		int	cmd_col_n_passes;   /* number of osc passes/image */
		float	cmd_col_time;	    /* data collection time/image */
		int	cmd_col_mode;	    /* 0 = collect time, 1 dose */
		int	cmd_col_image_number; /* start image number */
		char	cmd_col_dir[132];   /* directory for output images */
		char	cmd_col_prefix[30]; /* image name prefix */
		char	cmd_col_suffix[30]; /* image name suffix */
		int	cmd_col_adc;	    /* adc select */
		int	cmd_col_bin;	    /* bin select */
		float	cmd_col_xcen;	    /* x detector center in mm for oblique correction */
		float	cmd_col_ycen;	    /* y detector center in mm for oblique correction */
		int	cmd_col_compress;   /* 0 for none, 1 for .Z, 2 for .pck */
		float	cmd_col_dzratio;    /* ratio of 2nd picture expos time to 1st */
		int	cmd_col_dkinterval; /* interval between darks */
		int	cmd_col_rep_dark;   /* 1 to repeat darks every darkinterval seconds */
		int	cmd_col_dk_before;  /* 1 to repeat darks before each run */
		int	cmd_col_outfile_type;	/* 0 for 16 bit, 1 for 32 bit, 2 for 16 + overflow records */
		int	cmd_col_no_transform;	/* 1 to not transform data */
		int	cmd_col_output_raws;	/* 1 to output raws */
		float	cmd_col_step_size;	/* size of step for step/dose mode */
		float	cmd_col_dose_step;	/* dose per step, step/dose mode */
		float	cmd_col_atten_run;	/* attenuator amount for this run */
		float	cmd_col_hslit_run;	/* horiz slit amount for this run */
		float	cmd_col_vslit_run;	/* vertical slit amount for this run */
		float	cmd_col_autoal_run;	/* autoalign every run */
		float	cmd_col_run_wave;
		int	cmd_col_mad_mode;	/* 0 never, 1 per run, 2 per wedge, 3 per nframes */
		int	cmd_col_mad_nframes;	/* for mode = 3, number of frames between wavelength changes */
		int	cmd_col_mad_nwave;	/* number of wavelengths */
		float	cmd_col_mad_wavelengths[10];	/* wavelengths */
		float	cmd_col_do_wavelength;	/* used after runs are expanded in the queue */
		int	cmd_col_remarkc;    	/* number of remark records */
		int	cmd_col_restart_run;		/* run number for restart */
		int	cmd_col_restart_image;		/* image number for restart */
		char	*cmd_col_remarkv[MAXREMARK];  /* pointers to remarks */
		char	cmd_col_blcmd[BLCMDMAX];
	       };

typedef struct mdc_command mdc_command;

enum {
	MDC_COM_EOC = 0,
	MDC_COM_EXIT,
	MDC_COM_CONFIG,
	MDC_COM_STARTUP,
	MDC_COM_ERASE,
	MDC_COM_INIT,
	MDC_COM_STOP,
	MDC_COM_ABORT,
	MDC_COM_DMOVE,
	MDC_COM_PMOVE,
	MDC_COM_PMOVEREL,
	MDC_COM_DSET,
	MDC_COM_PSET,
	MDC_COM_LMOVE,
	MDC_COM_LSET,
	MDC_COM_WMOVE,
	MDC_COM_WSET,
	MDC_COM_SHUT,
	MDC_COM_SCAN,
	MDC_COM_OMOVE,
	MDC_COM_OSET,
	MDC_COM_KMOVE,
	MDC_COM_KSET,
	MDC_COM_COLL,
	MDC_COM_SNAP,
	MDC_COM_GONMAN,
	MDC_COM_HOME,
	MDC_COM_AMOVE,
	MDC_COM_AUTOALIGN,
	MDC_COM_XL_HS_MOVE,
	MDC_COM_XL_VS_MOVE,
	MDC_COM_XL_UP_HHS_MOVE,
	MDC_COM_XL_UP_VHS_MOVE,
	MDC_COM_XL_DN_HHS_MOVE,
	MDC_COM_XL_DN_VHS_MOVE,
	MDC_COM_QLIST,
	MDC_COM_QFLUSH,
	MDC_COL_DIST,
	MDC_COL_PHIS,
	MDC_COL_OSCW,
	MDC_COL_NIM,
	MDC_COL_DEZING,
	MDC_COL_TIME,
	MDC_COL_IMNO,
	MDC_COL_DIR,
	MDC_COL_PRE,
	MDC_COL_SUF,
	MDC_COL_MODE,
	MDC_COL_WAVE,
	MDC_COL_REMARK,
	MDC_COL_LIFT,
	MDC_COL_ADC,
	MDC_COL_BIN,
	MDC_COL_CENTER,
	MDC_COL_KSTART,
	MDC_COL_OSTART,
	MDC_COL_AXIS,
	MDC_COL_NDARK,
	MDC_COL_ANOM,
	MDC_COL_WEDGE,
	MDC_COL_COMPRESS,
	MDC_COL_BLCMD,
	MDC_COL_DZRATIO,
	MDC_COL_DKIVAL,
	MDC_COL_DKREP,
	MDC_COL_DKBEF,
	MDC_COL_OFILE,
	MDC_COL_NO_TRANSFORM,
	MDC_COL_OUTPUT_RAWS,	
	MDC_COL_STEP_SIZE,
	MDC_COL_DOSE_STEP,
	MDC_COL_MAD,
	MDC_COL_MAD_WAVE,
	MDC_COL_RESTART_RUN,
	MDC_COL_RESTART_IMAGE,
	MDC_COL_ATTEN_RUN,
	MDC_COL_AUTOAL_RUN,
	MDC_COL_HSLIT_RUN,
	MDC_COL_VSLIT_RUN
	};

#define	MAXQUEUE	100

#define	MAX_CMD		16

/*
 *	These are defines which are common to all
 *	scanners.  They form the first level
 *	initialization to the programs specific
 *	scanner variables.  These values may be
 *	overridden by a user supplied configuration
 *	table.
 */

#define	SPECIFIC_PHI_STEPS_DEG	(500)
#define	SPECIFIC_DIST_STEPS_MM	(100)
#define	SPECIFIC_PHI_TOP_SPEED	(2000)
#define	SPECIFIC_DIST_TOP_SPEED	(1000)
#define	SPECIFIC_DIST_MAX_POINT	(42500)
#define	SPECIFIC_DIST_MIN_POINT	(6500)
#define	SPECIFIC_UNITS_PER_SEC	(1000)
#define	SPECIFIC_UNITS_PER_DOSE	(1000)
#define	SPECIFIC_WAVELENGTH	(1.5418)
#define	SPECIFIC_IS_DIST	(1)
#define	SPECIFIC_IS_PHI		(1)
#define	SPECIFIC_MULTIPLIER	(4.)
#define	SPECIFIC_FLAGS		(0)
#define	SPECIFIC_LIFT_STEPS_MM	(100)
#define	SPECIFIC_LIFT_TOP_SPEED (1000)
#define	SPECIFIC_LIFT_MAX_POINT	(15000)
#define	SPECIFIC_LIFT_MIN_POINT	(0)
#define	SPECIFIC_IS_LIFT	(0)

#define	SPECIFIC_NC_POINTER	(0)
#define	SPECIFIC_NC_INDEX	(0)
#define	SPECIFIC_NC_X		(0)
#define	SPECIFIC_NC_Y		(0)
#define	SPECIFIC_NC_REC		(0)
#define	SPECIFIC_NC_POFF	(0)

#define	SPECIFIC_SCSI_ID	(2)
#define	SPECIFIC_SCSI_CONTROLLER	(0)
#define	SPECIFIC_SPIRAL_CHECK	(1)

#define	SPECIFIC_READ_FAST	(2.2)
#define	SPECIFIC_READ_SLOW	(8.7)
#define	SPECIFIC_READ_OVERHEAD	(1.0)
#define	SPECIFIC_BIN_FACTOR	(2.7)
#define	SPECIFIC_IS_KAPPA	(0)
#define	SPECIFIC_IS_OMEGA	(0)
#define	SPECIFIC_DEF_DEZINGER	(0)
#define	SPECIFIC_IS_2THETA	(0)
#define	SPECIFIC_PCSHUTTER	(0)
#define	SPECIFIC_DARK_INTERVAL	(0)
#define	SPECIFIC_PIXEL_SIZE	(0.085)
#define	SPECIFIC_DK_BEFORE_RUN	(1)
#define	SPECIFIC_OUTFILE_TYPE	(0)
#define	SPECIFIC_DETECTOR_SN	(-1)
#define	SPECIFIC_NO_TRANSFORM	(0)
#define	SPECIFIC_OUTPUT_RAWS	(0)
#define	SPECIFIC_J5_TRIGGER	(0)
#define	SPECIFIC_TIMECHECK	(0)
#define	SPECIFIC_CONSTRAIN_OMEGA	(360)
#define	SPECIFIC_CONSTRAIN_PHI		(360)
#define	SPECIFIC_CONSTRAIN_KAPPA	(360)
#define	SPECIFIC_STRIP_AVE	(0)
#define SPECIFIC_BCHK_TIME      (2.)
#define SPECIFIC_BCHK_DELTAPHI  (0.1)
#define SPECIFIC_IS_WAVELENGTH  (0)
#define SPECIFIC_APPROACH_START (0.0)
#define SPECIFIC_CHIP_SIZE_X      (1152)
#define SPECIFIC_CHIP_SIZE_Y      (1152)
#define SPECIFIC_KAPPA_CONST    (50.0)
#define SPECIFIC_MADRUN_NAMING  (0)
#define SPECIFIC_RETRYSHORT  	(0)
#define	SPECIFIC_CCD_MODULAR	(0)
#define SPECIFIC_PF_MOD         (0)
#define	SPECIFIC_MIN_VELOCITY	(.0001)
#define	SPECIFIC_MAX_VELOCITY	(100.0)
#define	SPECIFIC_ALLOW_STILLS	(0)
#define	SPECIFIC_PITCH_TUNE_DELTA (0)
#define SPECIFIC_BM8_MOD	(0)

/*
 *	These are scanner specific values, in the
 *	sense that they differ from TYPE of scanner.
 *
 *	They form the first level initialization to
 *	the programs specific scanner variables.
 *	These values may be overridden by a user
 *	supplied configration file.
 *
 *	Possible defines: (ONLY one may be defined)
 *
 *	#define	SCANNER_TYPE_BIG_BIG	1
 *	#define	SCANNER_TYPE_SMALL_HOLE	1
 */

#define	SCANNER_TYPE_SMALL_HOLE	1

#ifdef SCANNER_TYPE_BIG_BIG

#define	SPECIFIC_ERASE_TIME		(40.)
#define	SPECIFIC_SCAN_TIME		(136.)
#define	SPECIFIC_DC_ERASE_TIME		(70.)
#define	SPECIFIC_TOTAL_VALID_BLOCKS	(11952)
#define	SPECIFIC_TOTAL_PIXELS_X		(2000)
#define	SPECIFIC_TOTAL_PIXELS_Y		(2000)

#endif /* SCANNER_TYPE_BIG_BIG */

#ifdef SCANNER_TYPE_SMALL_HOLE

#define	SPECIFIC_ERASE_TIME		(34.)
#define	SPECIFIC_SCAN_TIME		(100.)
#define	SPECIFIC_DC_ERASE_TIME		(39.)
#define SPECIFIC_TOTAL_VALID_BLOCKS	(4224)
#define	SPECIFIC_TOTAL_PIXELS_X		(1200)
#define	SPECIFIC_TOTAL_PIXELS_Y		(1200)

#endif /* SCANNER_TYPE_SMALL_HOLE */

#ifdef SCANNER_TYPE_SMALL

#define	SPECIFIC_ERASE_TIME		(34.)
#define	SPECIFIC_SCAN_TIME		(75.)
#define	SPECIFIC_DC_ERASE_TIME		(54.)
#define SPECIFIC_TOTAL_VALID_BLOCKS	(4352)
#define	SPECIFIC_TOTAL_PIXELS_X		(1200)
#define	SPECIFIC_TOTAL_PIXELS_Y		(1200)
#define	SPECIFIC_MULTIPLIER		(4.)

#endif /* SCANNER_TYPE_SMALL */
cat ccd_dc_glob.c
#include	"ccd_dc_defs.h"

char ifname[256];	/* translated command file name */
char ofname[256];	/* translated output file name */
char sfname[256];	/* translated status file name */
char simdir[256];	/* translated directory name for fake images */
char xfcmdn[256];	/* ip_xform command name */
char lfname[256];	/* for logging important hardware messages */
char confname[256];	/* configuration file name */
char profname[256];	/* profile file name */

char fname_lead[256];	/* leading part of output images */
char fname_dir[256];	/* the directory part */
char scan_dir[256];	/* used to store the spiral files */
char scan_dir_export[256];	/* used to store the spiral files with exported NFS directory name of scan_dir */
char spiralfilename[512];	/* used to contain spiral file name */
char spiralfilename_export[512];	/* exported spiral file name */
char cartimagename[512];	/* what the spiral file will transform to */

int	fdcom;		/* file (socket) desc for command */
int	fdout;		/* file (socket) desc for output */
FILE	*fpout;		/* file pointer for output */
int	fdstat;		/* file (socket) desc for status */
int	fdxfcm;		/* file (socket) desc for transform */
FILE	*fplog;		/* log file for useful info */
FILE	*fpconfig;	/* file pointer for config file */
FILE	*fprun;		/* used in run file generation */
int	fddetcmd;	/* detector process command socket */
int	fddetstatus;	/* detector process status socket */
int	fdblcmd;	/* beamline process command socket */
int	fdblstatus;	/* beamline process status socket */

int	fposcom;	/* current file position for command */
int	fposout;	/* current file position for output */
int	fposstat;	/* current file position for status */
int	detector_sn;	/* serial number of the detector, if known */
int	output_raws;	/* 1 to output raws */
int	no_transform;	/* 1 to do no transform on line */
int	constrain_omega;	/* 0 for don't care, 180 for -180:180, 360 (def) for 0-360 */
int	constrain_phi;		/* 0 for don't care, 180 for -180:180, 360 (def) for 0-360 */
int	constrain_kappa;	/* 0 for don't care, 180 for -180:180, 360 (def) for 0-360 */

FILE	*fpnull;	/* /dev/null */
int	dc_in_progress;	/* Set when data collection is in progress */

char *trntable = LOGICAL_NAME_TABLE;	/* Essentially for VMS */

mdc_command	mdc_queue[MAXQUEUE];	/* queue of scanner commands */
mdc_command	*mdc_head;		/* points to first queue member */
mdc_command	mdc_current;		/* current command being executed */

/*
 *	Scanner status information.
 */

float	stat_dist;		/* current distance */
float	stat_phi;		/* current phi */
float	stat_lift;		/* current lift */
float	stat_omega;		/* current omega */
float	stat_kappa;		/* current kappa */
float	stat_start_phi;		/* starting phi value for this scan */
float	stat_start_omega;	/* starting omega */
float	stat_start_kappa;	/* strting kappa */
float	stat_osc_width;		/* oscillation range */
float	stat_time;		/* exposure time */
float	stat_intensity;		/* intensity reading from mar */
float	stat_wavelength;	/* wavelength */
float	stat_multiplier;	/* scanner specific multiplier factor */
int	stat_axis;		/* 1 for phi, 0 for omega */
int	stat_mode;		/* 0 for time mode, 1 for dose mode */
int	stat_max_count;		/* maximum counts in an exposure */
int	stat_n_images;		/* number of images in this collection */
int	stat_n_passes;		/* number of passes per image */
int	stat_n_mdc_updates;	/* number of times mdc has update stat file */
int	stat_n_ccd_updates;	/* number of times ccd_dc has updated its OWN status file */
int	stat_image_number;	/* used to keep track of the current image number */
int	stat_adc;		/* adc value (slow=0, fast = 1) */
int	stat_bin = 0;		/* 1 for 1x1, 2 for 2x2 binning */
char	stat_dir[80];		/* directory for collecting data */
char	stat_prefix[890];	/* code name + encoded run number */
char	stat_fname[80];		/* current file name */
char	stat_scanner_op[80];	/* scanner operation in progress */
char	stat_scanner_msg[80];	/* any useful scanner message */
char	stat_scanner_control[80];  /* control state */
char	stat_scanner_shutter[80];  /* state of the shutter */
char	stat_mode_msg[80];	/* collection mode: dose or time */
float	stat_xcen;		/* x beam center in mm for oblique correction */
float	stat_ycen;		/* y beam center in mm for oblique correction */
float	stat_2theta;		/* two theta of the detector */
int	stat_compress;		/* 0 for none, 1 for .Z 2 for .pck */
int	stat_anom;		/* 1 for anomalous, else 0 */
int	stat_wedge;		/* number of frames per anom mini-run */
float	stat_dzratio = 1.0;	/* ratio of 2nd/1st image expos time/dezingering */
float 	stat_step_size;         /* step size for step/dose mode */
float 	stat_dose_step;         /* dose per step for step/dose mode */
float	stat_attenuator;	/* attenuator amount */
float	stat_hslit;		/* horiz slit amount */
float	stat_vslit;		/* vertical slit amount */
float	min_velocity;		/* min data collection velocity */
float	max_velocity;		/* max data collection velocity */
int	allow_stills;

/*
 *	Simulation timing and control.
 */

int	use_pc_shutter;
int	use_j5_trigger;
int	use_timecheck;
int	sim_cmd_ticks;		/* when goes to zero, the command is done */

int	tick;		/* used for clock counting */
int	units;		/* used for calculating percentage completion */
int	decrement;	/* used for pseudo-timing of things */
int	dcop;		/* software state used for collect & scan */
int	retrycnt;	/* retry count for hardware faults */
int	msign;		/* used in calculations */
float	start_val;	/* used in calculations */
float	delta;		/* ditto */
int	totimg;		/* used for deciding when data collection done */
int	totpass;	/* same, only for multiple passes in a single osc */
int	dc_abort;	/* signals a data collection abort */
int	dc_stop;	/* signals a stop after current exposure */
int	command_rejected;	/* 1 if the command was rejected by ccd_hw_start */
int	dc_abort_ctr;	/* used during the abort procedure */
int	dc_error_rec;	/* used during data collection error recovery */
char	mdc_alert[80];	/* used to signal a hardware alert */

char	*mdc_comlit[] = {
			"eoc",
			"exit",
			"config",
			"startup",
			"erase",
			"initialize",
			"stop",
			"abort",
			"distance_move",
			"phi_move",
			"phi_move_rel",
			"distance_set",
			"phi_set",
			"lift_move",
			"lift_set",
			"wavelength_move",
			"wavelength_set",
			"shutter",
			"scan",
			"omega_move",
			"omega_set",
			"kappa_move",
			"kappa_set",
			"collect",
			"snap",
			"gon_manual",
			"home",
			"attenuate",
			"autoalign",
			"xl_hs_move",
			"xl_vs_move",
			"xl_up_hhs_move",
			"xl_up_vhs_move",
			"xl_dn_hhs_move",
			"xl_dn_vhs_move",
			"queue_list",
			"queue_flush",
			"distance",
			"phi_start",
			"osc_width",
			"n_images",
			"de_zinger",
			"time",
			"image_number",
			"directory",
			"image_prefix",
			"image_suffix",
			"mode",
			"wavelength",
			"remark",
			"lift",
			"adc",
			"bin",
			"center",
			"kappa_start",
			"omega_start",
			"axis",
			"newdark",
			"anomalous",
			"wedge",
			"compress",
			"blcmd",
			"dzratio",
			"darkinterval",
			"repeat_dark",
			"dk_before_run",
			"outfile_type",
			"no_transform",
			"output_raw",
			"step_size",
			"dose_per_step",
			"mad",
			"mad_wave",
			"restart_run",
			"restart_image",
			"atten_run",
			"autoal_run",
			"hslit_run",
			"vslit_run",
			NULL
			};

/*
 *	Variables which apply to both simulated and actual
 *	hardware operation.
 */

int	mdc_cmd_active;			/* 1 if we have an active command */
int	mdc_simulation;			/* 1 if simulation, 0 if actual hardware */
int	raw_ccd_image = 0;		/* 1 if doing calibration, else 0 */
int	repeat_dark_current = 0;	/* 1 if doing repeated dark currents, else 0 */
int	dark_current_interval = 0;	/* interval in sec for recollect dark currents */
int	dark_current_time = 0;		/* time function value for last dark current */
int	pixel_size;
int	dk_before_run;			/* 1 for dark current repeat before a run */
int	strip_ave;			/* 1 to use strip averages for dark pedistal renorm in xform */

int	n_ctrl;				/* number of controllers */
int	n_strip_ave;			/* number of returned strip_ave values */
float	strip_ave_vals[4];		/* their values */

int	(*mdc_cmd_start)();		/* function which starts commands */
int	(*mdc_cmd_progress)();		/* function checking progress */

int	fdmar;			/* file descriptor for mar */
struct	esd_status_block rs;	/* raw sataus block */
float	dt_stat;		/* number of seconds per status update */
float	kappa_const;		/* kappa goniostat constant, usually about 50 degrees */

/*
 *	Hardware scanner status.
 */

int	active[MAX_CMD];
int	started[MAX_CMD];
int	queued[MAX_CMD];
int	all_done[MAX_CMD];
int	aborted[MAX_CMD];
int	c_error[MAX_CMD];
short	last_valid_data;
short	last_command;
int	mains_active;
int	hv_on;
int	open_xray_shutter;
int	xray_shutter_open;
int	lock_ip;
int	ip_locked;
int	open_laser_shutter;
int	laser_shutter_open;
int	erase_lamp_on_out;
int	erase_lamp_on_ok;
int	ion_chamber;
int	ion_chamber_select_enab;
int	distance_steps;
int	phi_steps;
int	lift_steps;
int	omega_steps;
int	waiting_for_command[MAX_CMD];
int	readpointer;
int	writepointer;

/*
 *	Some timing variables useful to have.
 */

float	erase_time;	/* number of seconds it takes to erase plate */
float	scan_time;	/* number of seconds it takes to scan plate */
float	dc_erase_time;	/* slightly longer than normal erase */
int	phi_steps_deg;	/* number of steps per degree in phi */
int	dist_steps_mm;	/* number of steps per mm for the distance */
int	lift_steps_mm;	/* number of steps per mm for the lift mechanism */
int	phi_top_speed;	/* Top speed in steps/sec for phi motor */
int	phi_speed_used;	/* The actual speed for a particular operation */
int	dist_top_speed;	/* Top speed for distance in steps/mm */
int	dist_max_ref_point;	/* Number of steps for ending limit switch */
int	dist_min_ref_point;	/* Number of steps for dist at near limit switch */
int	lift_top_speed; /* Top speed for lift mechanism in steps/sec */
int	lift_max_point;		/* Number of steps for lift at the UPPER limit switch */
int	lift_min_point;		/* Number of steps for lift at the LOWER limit switch */
int	is_lift;		/* 1 if there is a lift mechanism on this machine */
int	units_per_second;	/* number of units per second/data coll */
int	units_per_dose;		/* same thing, only for dose */
int	magic_flags;		/* may need for a special purpose */
int	is_distance;		/* 1 if there is operable distance */
int	is_phi;			/* 1 if there is operable phi */
int	radius_mode;		/* 0 (default) 180 or 300 */
float	read_fast;		/* read time/FAST ADC */
float	read_slow;		/* read time/SLOW ADC */
float	read_overhead;		/* general overhead per picture */
float	bin_factor;		/* factor to apply for time if bin 2x2 */
int	is_kappa;		/* 1 if we have a kappa axis */
int	is_omega;		/* 1 if we have an omega axis */
int	def_dezinger;		/* 1 if default is to dezinger images */
int	is_2theta;		/* 1 if we have a two theta.  This is exclusive of is_lift */
int     is_wavelength;          /* 1 if we have wavelength control */
float   approach_start;         /* non-zero to move this far from start position, then to start position */
int     chip_size_x;            /* size of the basic chip element in the detector, in pixels */
int     chip_size_y;            /* size of the basic chip element in the detector, in pixels */
float   bchk_time;                      /* beamstop check time */
float   bchk_deltaphi;                  /* beamstop check deltaphi */
int     perform_beamstop_check;         /* 1 to perform beamstop check, else 0 */
int     checking_direct_beam;           /* 1 while this is in progress */
char    bchk_semiphore_file[256];       /* beamstop check semiphore file name */
int	madrun_naming;
int	retryshort;			/* 1 to retry short exposures (mar base) */
int	ccd_modular;			/* 1 if using modular (multiple) framegrabbers, else 0 */
int	pf_mod;			/* 1 if using modular (multiple) framegrabbers, else 0 */
int     pitch_tune_delta;
time_t  pitch_tune_last = 0;
int	bm8_mod;

int	nc_pointer;	/* neighbor code start pointer */
int	nc_index;	/* neighbor code start index */
int	nc_x;		/* neighbor code start x value */
int	nc_y;		/* neighbor code start y value */
int	nc_rec;		/* neighbor code start record value */
int	nc_poff;	/* neighbor code start pixel offset value */

int	scsi_id;	/* SCSI unit number of the MAR controller */
int	scsi_controller;	/* SCSI controller number (VMS: a = 0, b = 1, etc.) */
int	spiral_check;	/* 1 to check spiral records */

float	beam_xcen;		/* x beam center in mm for oblique correction */
float	beam_ycen;		/* y beam center in mm for oblique correction */
int	outfile_type;		/* 0 or ushort, 1 for int */

/*
 *	These are lower case assigned versions of
 *	the default #defines in the mdcdefs.h file.
 *
 *	They are given the initial values by the .h file
 *	but may be overridden either by the program
 * 	or by the user's configuration file.
 */


float	specific_erase_time;	/* how many sec. a simple erase command takes */
float	specific_scan_time;	/* how many seconds the scan part of the GOIPS takes */
float	specific_dc_erase_time;	/* how many seconds the erase and lock parts of GOIPS takes */
int	specific_total_valid_blocks;	/* how many blocks makes a spiral scan */
int	specific_total_pixels_x;	/* number of pixels in x */
int	specific_total_pixels_y;	/* number of pixels in y */
float	specific_multiplier;	/* This is scanner specific and should ALWAYS user specified */
int	specific_phi_steps_deg;	/* number of steps per degree for phi motor */
int	specific_dist_steps_mm;	/* number of steps per mm for the distance */
int	specific_lift_steps_mm;	/* number of steps per mm for tower lift mechanism */
int	specific_lift_top_speed; /* top speed for the lift motor (masquerading as "omega") */
int	specific_lift_max_point; /* value of lift in STEPS at the upper limit */
int	specific_lift_min_point; /* value of lift in STEPS at the lower limit */
int	specific_is_lift;	/* is there a lift mechanism on this machine? */
int	specific_phi_top_speed;	/* top speed of phi motor in steps per second */
int	specific_dist_top_speed; /* top speed of distance motor in steps per second */
int	specific_dist_max_point; /* value of distance in STEPS at the FAR distance limit */
int	specific_dist_min_point; /* value of distance in STEPS at the NEAR distance limit */
int	specific_units_per_sec;	/* units for timing exposures */
int	specific_units_per_dose; /* units for measuring exposures by dose */
float	specific_wavelength; 	/* wavelength default */
int	specific_is_distance;	/* is there a distance on this machine? */
int	specific_is_phi;	/* is there a phi motor on this machine? */
int	specific_flags;		/* sometime we may need override values */
int	specific_nc_pointer;	/* neighbor code start pointer */
int	specific_nc_index;	/* neighbor code start index */
int	specific_nc_x;		/* neighbor code start x value */
int	specific_nc_y;		/* neighbor code start y value */
int	specific_nc_rec;	/* neighbor code start record value */
int	specific_nc_poff;	/* neighbor code start pixel offset value */
int	specific_scsi_id;	/* SCSI unit number of the controller */
int	specific_scsi_controller;	/* controller number */
int	specific_spiral_check;		/* 1 to check for bad spiral records */
float	specific_read_fast;		/* read time/FAST ADC */
float	specific_read_slow;		/* read time/SLOW ADC */
float	specific_read_overhead;		/* general overhead per picture */
float	specific_bin_factor;		/* factor to apply for time if bin 2x2 */
int	specific_is_kappa;		/* 1 if we have a kappa axis */
int	specific_is_omega;		/* 1 if we have an omega axis */
int	specific_def_dezinger;		/* 1 if default is to dezinger images */
int	specific_is_2theta;		/* 1 if we have 2theta */
int     specific_is_wavelength;         /* 1 if we have 2theta */
float   specific_approach_start;        /* non-zero to move this far from start position, then to start position */
int     specific_chip_size_x;           /* size of the basic chip element in the detector, in pixels */
int     specific_chip_size_y;           /* size of the basic chip element in the detector, in pixels */
int	specific_pcshutter;		/* 1 if default is to dezinger images */
int	specific_dark_interval;		/* time in sec in between dark current recollects */
float	specific_pixel_size;		/* pixel size */
int	specific_compress;		/* 0 for none, 1 for .Z 2 for .pck */
int	specific_dk_before_run;		/* 1 for dark current repeat before a run */
int	specific_repeat_dark;		/* 1 for repeat dark current */
int	specific_outfile_type;		/* 0 or ushort, 1 for int */
int	specific_detector_sn;		/* detector serial number, if specified */
int	specific_no_transform;		/* 1 for no on-line transform */
int	specific_output_raws;		/* 1 for output raws */
int	specific_j5_trigger;		/* 1 to use j5 trigger for ext_sync */
int	specific_timecheck;		/* 1 to use j5 trigger for ext_sync */
int	specific_constrain_omega;	/* 0 for don't care, 180 for -180:180, 360 (def) for 0-360 */
int	specific_constrain_phi;		/* 0 for don't care, 180 for -180:180, 360 (def) for 0-360 */
int	specific_constrain_kappa;	/* 0 for don't care, 180 for -180:180, 360 (def) for 0-360 */
int	specific_strip_ave;		/* 1 to use strip averages for dk pedistal renorm */
float   specific_bchk_time;             /* time for beamstop check */
float   specific_bchk_deltaphi;         /* delta phi for beamstop check */
float   specific_kappa_const;           /* kappa constant */
int     specific_madrun_naming;         /* 1 for Henry's convention, 0 for cn's */
int	specific_retryshort;		/* 1 to retry short exposures (mar bases) */
int	specific_ccd_modular;		/* 1 if we are using modular (multiple) framegrabbers */
int	specific_pf_mod;		/* 1 if we are running under PF mods */
float	specific_min_velocity;
float	specific_max_velocity;
int	specific_allow_stills;
int	specific_pitch_tune_delta;
int	specific_bm8_mod;
]0;capel@8bmserver1:/usr/local/ccd_dist/src_std/ccd_dc_api_mad_x8c[root@8bmserver1 ccd_dc_api_mad_x8c]# !ls
ls -lrt *.[ch]
[00m-rw-r--r--    1 1115     103            84 Apr 26  1999 [00mbzero.c[00m
-rw-r--r--    1 1115     103         10815 Apr 26  1999 [00mccd_dc_hwsim.c[00m
-rw-r--r--    1 1115     103          3274 Apr 26  1999 [00mccd_dc_sio.c[00m
-rw-r--r--    1 1115     103         16876 Apr 26  1999 [00mccd_dc_input_orig.c[00m
-rw-r--r--    1 1115     103           784 Apr 26  1999 [00mutil_misc.c[00m
-rw-r--r--    1 1115     103          8331 Apr 26  1999 [00mtest_seq_first.c[00m
-rw-r--r--    1 1115     103          9949 Apr 26  1999 [00mtest_seq.c[00m
-rw-r--r--    1 1115     103           629 Apr 26  1999 [00mparse_file_name.c[00m
-rw-r--r--    1 1115     103          2003 Apr 26  1999 [00mnet_client.c[00m
-rw-r--r--    1 1115     103          2082 Apr 26  1999 [00mvms_select.h[00m
-rw-r--r--    1 1115     103          3451 Jul  5  1999 [00mccd_dc_heartbeat.c[00m
-rw-r--r--    1 1115     103          1559 Jun 19  2001 [00mccd_dc_args.c[00m
-rw-r--r--    1 1115     103          4587 Jun 19  2001 [00mccd_dc_det.c[00m
-rw-r--r--    1 1115     103          1056 Jun 19  2001 [00mccd_dc_main.c[00m
-rw-r--r--    1 1115     103         19780 Apr 18 18:21 [00mccd_server.c[00m
-rw-r--r--    1 1115     103          4604 Apr 18 18:40 [00mccd_dc_bl.c[00m
-rw-r--r--    1 1115     103          1315 Apr 18 19:22 [00mget_attenuator.c[00m
-rw-r--r--    1 1115     103         22959 Apr 18 20:43 [00mccd_dc_input.c[00m
-rw-r--r--    1 1115     103          8100 Apr 24 18:51 [00mccd_dc_seq.c[00m
-rw-r--r--    1 1115     103          9363 Apr 24 18:52 [00mccd_dc_seq_nowork.c[00m
-rw-r--r--    1 1115     103         23181 May 20 23:55 [00mccd_dc_strstat.c[00m
-rw-r--r--    1 1115     103          9357 Aug 13 09:08 [00mccd_dc_defs.h[00m
-rw-r--r--    1 1115     103         17755 Aug 13 09:08 [00mccd_dc_glob.c[00m
-rw-r--r--    1 1115     103          9785 Aug 13 09:09 [00mccd_dc_ext.h[00m
-rw-r--r--    1 1115     103         42943 Aug 13 09:12 [00mccd_dc_misc.c[00m
-rw-r--r--    1 1115     103         51448 Aug 14 13:11 [00mccd_dc_hw.c[00m
cat ccd_dc_misc.c
#include	"ccd_dc_ext.h"

/*
 *-------------------------------------------
 *
 *	Miscellaneous routines in this module.
 *
 *-------------------------------------------
 */

/*
 *	ccd_initialize
 *
 *	ccd_initialize translates logical names
 *	into actual file names (environment for
 *	UNIX, logical name table for VMS) and
 *	opens them in their appropriate states.
 *
 *	Next, ccd_initialize assigns default values
 *	of scanner times or attributes to the
 *	variables labled "specific...".
 *
 *	Then ccd_initialize reads the user's
 *	configuration file and alters the
 *	"specific..." variables based on that
 *	file's contents.
 *
 *	Finally, the "specific..." variables are
 *	used to assign values to variables which
 *	the scanner actually uses.
 *
 *	So the order of precedence:
 *
 *	  1)	mardefs.h	(lowest)
 *	  2)	user config	(next)
 *	  3)	values from profile (highest)
 */

ccd_initialize()
  {
	long	clock;
	char	*cptr;

	fpout = NULL;
	fplog = NULL;
	fpconfig = NULL;
	fdcom = fdout = fdstat = fdxfcm = -1;
	fddetcmd = fddetstatus = fdblcmd = fdblstatus = -1;
	if(NULL == (fpnull = fopen("/dev/null","r+")))
	  {
	    fprintf(stderr,"ccd_dc: ccd_initialize: cannot open /dev/null\n");
	    exit(0);
	  }

	ccd_init_files();
/*
 *	Log the time to the errorlog for startup
 */
	time(&clock);
	cptr = (char *) ctime(&clock);
	fprintf(fplog,"=============================\n");
	fprintf(fplog,"ccd_dc: started %s\n",cptr);
	fprintf(fplog,"=============================\n");

	ccd_init_defaults();
	ccd_init_config(fpnull);
	ccd_init_vars();
	strcpy(mdc_alert,"");
	dc_in_progress = 0;
	perform_beamstop_check = 0;
	checking_direct_beam = 0;
	if(NULL != (cptr = (char *) getenv("CCD_BCHK_SEMIPHORE_FILE")))
	  {
		perform_beamstop_check = 1;
		strcpy(bchk_semiphore_file,cptr);
	  }  
  }

/*
 *	This routine assigns the first round of
 *	values to the "specific..." variables.
 *
 *	The defaults come from this programs
 * 	ccd_dc_defs.h file.  Variables which change
 *	from scanner to scanner or from some
 *	other reason will be altered in the next
 *	phase of initialization.
 */

ccd_init_defaults()
  {
	specific_erase_time = SPECIFIC_ERASE_TIME;
	specific_scan_time = SPECIFIC_SCAN_TIME;
	specific_dc_erase_time = SPECIFIC_DC_ERASE_TIME;	
	specific_total_valid_blocks = SPECIFIC_TOTAL_VALID_BLOCKS;
	specific_total_pixels_x = SPECIFIC_TOTAL_PIXELS_X;
	specific_total_pixels_y = SPECIFIC_TOTAL_PIXELS_Y;
	specific_multiplier = SPECIFIC_MULTIPLIER;
	specific_phi_steps_deg = SPECIFIC_PHI_STEPS_DEG;
	specific_dist_steps_mm = SPECIFIC_DIST_STEPS_MM;
	specific_lift_steps_mm = SPECIFIC_LIFT_STEPS_MM;
	specific_phi_top_speed = SPECIFIC_PHI_TOP_SPEED;
	specific_dist_top_speed = SPECIFIC_DIST_TOP_SPEED;
	specific_lift_top_speed = SPECIFIC_LIFT_TOP_SPEED;
	specific_dist_max_point = SPECIFIC_DIST_MAX_POINT;
	specific_dist_min_point = SPECIFIC_DIST_MIN_POINT;
	specific_lift_max_point = SPECIFIC_LIFT_MAX_POINT;
	specific_lift_min_point = SPECIFIC_LIFT_MIN_POINT;
	specific_units_per_sec = SPECIFIC_UNITS_PER_SEC;
	specific_units_per_dose = SPECIFIC_UNITS_PER_DOSE;
	specific_wavelength = SPECIFIC_WAVELENGTH;
	specific_is_distance = SPECIFIC_IS_DIST;
	specific_is_phi = SPECIFIC_IS_PHI;
	specific_is_lift = SPECIFIC_IS_LIFT;
	specific_flags = SPECIFIC_FLAGS;
	specific_nc_pointer = SPECIFIC_NC_POINTER;
	specific_nc_index = SPECIFIC_NC_INDEX;
	specific_nc_x = SPECIFIC_NC_X;	
	specific_nc_y = SPECIFIC_NC_Y;
	specific_nc_rec = SPECIFIC_NC_REC;
	specific_nc_poff = SPECIFIC_NC_POFF;
	specific_scsi_id = SPECIFIC_SCSI_ID;
	specific_scsi_controller = SPECIFIC_SCSI_CONTROLLER;
	specific_spiral_check = SPECIFIC_SPIRAL_CHECK;
	specific_read_fast = SPECIFIC_READ_FAST;
	specific_read_slow = SPECIFIC_READ_SLOW;
	specific_read_overhead = SPECIFIC_READ_OVERHEAD;
	specific_bin_factor = SPECIFIC_BIN_FACTOR;
	specific_is_kappa = SPECIFIC_IS_KAPPA;
	specific_is_omega = SPECIFIC_IS_OMEGA;
	specific_def_dezinger = SPECIFIC_DEF_DEZINGER;
	specific_is_2theta = SPECIFIC_IS_2THETA;
	specific_pcshutter = SPECIFIC_PCSHUTTER;
	specific_dark_interval = SPECIFIC_DARK_INTERVAL;
	specific_pixel_size = SPECIFIC_PIXEL_SIZE;
	specific_dk_before_run = SPECIFIC_DK_BEFORE_RUN;
	specific_repeat_dark = repeat_dark_current; 
	specific_outfile_type = SPECIFIC_OUTFILE_TYPE;
	specific_detector_sn = SPECIFIC_DETECTOR_SN;
	specific_no_transform = SPECIFIC_NO_TRANSFORM;
	specific_output_raws = SPECIFIC_OUTPUT_RAWS;
	specific_j5_trigger = SPECIFIC_J5_TRIGGER;
	specific_timecheck = SPECIFIC_TIMECHECK;
	specific_constrain_omega = SPECIFIC_CONSTRAIN_OMEGA;
	specific_constrain_phi   = SPECIFIC_CONSTRAIN_PHI;
	specific_constrain_kappa = SPECIFIC_CONSTRAIN_KAPPA;
	specific_strip_ave = SPECIFIC_STRIP_AVE;
	specific_bchk_time = SPECIFIC_BCHK_TIME;
	specific_bchk_deltaphi = SPECIFIC_BCHK_DELTAPHI;
	specific_is_wavelength = SPECIFIC_IS_WAVELENGTH;
	specific_approach_start = SPECIFIC_APPROACH_START;
	specific_chip_size_x = SPECIFIC_CHIP_SIZE_X;
	specific_chip_size_y = SPECIFIC_CHIP_SIZE_Y;
	specific_kappa_const = SPECIFIC_KAPPA_CONST;
	specific_madrun_naming = SPECIFIC_MADRUN_NAMING;
	specific_retryshort = SPECIFIC_RETRYSHORT;
	specific_ccd_modular = SPECIFIC_CCD_MODULAR;
        specific_pf_mod = SPECIFIC_PF_MOD;
	specific_min_velocity = SPECIFIC_MIN_VELOCITY;
	specific_max_velocity = SPECIFIC_MAX_VELOCITY;
	specific_allow_stills = SPECIFIC_ALLOW_STILLS;
	specific_pitch_tune_delta = SPECIFIC_PITCH_TUNE_DELTA;
	specific_bm8_mod = SPECIFIC_PITCH_TUNE_DELTA;
  }

/*
 *	This routine initializes scanner global
 *	variables now that the program has decided
 *	what the specific parameters actually are.
 */

ccd_init_vars()
  {
	int	mdc_sim_progress();
	int	ccd_hw_progress();
	void	mdc_sim_start();
	void	ccd_hw_start();

	if(mdc_simulation)
	  {
		dt_stat = 1.0;
		erase_time = specific_erase_time;
		scan_time = specific_scan_time;
		dc_erase_time = specific_dc_erase_time;
		phi_steps_deg = specific_phi_steps_deg;
		dist_steps_mm = specific_dist_steps_mm;
		lift_steps_mm = specific_lift_steps_mm;
		phi_top_speed = specific_phi_top_speed;
		dist_top_speed = specific_dist_top_speed;
		lift_top_speed = specific_lift_top_speed;
		dist_max_ref_point = specific_dist_max_point;
		dist_min_ref_point = specific_dist_min_point;
		lift_max_point = specific_lift_max_point;
		lift_min_point = specific_lift_min_point;
		units_per_second = specific_units_per_sec;
		units_per_dose = specific_units_per_dose;
		stat_wavelength = specific_wavelength;
		stat_multiplier = specific_multiplier;
		magic_flags = specific_flags;
		is_distance = specific_is_distance;
		is_phi = specific_is_phi;
		is_lift = specific_is_lift;
		is_2theta = specific_is_2theta;
		dark_current_interval = specific_dark_interval;
		pixel_size = specific_pixel_size;
		dk_before_run = specific_dk_before_run;
		repeat_dark_current = specific_repeat_dark;
		strip_ave = specific_strip_ave;
		bchk_time = specific_bchk_time;
		bchk_deltaphi = specific_bchk_deltaphi;
		is_wavelength = specific_is_wavelength;
		approach_start = specific_approach_start;
		chip_size_x = specific_chip_size_x;
		chip_size_y = specific_chip_size_y;
		kappa_const = specific_kappa_const;
		madrun_naming = specific_madrun_naming;
		retryshort = specific_retryshort;
		ccd_modular = specific_ccd_modular;
		pf_mod = specific_pf_mod;
		stat_attenuator = -1;	/* always begins as unknown */
		stat_hslit = -1;
		stat_vslit = -1;
		min_velocity = specific_min_velocity;
		max_velocity = specific_max_velocity;
		allow_stills = specific_allow_stills;
		pitch_tune_delta = specific_pitch_tune_delta;
		bm8_mod = specific_bm8_mod;

		nc_pointer = specific_nc_pointer;
		nc_index = specific_nc_index;
		nc_x = specific_nc_x;	
		nc_y = specific_nc_y;
		nc_rec = specific_nc_rec;
		nc_poff = specific_nc_poff;

		stat_mode = 0;
		scsi_id = specific_scsi_id;
		scsi_controller = specific_scsi_controller;
		spiral_check = specific_spiral_check;

		beam_xcen = 45.;
		beam_ycen = 45.;

		outfile_type = specific_outfile_type;
		detector_sn = specific_detector_sn;
		raw_ccd_image = specific_no_transform;
		output_raws = specific_output_raws;
		constrain_omega = specific_constrain_omega;
		constrain_phi   = specific_constrain_phi;
		constrain_kappa = specific_constrain_kappa;

		mdc_cmd_progress = mdc_sim_progress;
		mdc_cmd_start = mdc_sim_start;

		mdc_sim_initial_status();
	  }
	 else
	  {
		dt_stat = 1.0;
		erase_time = specific_erase_time;
		dc_erase_time = specific_dc_erase_time;
		scan_time = specific_scan_time;
		phi_steps_deg = specific_phi_steps_deg;
		dist_steps_mm = specific_dist_steps_mm;
		lift_steps_mm = specific_lift_steps_mm;
		phi_top_speed = specific_phi_top_speed;
		dist_top_speed = specific_dist_top_speed;
		lift_top_speed = specific_lift_top_speed;
		dist_max_ref_point = specific_dist_max_point;
		dist_min_ref_point = specific_dist_min_point;
		lift_max_point = specific_lift_max_point;
		lift_min_point = specific_lift_min_point;
		units_per_second = specific_units_per_sec;
		units_per_dose = specific_units_per_dose;
		stat_wavelength = specific_wavelength;
		stat_multiplier = specific_multiplier;
		magic_flags = specific_flags;
		is_distance = specific_is_distance;
		is_phi = specific_is_phi;
		is_lift = specific_is_lift;
		read_fast = specific_read_fast;
		read_slow = specific_read_slow;
		read_overhead = specific_read_overhead;
		bin_factor = specific_bin_factor;
		is_kappa = specific_is_kappa;
		is_omega = specific_is_omega;
		def_dezinger = specific_def_dezinger;
		is_2theta = specific_is_2theta;
		use_pc_shutter = specific_pcshutter;
		use_j5_trigger = specific_j5_trigger;
		use_timecheck = specific_timecheck;
		dark_current_interval = specific_dark_interval;
		pixel_size = specific_pixel_size;
		dk_before_run = specific_dk_before_run;
		repeat_dark_current = specific_repeat_dark;
		strip_ave = specific_strip_ave;
		bchk_time = specific_bchk_time;
		bchk_deltaphi = specific_bchk_deltaphi;
		is_wavelength = specific_is_wavelength;
		approach_start = specific_approach_start;
		chip_size_x = specific_chip_size_x;
		chip_size_y = specific_chip_size_y;
		kappa_const = specific_kappa_const;
		madrun_naming = specific_madrun_naming;
		retryshort = specific_retryshort;
		ccd_modular = specific_ccd_modular;
		pf_mod = specific_pf_mod;
		stat_attenuator = -1;		/* always begins as unknown */
		stat_hslit = -1;
		stat_vslit = -1;
		min_velocity = specific_min_velocity;
		max_velocity = specific_max_velocity;
		allow_stills = specific_allow_stills;
		pitch_tune_delta = specific_pitch_tune_delta;
		bm8_mod = specific_bm8_mod;

		nc_pointer = specific_nc_pointer;
		nc_index = specific_nc_index;
		nc_x = specific_nc_x;	
		nc_y = specific_nc_y;
		nc_rec = specific_nc_rec;
		nc_poff = specific_nc_poff;

		stat_mode = 0;
		scsi_id = specific_scsi_id;
		scsi_controller = specific_scsi_controller;
		spiral_check = specific_spiral_check;

		beam_xcen = 45.;
		beam_ycen = 45.;

		outfile_type = specific_outfile_type;
		detector_sn = specific_detector_sn;
		raw_ccd_image = specific_no_transform;
		output_raws = specific_output_raws;
		constrain_omega = specific_constrain_omega;
		constrain_phi   = specific_constrain_phi;
		constrain_kappa = specific_constrain_kappa;

		mdc_cmd_progress = ccd_hw_progress;
		mdc_cmd_start = ccd_hw_start;

		fdmar = -1;	/* this module does NOT perform hardware operatons */
	  }
  }

/*
 *	This routine handles the name translation
 *	and file opens, leaving all in their proper
 *	state.
 *
 *	Network version:
 *	  Open up the log file.
 *	  Open up the config file.
 *	  Open up the profile file.
 */

ccd_init_files()
  {
	int	i;
	char	temp[50];

	/*
	 *	Translate logical names.
	 */

	if(0 == trnlog(trntable,"CCDSCANDIR",scan_dir))                      
	  {
	    fprintf(stderr,
	      "Please set the logical name or environment variable CCDSCANDIR\n");
	    fprintf(stderr,
	      "Then re-execute ccd_dc.\n");
	    cleanexit(BAD_STATUS);
	  }
	i = strlen(scan_dir);
	if(i > 0)
	  {
	    if(scan_dir[i-1] != '/' && scan_dir[i-1] != '\\')
	      {
		scan_dir[i] = '/'; scan_dir[i+1] = '\0';
	      }
	  }
	if(0 == trnlog(trntable,"CCDSCANDIR_EXPORT",scan_dir_export))                      
	  {
	    fprintf(stderr,
	      "Please set the logical name or environment variable CCDSCANDIR_EXPORT\n");
	    fprintf(stderr,
	      "Then re-execute ccd_dc.\n");
	    cleanexit(BAD_STATUS);
	  }
	i = strlen(scan_dir_export);
	if(i > 0)
	  {
	    if(scan_dir_export[i-1] != '/' && scan_dir[i-1] != '\\')
	      {
		scan_dir_export[i] = '/'; scan_dir_export[i+1] = '\0';
	      }
	  }

	if(0 == trnlog(trntable,CCD_DC_LOCAL_LOG,lfname))
	  {
	    fprintf(stderr,
	      "Please set the logical name or environment variable.\n");
	    fprintf(stderr,
	      "Then re-execute ccd_dc.\n");
	    cleanexit(BAD_STATUS);
	  }
        if(0 == trnlog(trntable,CCD_DC_CONFIG,confname))
          {
            fprintf(stderr,
              "Please set the logical name or environment variable.\n");
            fprintf(stderr,
              "Then re-execute ccd_dc.\n");
            cleanexit(BAD_STATUS);
          }
        if(0 != trnlog(trntable,CCD_N_CTRL,temp))
	    sscanf(temp,"%d",&n_ctrl);
	  else
	    n_ctrl = 1;

	/*
	 *	Open up log file only.
	 */
	
	if(NULL == (fplog = fopen(lfname,OPENA_REC)))
	  {
	    fprintf(stderr,"Cannot open %s as ccd log file\n",lfname);
	    cleanexit(BAD_STATUS);
	  }

  }

/*
 *	ccd_init_config
 *
 *	This routine allows the user to override default
 *	values for the scanner specific variables from
 *	a configuration file.
 *
 *	The format of the configuration file is:
 *
 *	keyword		value
 *
 *	The user may specify as little of the formal
 *	keyword as is necessary for unambiguous
 *	determination of the keyword.
 */

/*
 *	keywords:
 */

struct config_key {
			char	*key_name;
			char	*key_abbr;
			int	key_value;
		  };

enum {
	KEY_ERASE_TIME	=      0,
	KEY_SCAN_TIME		,
	KEY_DC_ERASE_TIME	,
	KEY_TOTAL_VALID_BLOCKS	,
	KEY_TOTAL_PIXELS_X	,
	KEY_TOTAL_PIXELS_Y	,
	KEY_MULTIPLIER		,
	KEY_PHI_STEPS_DEG	,
	KEY_DIST_STEPS_MM	,
	KEY_PHI_TOP_SPEED	,
	KEY_DIST_TOP_SPEED	,
	KEY_DIST_MAX_POINT	,
	KEY_DIST_MIN_POINT	,
	KEY_UNITS_PER_SEC	,
	KEY_UNITS_PER_DOSE	,
	KEY_WAVELENGTH		,
	KEY_IS_DIST		,
	KEY_IS_PHI		,
	KEY_FLAGS		,
	KEY_NC_POINTER		,
	KEY_NC_INDEX		,
	KEY_NC_X		,
	KEY_NC_Y		,
	KEY_NC_REC		,
	KEY_NC_POFF		,
	KEY_SCSI_ID		,
	KEY_SCSI_CONTROLLER	,
	KEY_SPIRAL_CHECK	,
	KEY_LIFT_STEPS_MM       ,
	KEY_LIFT_TOP_SPEED      ,
	KEY_LIFT_MAX_POINT      ,
	KEY_LIFT_MIN_POINT      ,
	KEY_IS_LIFT             ,
	KEY_READ_FAST		,
	KEY_READ_SLOW		,
	KEY_READ_OVERHEAD	,
	KEY_BIN_FACTOR		,
	KEY_USEKAPPA		,
	KEY_USEOMEGA		,
	KEY_DEZINGER		,
	KEY_USE2THETA		,
	KEY_PCSHUTTER		,
	KEY_DARKINTERVAL	,
	KEY_PIXEL_SIZE		,
	KEY_DK_BEFORE_RUN	,
	KEY_REPEAT_DARK		,
	KEY_OUTFILE_TYPE	,
	KEY_DETECTOR_SN		,
	KEY_NO_TRANSFORM	,
	KEY_OUTPUT_RAWS		,
	KEY_J5_TRIGGER		,
	KEY_TIMECHECK		,
	KEY_CONSTRAIN_OMEGA	,
	KEY_CONSTRAIN_PHI	,
	KEY_CONSTRAIN_KAPPA	,
	KEY_STRIP_AVE		,
	KEY_BCHK_TIME		,
	KEY_BCHK_DELTAPHI	,
	KEY_USEWAVELENGTH	,
	KEY_APPROACH_START	,
	KEY_CHIP_SIZE_X		,
	KEY_CHIP_SIZE_Y		,
	KEY_KAPPA_CONST		,
	KEY_DAEMON_EXIT		,
	KEY_USEZERO_ANGLES	,
	KEY_USEGON_MANUAL	,
	KEY_MADRUN_NAMING	,
	KEY_RETRYSHORT		,
	KEY_CCD_MODULAR		,
	KEY_PF_MOD		,
	KEY_MIN_VELOCITY	,
	KEY_MAX_VELOCITY	,
	KEY_ALLOW_STILLS	,
	KEY_PITCH_TUNE_DELTA	,
	KEY_BM8_MOD
  };

struct config_key config_list[] = 
  {
		"erasetime","erasetime",KEY_ERASE_TIME, 
		"scantime","scantime",KEY_SCAN_TIME,
		"dcerasetime","dcerasetime",KEY_DC_ERASE_TIME,
		"blocks","blocks",KEY_TOTAL_VALID_BLOCKS,
		"pixelsx","pixelsx", KEY_TOTAL_PIXELS_X,
		"pixelsy","pixelsy",KEY_TOTAL_PIXELS_Y,
		"multiplier","multiplier",KEY_MULTIPLIER,
		"phisteps","phisteps",KEY_PHI_STEPS_DEG,
		"diststeps","diststeps",KEY_DIST_STEPS_MM,
		"phitop","phit",KEY_PHI_TOP_SPEED,
		"disttop","distt",KEY_DIST_TOP_SPEED,
		"distmax","distmax",KEY_DIST_MAX_POINT,
		"distmin","distmin",KEY_DIST_MIN_POINT,
		"unitsec","units",KEY_UNITS_PER_SEC,
		"unitdose","unitd",KEY_UNITS_PER_DOSE,
		"wavelength","wavelength",KEY_WAVELENGTH,
		"usedistance","usedistance",KEY_IS_DIST,
		"usephi","usephi",KEY_IS_PHI,
		"flags","flags",KEY_FLAGS,
		"nc_pointer","nc_poi",KEY_NC_POINTER,
		"nc_index","nc_i",KEY_NC_INDEX,
		"nc_x","nc_x",KEY_NC_X,
		"nc_y","nc_y",KEY_NC_Y,
		"nc_rec","nc_r",KEY_NC_REC,
		"nc_poff","nc_pof",KEY_NC_POFF,
		"scsi_id","scsi_id",KEY_SCSI_ID,
		"scsi_controller","scsi_controller",KEY_SCSI_CONTROLLER,
		"spiral_check","spiral_check",KEY_SPIRAL_CHECK,
		"liftsteps","liftsteps",KEY_LIFT_STEPS_MM,
		"lifttop","lifttop",KEY_LIFT_TOP_SPEED,
		"liftmax","liftmax",KEY_LIFT_MAX_POINT,
		"liftmin","liftmin",KEY_LIFT_MIN_POINT,
		"uselift","uselift",KEY_IS_LIFT,
		"read_fast","read_fast",KEY_READ_FAST,
		"read_slow","read_slow",KEY_READ_SLOW,
		"read_overhead","read_overhead",KEY_READ_OVERHEAD,
		"bin_factor","bin_factor",KEY_BIN_FACTOR,
		"usekappa","usekappa",KEY_USEKAPPA,
		"useomega","useomega",KEY_USEOMEGA,
		"dezinger","dezinger",KEY_DEZINGER,
		"use2theta","use2theta",KEY_USE2THETA,
		"pcshutter","pcshutter",KEY_PCSHUTTER,
		"darkinterval","darkinterval",KEY_DARKINTERVAL,
		"pixel_size","pixel_size",KEY_PIXEL_SIZE,
		"dk_before_run","dk_before_run",KEY_DK_BEFORE_RUN,
		"repeat_dark","repeat_dark",KEY_REPEAT_DARK,
		"outfile_type","outfile_type",KEY_OUTFILE_TYPE,
		"detector_sn","detector_sn",KEY_DETECTOR_SN,
		"no_transform","no_transform",KEY_NO_TRANSFORM,
		"output_raws","output_raws",KEY_OUTPUT_RAWS,
		"j5_trigger","j5_trigger",KEY_J5_TRIGGER,
		"timecheck","timecheck",KEY_TIMECHECK,
		"constrain_omega","constrain_omega",KEY_CONSTRAIN_OMEGA,
		"constrain_phi","constrain_phi",KEY_CONSTRAIN_PHI,
		"constrain_kappa","constrain_kappa",KEY_CONSTRAIN_KAPPA,
		"strip_ave","strip_ave",KEY_STRIP_AVE,
		"beamcheck_time","beamcheck_time",KEY_BCHK_TIME,
		"beamcheck_deltaphi","beamcheck_deltaphi",KEY_BCHK_DELTAPHI,
		"usewavelength","usewavelength",KEY_USEWAVELENGTH,
		"approach_start","approach_start",KEY_APPROACH_START,
		"chip_size_x","chip_size_x",KEY_CHIP_SIZE_Y,
		"chip_size_y","chip_size_y",KEY_CHIP_SIZE_X,
		"kappa_const","kappa_const",KEY_KAPPA_CONST,
		"daemon_exit","daemon_exit",KEY_DAEMON_EXIT,
		"usezero_angles","usezero_angles",KEY_USEZERO_ANGLES,
		"usegon_manual","usegon_manual",KEY_USEGON_MANUAL,
		"madrun_naming","madrun_naming",KEY_MADRUN_NAMING,
		"retryshort","retryshort",KEY_RETRYSHORT,
		"modular", "modular", KEY_CCD_MODULAR,
		"pf_mod", "pf_mod", KEY_PF_MOD,
		"min_velocity", "min_velocity", KEY_MIN_VELOCITY,
		"max_velocity", "max_velocity", KEY_MAX_VELOCITY,
		"allow_stills", "allow_stills", KEY_ALLOW_STILLS,
		"pitch_tune_delta","pitch_tune_delta", KEY_PITCH_TUNE_DELTA,
		"bm8_mod","bm8_mod", KEY_BM8_MOD,
		NULL,NULL,0,
  };

ccd_init_config(fpmsg)
FILE	*fpmsg;
  {
	char	tname[256];
	char	line[132];
	char	string1[132],string2[132];
	int	i,j;

	strcpy(tname,confname);

	if(NULL == (fpconfig = fopen(tname,"r")))
	  {
	    fprintf(stderr,"ccd_dc: config: cannot open config file %s\n",tname);
	    fprintf(fplog,"ccd_dc: config: cannot open config file %s\n",tname);
	    fflush(fplog);
	    return;
	  }

	while(NULL != fgets(line,sizeof line,fpconfig))
	  {
	    if(line[0] == '!' || line[0] == '#')
	      {
		fprintf(fpmsg,"%s",line);
		fprintf(fplog,"%s",line);
		continue;
	      }
	    i = sscanf(line,"%s%s",string1,string2);
	    if(i != 2)
	      {
		fprintf(stderr,"ccd_dc: config: not enough params (need 2):\n");
		fprintf(stderr,"%s",line);
		fprintf(stderr,"ccd_dc: config: ignoring that line.\n");
		continue;
	      }
	    j = 0;
	    for(i = 0; config_list[i].key_name != NULL; i++)
	      if(0 == strncmp(config_list[i].key_abbr,string1,strlen(config_list[i].key_abbr)))
		{
			j = 1;
			break;
		}
	    if(j == 0)
	      {
		fprintf(stderr,"ccd_dc: config: unrecognized keyword:\n");
		fprintf(stderr,"%s",line);
		fprintf(stderr,"ccd_dc: config: ignoring that line.\n");
		continue;
	      }
	    switch(config_list[i].key_value)
	      {
		case	KEY_ERASE_TIME:
			sscanf(string2,"%f",&specific_erase_time);
			fprintf(fpmsg,"ccd_dc: config: %s set to %10.2f\n",
				config_list[i].key_name,specific_erase_time);
			fprintf(fplog,"ccd_dc: config: %s set to %10.2f\n",
				config_list[i].key_name,specific_erase_time);
			break;
		case	KEY_SCAN_TIME:
			sscanf(string2,"%f",&specific_scan_time);
			fprintf(fpmsg,"ccd_dc: config: %s set to %10.2f\n",
				config_list[i].key_name,specific_scan_time);
			fprintf(fplog,"ccd_dc: config: %s set to %10.2f\n",
				config_list[i].key_name,specific_scan_time);
			break;
		case	KEY_DC_ERASE_TIME:
			sscanf(string2,"%f",&specific_dc_erase_time);
			fprintf(fpmsg,"ccd_dc: config: %s set to %10.2f\n",
				config_list[i].key_name,specific_dc_erase_time);
			fprintf(fplog,"ccd_dc: config: %s set to %10.2f\n",
				config_list[i].key_name,specific_dc_erase_time);
			break;
		case	KEY_TOTAL_VALID_BLOCKS:
			sscanf(string2,"%d",&specific_total_valid_blocks);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_total_valid_blocks);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_total_valid_blocks);
			break;
		case	KEY_TOTAL_PIXELS_X:
			sscanf(string2,"%d",&specific_total_pixels_x);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_total_pixels_x);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_total_pixels_x);
			break;
		case	KEY_TOTAL_PIXELS_Y:
			sscanf(string2,"%d",&specific_total_pixels_y);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_total_pixels_y);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_total_pixels_y);
			break;
		case	KEY_MULTIPLIER:
			sscanf(string2,"%f",&specific_multiplier);
			fprintf(fpmsg,"ccd_dc: config: %s set to %10.2f\n",
				config_list[i].key_name,specific_multiplier);
			fprintf(fplog,"ccd_dc: config: %s set to %10.2f\n",
				config_list[i].key_name,specific_multiplier);
			break;
		case	KEY_PHI_STEPS_DEG:
			sscanf(string2,"%d",&specific_phi_steps_deg);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_phi_steps_deg);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_phi_steps_deg);
			break;
		case	KEY_DIST_STEPS_MM:
			sscanf(string2,"%d",&specific_dist_steps_mm);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_dist_steps_mm);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_dist_steps_mm);
			break;
		case	KEY_PHI_TOP_SPEED:
			sscanf(string2,"%d",&specific_phi_top_speed);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_phi_top_speed);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_phi_top_speed);
			break;
		case	KEY_DIST_TOP_SPEED:
			sscanf(string2,"%d",&specific_dist_top_speed);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_dist_top_speed);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_dist_top_speed);
			break;
		case	KEY_DIST_MAX_POINT:
			sscanf(string2,"%d",&specific_dist_max_point);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_dist_max_point);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_dist_max_point);
			break;
		case	KEY_DIST_MIN_POINT:
			sscanf(string2,"%d",&specific_dist_min_point);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_dist_min_point);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_dist_min_point);
			break;
		case	KEY_UNITS_PER_SEC:
			sscanf(string2,"%d",&specific_units_per_sec);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_units_per_sec);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_units_per_sec);
			break;
		case	KEY_UNITS_PER_DOSE:
			sscanf(string2,"%d",&specific_units_per_dose);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_units_per_dose);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_units_per_dose);
			break;
		case	KEY_WAVELENGTH:
			sscanf(string2,"%f",&specific_wavelength);
			fprintf(fpmsg,"ccd_dc: config: %s set to %10.2f\n",
				config_list[i].key_name,specific_wavelength);
			fprintf(fplog,"ccd_dc: config: %s set to %10.2f\n",
				config_list[i].key_name,specific_wavelength);
			break;
		case	KEY_IS_DIST:
			sscanf(string2,"%d",&specific_is_distance);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_is_distance);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_is_distance);
			break;
		case	KEY_IS_PHI:
			sscanf(string2,"%d",&specific_is_phi);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_is_phi);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_is_phi);
			break;
		case	KEY_FLAGS:
			sscanf(string2,"%d",&specific_flags);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_flags);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_flags);
			break;
		case	KEY_NC_POINTER:
			sscanf(string2,"%d",&specific_nc_pointer);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_nc_pointer);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_nc_pointer);
			break;
		case	KEY_NC_INDEX:
			sscanf(string2,"%d",&specific_nc_index);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_nc_index);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_nc_index);
			break;
		case	KEY_NC_X:
			sscanf(string2,"%d",&specific_nc_x);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_nc_x);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_nc_x);
			break;
		case	KEY_NC_Y:
			sscanf(string2,"%d",&specific_nc_y);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_nc_y);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_nc_y);
			break;
		case	KEY_NC_REC:
			sscanf(string2,"%d",&specific_nc_rec);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_nc_rec);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_nc_rec);
			break;
		case	KEY_NC_POFF:
			sscanf(string2,"%d",&specific_nc_poff);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_nc_poff);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_nc_poff);
			break;
		case	KEY_SCSI_ID:
			sscanf(string2,"%d",&specific_scsi_id);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_scsi_id);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_scsi_id);
			break;
		case	KEY_SCSI_CONTROLLER:
			sscanf(string2,"%d",&specific_scsi_controller);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_scsi_controller);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_scsi_controller);
			break;
		case	KEY_SPIRAL_CHECK:
			sscanf(string2,"%d",&specific_spiral_check);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",config_list[i].key_name,specific_spiral_check);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",config_list[i].key_name,specific_spiral_check);
			break;
		case	KEY_LIFT_STEPS_MM:
			sscanf(string2,"%d",&specific_lift_steps_mm);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_lift_steps_mm);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_lift_steps_mm);
			break;
		case	KEY_LIFT_TOP_SPEED:
			sscanf(string2,"%d",&specific_lift_top_speed);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_lift_top_speed);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_lift_top_speed);
			break;
		case	KEY_LIFT_MAX_POINT:
			sscanf(string2,"%d",&specific_lift_max_point);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_lift_max_point);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_lift_max_point);
			break;
		case	KEY_LIFT_MIN_POINT:
			sscanf(string2,"%d",&specific_lift_min_point);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_lift_min_point);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_lift_min_point);
			break;
		case	KEY_IS_LIFT:
			sscanf(string2,"%d",&specific_is_lift);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_is_lift);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_is_lift);
			break;
		case	KEY_READ_FAST:
			sscanf(string2,"%f",&specific_read_fast);
			fprintf(fpmsg,"ccd_dc: config: %s set to %5.2f\n",
				config_list[i].key_name,specific_read_fast);
			fprintf(fplog,"ccd_dc: config: %s set to %5.2f\n",
				config_list[i].key_name,specific_read_fast);
			break;
		case	KEY_READ_SLOW:
			sscanf(string2,"%f",&specific_read_slow);
			fprintf(fpmsg,"ccd_dc: config: %s set to %5.2f\n",
				config_list[i].key_name,specific_read_slow);
			fprintf(fplog,"ccd_dc: config: %s set to %5.2f\n",
				config_list[i].key_name,specific_read_slow);
			break;
		case	KEY_READ_OVERHEAD:
			sscanf(string2,"%f",&specific_read_overhead);
			fprintf(fpmsg,"ccd_dc: config: %s set to %5.2f\n",
				config_list[i].key_name,specific_read_overhead);
			fprintf(fplog,"ccd_dc: config: %s set to %5.2f\n",
				config_list[i].key_name,specific_read_overhead);
			break;
		case	KEY_BIN_FACTOR:
			sscanf(string2,"%f",&specific_bin_factor);
			fprintf(fpmsg,"ccd_dc: config: %s set to %5.2f\n",
				config_list[i].key_name,specific_bin_factor);
			fprintf(fplog,"ccd_dc: config: %s set to %5.2f\n",
				config_list[i].key_name,specific_bin_factor);
			break;
		case	KEY_USEKAPPA:
			sscanf(string2,"%d",&specific_is_kappa);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_is_kappa);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_is_kappa);
			break;
		case	KEY_USEOMEGA:
			sscanf(string2,"%d",&specific_is_omega);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_is_omega);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_is_omega);
			break;
		case	KEY_DEZINGER:
			sscanf(string2,"%d",&specific_def_dezinger);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_def_dezinger);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_def_dezinger);
			break;
		case	KEY_USE2THETA:
			sscanf(string2,"%d",&specific_is_2theta);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_is_2theta);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_is_2theta);
			fprintf(stderr,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_is_2theta);
			break;
		case	KEY_USEWAVELENGTH:
			sscanf(string2,"%d",&specific_is_wavelength);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_is_wavelength);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_is_wavelength);
			fprintf(stderr,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_is_wavelength);
			break;
		case	KEY_APPROACH_START:
			sscanf(string2,"%f",&specific_approach_start);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_approach_start);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_approach_start);
			fprintf(stderr,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_approach_start);
			break;
                case    KEY_CHIP_SIZE_X:
                        sscanf(string2,"%d",&specific_chip_size_x);
                        fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
                                config_list[i].key_name,specific_chip_size_x);
                        fprintf(fplog,"ccd_dc: config: %s set to %d\n",
                                config_list[i].key_name,specific_chip_size_x);
                        fprintf(stderr,"ccd_dc: config: %s set to %d\n",
                                config_list[i].key_name,specific_chip_size_x);
                        break;
                case    KEY_CHIP_SIZE_Y:
                        sscanf(string2,"%d",&specific_chip_size_y);
                        fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
                                config_list[i].key_name,specific_chip_size_y);
                        fprintf(fplog,"ccd_dc: config: %s set to %d\n",
                                config_list[i].key_name,specific_chip_size_y);
                        fprintf(stderr,"ccd_dc: config: %s set to %d\n",
                                config_list[i].key_name,specific_chip_size_y);
                        break;
		case	KEY_PCSHUTTER:
			sscanf(string2,"%d",&specific_pcshutter);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_pcshutter);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_pcshutter);
			break;
		case	KEY_DARKINTERVAL:
			sscanf(string2,"%d",&specific_dark_interval);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_dark_interval);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_dark_interval);
			break;
		case	KEY_PIXEL_SIZE:
			sscanf(string2,"%f",&specific_pixel_size);
			fprintf(fpmsg,"ccd_dc: config: %s set to %f\n",
				config_list[i].key_name,specific_pixel_size);
			fprintf(fplog,"ccd_dc: config: %s set to %f\n",
				config_list[i].key_name,specific_pixel_size);
			break;
		case	KEY_BCHK_TIME:
			sscanf(string2,"%f",&specific_bchk_time);
			fprintf(fpmsg,"ccd_dc: config: %s set to %f\n",
				config_list[i].key_name,specific_bchk_time);
			fprintf(fplog,"ccd_dc: config: %s set to %f\n",
				config_list[i].key_name,specific_bchk_time);
			break;
		case	KEY_BCHK_DELTAPHI:
			sscanf(string2,"%f",&specific_bchk_deltaphi);
			fprintf(fpmsg,"ccd_dc: config: %s set to %f\n",
				config_list[i].key_name,specific_bchk_deltaphi);
			fprintf(fplog,"ccd_dc: config: %s set to %f\n",
				config_list[i].key_name,specific_bchk_deltaphi);
			break;
		case	KEY_DK_BEFORE_RUN:
			sscanf(string2,"%d",&specific_dk_before_run);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_dk_before_run);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_dk_before_run);
			break;
		case	KEY_REPEAT_DARK:
			sscanf(string2,"%d",&specific_repeat_dark);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_repeat_dark);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_repeat_dark);
			break;
		case	KEY_DETECTOR_SN:
			sscanf(string2,"%d",&specific_detector_sn);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_detector_sn);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_detector_sn);
			break;
		case	KEY_NO_TRANSFORM:
			sscanf(string2,"%d",&specific_no_transform);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_no_transform);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_no_transform);
			break;
		case	KEY_OUTPUT_RAWS:
			sscanf(string2,"%d",&specific_output_raws);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_output_raws);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_output_raws);
			break;
		case	KEY_J5_TRIGGER:
			sscanf(string2,"%d",&specific_j5_trigger);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_j5_trigger);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_j5_trigger);
			break;
		case	KEY_STRIP_AVE:
			sscanf(string2,"%d",&specific_strip_ave);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_strip_ave);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_strip_ave);
			break;
		case	KEY_TIMECHECK:
			sscanf(string2,"%d",&specific_timecheck);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_timecheck);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_timecheck);
			break;
		case	KEY_CONSTRAIN_OMEGA:
			sscanf(string2,"%d",&specific_constrain_omega);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_constrain_omega);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_constrain_omega);
			break;
		case	KEY_CONSTRAIN_PHI:
			sscanf(string2,"%d",&specific_constrain_phi);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_constrain_phi);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_constrain_phi);
			break;
		case	KEY_CONSTRAIN_KAPPA:
			sscanf(string2,"%d",&specific_constrain_kappa);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_constrain_kappa);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_constrain_kappa);
			break;

			/*
			 *	These three are for the GUI only.  No effect on ccd_dc.
			 */

		case	KEY_DAEMON_EXIT:
			break;
		case	KEY_USEZERO_ANGLES:
			break;
		case	KEY_USEGON_MANUAL:
			break;

		case	KEY_KAPPA_CONST:
			sscanf(string2,"%f",&specific_kappa_const);
			fprintf(fpmsg,"ccd_dc: config: %s set to %7.3f\n",
				config_list[i].key_name,specific_kappa_const);
			fprintf(fplog,"ccd_dc: config: %s set to %7.3f\n",
				config_list[i].key_name,specific_kappa_const);
			break;
		case	KEY_MADRUN_NAMING:
			sscanf(string2,"%f",&specific_madrun_naming);
			fprintf(fpmsg,"ccd_dc: config: %s set to %7.3f\n",
				config_list[i].key_name,specific_madrun_naming);
			fprintf(fplog,"ccd_dc: config: %s set to %7.3f\n",
				config_list[i].key_name,specific_madrun_naming);
			break;
		case	KEY_RETRYSHORT:
			sscanf(string2,"%f",&specific_retryshort);
			fprintf(fpmsg,"ccd_dc: config: %s set to %7.3f\n",
				config_list[i].key_name,specific_retryshort);
			fprintf(fplog,"ccd_dc: config: %s set to %7.3f\n",
				config_list[i].key_name,specific_retryshort);
			break;
		case	KEY_CCD_MODULAR:
			sscanf(string2,"%d",&specific_ccd_modular);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_ccd_modular);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_ccd_modular);
			fprintf(stdout,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_ccd_modular);
			break;
		case	KEY_PF_MOD:
			sscanf(string2,"%d",&specific_pf_mod);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_pf_mod);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_pf_mod);
			fprintf(stdout,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_pf_mod);
			break;
		case	KEY_ALLOW_STILLS:
			sscanf(string2,"%d",&specific_allow_stills);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_allow_stills);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_allow_stills);
			fprintf(stdout,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_allow_stills);
			break;
		case	KEY_MIN_VELOCITY:
			sscanf(string2,"%f",&specific_min_velocity);
			fprintf(fpmsg,"ccd_dc: config: %s set to %10.5f\n",
				config_list[i].key_name,specific_min_velocity);
			fprintf(fplog,"ccd_dc: config: %s set to %10.5f\n",
				config_list[i].key_name,specific_min_velocity);
			fprintf(stdout,"ccd_dc: config: %s set to %10.5f\n",
				config_list[i].key_name,specific_min_velocity);
			break;
		case	KEY_MAX_VELOCITY:
			sscanf(string2,"%f",&specific_max_velocity);
			fprintf(fpmsg,"ccd_dc: config: %s set to %10.5f\n",
				config_list[i].key_name,specific_max_velocity);
			fprintf(fplog,"ccd_dc: config: %s set to %10.5f\n",
				config_list[i].key_name,specific_max_velocity);
			fprintf(stdout,"ccd_dc: config: %s set to %10.5f\n",
				config_list[i].key_name,specific_max_velocity);
			break;
		case	KEY_PITCH_TUNE_DELTA:
			sscanf(string2,"%d",&specific_pitch_tune_delta);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_pitch_tune_delta);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_pitch_tune_delta);
			fprintf(stdout,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_pitch_tune_delta);
			break;
		case	KEY_BM8_MOD:
			sscanf(string2,"%d",&specific_bm8_mod);
			fprintf(fpmsg,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_bm8_mod);
			fprintf(fplog,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_bm8_mod);
			fprintf(stdout,"ccd_dc: config: %s set to %d\n",
				config_list[i].key_name,specific_bm8_mod);
			break;
		case	KEY_OUTFILE_TYPE:
			if(0 == strcmp(string2,"signed_long") ||
			   0 == strcmp(string2,"int"))
				outfile_type = 1;
			if(outfile_type == 0)
			  {
			    fprintf(fpmsg,"ccd_dc: config: %s set to unsigned_short\n",
				config_list[i].key_name);
			    fprintf(fplog,"ccd_dc: config: %s set to unsigned_short\n",
				config_list[i].key_name);
			  }
			 else
			  {
			    fprintf(fpmsg,"ccd_dc: config: %s set to signed_long\n",
				config_list[i].key_name);
			    fprintf(fplog,"ccd_dc: config: %s set to signed_long\n",
				config_list[i].key_name);
			  }
			break;
	      }
	  }
	fflush(fplog);
	fclose(fpconfig);
  }

static	char	timeholder[120];

char	*ztime()
  {
	long	clock;
	char	*cptr;

	time(&clock);
	cptr = (char *) ctime(&clock);
	strcpy(timeholder,cptr);
	timeholder[strlen(timeholder) - 1] = '\0';
	return(timeholder);
  }
]0;capel@8bmserver1:/usr/local/ccd_dist/src_std/ccd_dc_api_mad_x8c[root@8bmserver1 ccd_dc_api_mad_x8c]# ca[K!ls
ls -lrt *.[ch]
[00m-rw-r--r--    1 1115     103            84 Apr 26  1999 [00mbzero.c[00m
-rw-r--r--    1 1115     103         10815 Apr 26  1999 [00mccd_dc_hwsim.c[00m
-rw-r--r--    1 1115     103          3274 Apr 26  1999 [00mccd_dc_sio.c[00m
-rw-r--r--    1 1115     103         16876 Apr 26  1999 [00mccd_dc_input_orig.c[00m
-rw-r--r--    1 1115     103           784 Apr 26  1999 [00mutil_misc.c[00m
-rw-r--r--    1 1115     103          8331 Apr 26  1999 [00mtest_seq_first.c[00m
-rw-r--r--    1 1115     103          9949 Apr 26  1999 [00mtest_seq.c[00m
-rw-r--r--    1 1115     103           629 Apr 26  1999 [00mparse_file_name.c[00m
-rw-r--r--    1 1115     103          2003 Apr 26  1999 [00mnet_client.c[00m
-rw-r--r--    1 1115     103          2082 Apr 26  1999 [00mvms_select.h[00m
-rw-r--r--    1 1115     103          3451 Jul  5  1999 [00mccd_dc_heartbeat.c[00m
-rw-r--r--    1 1115     103          1559 Jun 19  2001 [00mccd_dc_args.c[00m
-rw-r--r--    1 1115     103          4587 Jun 19  2001 [00mccd_dc_det.c[00m
-rw-r--r--    1 1115     103          1056 Jun 19  2001 [00mccd_dc_main.c[00m
-rw-r--r--    1 1115     103         19780 Apr 18 18:21 [00mccd_server.c[00m
-rw-r--r--    1 1115     103          4604 Apr 18 18:40 [00mccd_dc_bl.c[00m
-rw-r--r--    1 1115     103          1315 Apr 18 19:22 [00mget_attenuator.c[00m
-rw-r--r--    1 1115     103         22959 Apr 18 20:43 [00mccd_dc_input.c[00m
-rw-r--r--    1 1115     103          8100 Apr 24 18:51 [00mccd_dc_seq.c[00m
-rw-r--r--    1 1115     103          9363 Apr 24 18:52 [00mccd_dc_seq_nowork.c[00m
-rw-r--r--    1 1115     103         23181 May 20 23:55 [00mccd_dc_strstat.c[00m
-rw-r--r--    1 1115     103          9357 Aug 13 09:08 [00mccd_dc_defs.h[00m
-rw-r--r--    1 1115     103         17755 Aug 13 09:08 [00mccd_dc_glob.c[00m
-rw-r--r--    1 1115     103          9785 Aug 13 09:09 [00mccd_dc_ext.h[00m
-rw-r--r--    1 1115     103         42943 Aug 13 09:12 [00mccd_dc_misc.c[00m
-rw-r--r--    1 1115     103         51448 Aug 14 13:11 [00mccd_dc_hw.c[00m
cat ccd_dc_hw.c
#include	"ccd_dc_ext.h"

/*
 *----------------------------------------------
 *
 *	Module to sequence the control of the CCD
 *	hardware modules.
 *
 *	Two processes are used to run hardware:
 *		ccd_det		controls the detector.
 *		ccd_bl		controls the beamline.
 *
 *	In this implimentation, it is assumed that
 *	ccd_bl controls all hardware EXCEPT the detector.
 *
 *----------------------------------------------
 */

/*
 *	Routines to accurately calculate the
 *	time commands take to execute.  This
 *	is for the completeness statistics, for
 *	the most part, and does not actually
 *	alter functionality.
 */

static	time_t	tick_clock_val;

tick_set()
  {
	time(&tick_clock_val);
  }

int	tick_diff()
  {
	time_t	current_clock_val;
	int	diff_in_secs;

	time(&current_clock_val);
	diff_in_secs = ((int) current_clock_val) - ((int) tick_clock_val);
	tick_clock_val = current_clock_val;
	return(diff_in_secs);
  }

/*
 *	Operation codes for the initialize command.
 *
 *	These are software state variables to keep
 *	track of which initialize phase the program
 *	is doing.
 */

#define	INITOP_ABORT	0
#define	INITOP_RESET	1
#define	INITOP_SHUTTER	2
#define	INITOP_LOADTAB	3
#define	INITOP_DISTANCE	4

int	init_op;

/*
 *	Operation codes for the data collection command.
 *
 *	These are purely software states so the program
 *	can keep track of what part of data collection it
 *	is doing.
 */

#define	DCOP_COLLECT	0
#define	DCOP_SCAN	1
#define	DCOP_ERASE	2
#define	DCOP_RECRESET	3
#define	DCOP_RECERASE	4
#define	DCOP_RECSHUTTER	5

int	active_trans = 0;
int	scan_readout_in_progress = 0;	/* used to make sure we don't step on scan readout in progress */
int	scan_abort_readout = 0;		/* 1 to cause scan_readout to abort and close its files */

/*
 *	These are used to check to see if distance
 *	or phi actually move, and are used in conjunction
 *	with active_trans above.
 */

double	phi_value_saved;	/* value before a move */
double	omega_value_saved;	/* value before a move */
int	dist_value_saved;	/* value before a move */
int     lift_value_saved;
int	phi_no_motion;		/* 1 if no motion was initiated */
int     dist_no_motion;         /* 1 if no motion was initiated */
int     lift_no_motion;         /* 1 if no motion was initiated */

int	shutter_retry;		/* used to keep track for shutter errors */
int	collect_counter;	/* used to make sure we check c_error for collect */
int	reset_counter;		/* used to make sure we wait long enough */
int	init_dist_ctr;		/* used to make sure we wait long enough */
int	double_exp_flag;	/* 1 to do two exposures per actual image */
int	double_exp_ctr;		/* used to toggle double exposures */
int	doing_dark_current;	/* 1 if doing dark current exposures */
int	doing_second_dk;	/* 1 if doing second dark current */
int	doing_snapshot;		/* 1 if doing a shapshot */

int	goniostat_type = 0;	/* 0 for phi only, 1 for Eulerian, 2 for Kappa */
int	wedge_count;		/* used for counting down in a wedge */
int	wedge_side;		/* 0 if doing the primary run, 1 if doing the bijvoet */
int	wedge_run;		/* which_run is being collected */
int	wedge_imno;
int	wedge_size;
float	wedge_omega;
float	wedge_phi;
float	wedge_kappa;
char	wedge_prefix[256];	/* temp holding tank for prefix */

float	current_darkcurrent_time = 0;	/* keeps track of the length of the current dark current image */

static	int	gl_blret;
static	int	exposure_short_by;	/* number of seconds, approx., by which an exposure is "short" */
static	int	short_exposure_wait;	/* 1 when we are stalling for the "rest" of a short exposure */

parse_file_name(s,t,inp)
char	*s,*t;
int	*inp;
  {
	int	i,j,k;
	
	j = strlen(s);
	for(i = j - 1; i > 0 && s[i] != '_'; i--);
	if(i == 0)
	  {
	    *inp = 0;
	    strcpy(t,s);
	    return;
	  }
	for(j = i + 1; s[j] != '\0'; j++)
	  if(s[j] < '0' || s[j] > '9')
	    {
	    	*inp = 0;
		strcpy(t,s);
		return;
	    }
	*inp = atoi(&s[i + 1]);
	for(j = 0; j < i; j++)
	  t[j] = s[j];
	t[i] = '\0';
  }

/*
 *	make_header_smv  -  make a suitable SMV header.
 */

#define	SHDSIZE		20480

char	made_header[SHDSIZE];

make_header_smv()
  {
	char	buf[32];
	int	i;
	char	*cptr;
	char	*ztime();

	clrhd(made_header);

	/*
	 *	standard items.
	 */
	
	puthd("DIM","2",made_header);

#if defined(alpha) || defined(linux)
	puthd("BYTE_ORDER","little_endian",made_header);
#else
	puthd("BYTE_ORDER","big_endian",made_header);
#endif /* alpha */

	puthd("TYPE","unsigned_short",made_header);

	if(stat_bin == 1)
	  {
            sprintf(buf,"%d",chip_size_x);
            puthd("SIZE1",buf,made_header);
            sprintf(buf,"%d",chip_size_y);
            puthd("SIZE2",buf,made_header);
	    sprintf(buf,"%6.4f",pixel_size);
	    puthd("PIXEL_SIZE",buf,made_header);
	    puthd("BIN","none",made_header);
	  }
	 else
	  {
            sprintf(buf,"%d",chip_size_x / stat_bin);
            puthd("SIZE1",buf,made_header);
            sprintf(buf,"%d",chip_size_y / stat_bin);
            puthd("SIZE2",buf,made_header);
	    sprintf(buf,"%6.4f",pixel_size * stat_bin);
	    puthd("PIXEL_SIZE",buf,made_header);
	    puthd("BIN","2x2",made_header);
	  }
	if(stat_adc == 0)
	    puthd("ADC","slow",made_header);
	  else
	    puthd("ADC","fast",made_header);
	if(0)
	{
	for(i = 0; i < n_ctrl; i++)
	  {
		sprintf(buf,"CCD_OFFSET%d",i);
		puthd(buf,"xx",made_header);
	  }
	}
	/*
	 *	adsc items.
	 */
	if(detector_sn > 0)
	  {
		sprintf(buf,"%d",detector_sn);
		puthd("DETECTOR_SN",buf,made_header);
	  }
	cptr = ztime();
	puthd("DATE",cptr,made_header);
	sprintf(buf,"%.2f",stat_time);
	puthd("TIME",buf,made_header);
	sprintf(buf,"%.3f",stat_dist);
	puthd("DISTANCE",buf,made_header);
	sprintf(buf,"%.3f",stat_osc_width);
	puthd("OSC_RANGE",buf,made_header);
	if(stat_axis == 1)
	  {
	    if(is_kappa)
	      {
		sprintf(buf,"%.3f",phi_value_saved);
		puthd("PHI",buf,made_header);
		puthd("OSC_START",buf,made_header);
		sprintf(buf,"%.3f",stat_omega);
		puthd("OMEGA",buf,made_header);
	        sprintf(buf,"%.3f",stat_kappa);
	        puthd("KAPPA",buf,made_header);
	      }
	     else
	      {
		sprintf(buf,"%.3f",phi_value_saved);
		puthd("PHI",buf,made_header);
		puthd("OSC_START",buf,made_header);
	      }
	  }
	 else
	  {
	    if(is_kappa)
	      {
		sprintf(buf,"%.3f",omega_value_saved);
		puthd("OMEGA",buf,made_header);
		puthd("OSC_START",buf,made_header);
		sprintf(buf,"%.3f",stat_phi);
		puthd("PHI",buf,made_header);
	        sprintf(buf,"%.3f",stat_kappa);
	        puthd("KAPPA",buf,made_header);
	      }
	     else
	      {
		sprintf(buf,"%.3f",omega_value_saved);
		puthd("OMEGA",buf,made_header);
		puthd("OSC_START",buf,made_header);
	      }
	  }
	if(is_2theta)
	  {
	    sprintf(buf,"%.3f",stat_2theta);
	    puthd("TWOTHETA",buf,made_header);
	  }
	if(stat_axis == 1)
	    puthd("AXIS","phi",made_header);
	  else
	    puthd("AXIS","omega",made_header);
	sprintf(buf,"%.5f",stat_wavelength);
	puthd("WAVELENGTH",buf,made_header);
	sprintf(buf,"%.3f",beam_xcen);
	puthd("BEAM_CENTER_X",buf,made_header);
	sprintf(buf,"%.3f",beam_ycen);
	puthd("BEAM_CENTER_Y",buf,made_header);
        if(doing_dark_current)
                sprintf(buf,"%d",doing_second_dk * 2 + 2 - double_exp_ctr);
          else
            {
                if(double_exp_flag)
                        sprintf(buf,"%d",4 + 2 - double_exp_ctr);
                    else
                        strcpy(buf,"5");
            }
	if(stat_attenuator != -1)
	{
		get_attenuator_name((int) (stat_attenuator + .01), buf);
		puthd("ATTENUATOR", buf, made_header);
	}
	padhd(made_header,512);
  }

/*      Routine to set the beamline to give a lock on the beamline process before starting 
*       data collection.  Right now, all it does it close the shutter, but when fully implemented
*       it should do the following:
*       1. Request a lock from the beamline process.  Upon getting a lock the "collection in progress"
*          signal line will be active.
*       2. If a lock cannot be obtained at this time (because another process is using the beamline),
*          issue a message to this effect and poll until the lock can be obtained.
*       3. After getting a lock, close the shutter.
*
*       There is also an unlock command.  Use of locks is entirely voluntary and is not enforced.
*/

     void send_bl_lock()
{
  /* output_blcmd(fdblcmd,"cmd","get_lock"); */
}
     void send_bl_unlock()
{
  /*output_blcmd(fdblcmd,"cmd","release_lock"); */
}

/*
 *	Routine to send the start detector exposing command.  Main purpose
 *	here is to build up filenames.
 */

send_det_start()
  {
	char	tempbuf[1024],tbuf[1024],infobuf[512],morebuf[100];
	char	im_3dig[4];
	char	suffix[20];
	int	hsize;
        int  detret;
	double	tmp;
	int	kind;
	char *message[80];
	
	make_header_smv();
	gethdl(&hsize, made_header);

	sprintf(tempbuf,"start\nheader_size %d\n",hsize);

	if(doing_dark_current)
		sprintf(suffix,"dkx_%d",doing_second_dk * 2 + 2 - double_exp_ctr);
	  else
	    {
		if(double_exp_flag)
			sprintf(suffix,"imx_%d",2 - double_exp_ctr);
		    else
			sprintf(suffix,"imx_0");
	    }
	util_3digit(im_3dig,stat_image_number);
	sprintf(infobuf,"info %s_%s.%s\n",stat_prefix,im_3dig,suffix);

        sprintf(morebuf,"row_xfer %d\ncol_xfer %d\n",chip_size_y / stat_bin, chip_size_x / stat_bin);
        strcat(tempbuf,morebuf);

	if(use_pc_shutter)
	  {
	    if(doing_dark_current == 0)
	      strcat(tempbuf,"pcshutter 1\n");
	     else
	      strcat(tempbuf,"pcshutter 0\n");
	  }
	if(use_j5_trigger)
	      strcat(tempbuf,"j5_trigger 1\n");
	if(use_timecheck)
	      strcat(tempbuf,"timecheck 1\n");

	strcat(tempbuf,infobuf);
	sprintf(tbuf,"adc %d\nrow_bin %d\ncol_bin %d\ntime %f\n",stat_adc,stat_bin,stat_bin,stat_time);
	strcat(tempbuf,tbuf);
	if(ccd_modular)
	{
		sprintf(tbuf,"save_raw %d\n",output_raws);
		strcat(tempbuf,tbuf);

		if(raw_ccd_image == 0)
			sprintf(tbuf,"transform_image 1\n");
		else
			sprintf(tbuf,"transform_image 0\n");
		strcat(tempbuf,tbuf);

		if(doing_dark_current)
		    kind = 2 * doing_second_dk + 2 - double_exp_ctr;
		else
		  {
		    if(double_exp_flag)
		        kind = 4 + 2 - double_exp_ctr;
		    else
		        kind = 5;
		  }
		sprintf(tbuf,"image_kind %d\n",kind);
		strcat(tempbuf,tbuf);
	}

	detret = output_detcmd(fddetcmd,tempbuf,made_header,hsize);
        if (detret == CCD_DET_NOTCONNECTED) {
          dc_stop = 1;
	  sprintf(message[0]," send_det_start");
	  issue_signal("CCD_SIG_DET_DROPPED",message);
          set_alert_msg("ERROR: Detector control not connected.");
        }
  }

/*
 *	Routine to send the start beam line exposing command.  Main purpose
 *	here is to build up filenames.
 */

int	send_bl_start()
  {
	char	tempbuf[1024],tbuf[1024];
	char	im_3dig[4];
	char	suffix[20];
	double	tmp;
	int 	bline_ret;
	char	*ztime();
        time_t  t_start,t_end;
        int     i_start,i_end,time_total;
	char *message[80];

	if(doing_dark_current)
		sprintf(suffix,"dkc(%d)",doing_second_dk * 2 + 2 - double_exp_ctr);
	  else
	    {
		if(double_exp_flag)
			sprintf(suffix,"img(%d)",2 - double_exp_ctr);
		    else
			sprintf(suffix,"img");
	    }

	if(stat_axis == 1)
		tmp = phi_value_saved;
	    else
		tmp = omega_value_saved;
	sprintf(tempbuf,"collect\ntime %10.2f\ndistance %10.2f\nosc_width %10.3f\nphi_start %10.3f\n",
		stat_time,stat_dist,stat_osc_width,tmp);
	sprintf(tbuf,"wavelength %7.5f\ndirectory %s\nimage_prefix %s\nimage_suffix %s\nimage_number %d\n",
		stat_wavelength,stat_dir,stat_prefix,suffix,stat_image_number);
	strcat(tempbuf,tbuf);

	/*
	 *	To simplify for (older) software which does not support multiple axes, if
	 *	the data collection is not omega, omit the axis specification.
	 */

	if(stat_axis == 0)
		strcat(tempbuf,"axis 0\n");

	if(doing_dark_current)
	  strcat(tempbuf,"mode darkcurrent_dc\n");
         else {
             if (stat_mode == 1) {
               sprintf (tbuf,"mode dose\nstep_size %f\ndose_per_step %f\n",
                stat_step_size, stat_dose_step);
               strcat(tempbuf,tbuf);
             }
             else {
             strcat(tempbuf,"mode beamline_dc\n");
             }
           }

	sprintf(tbuf,"adc %d\nbin %d\n",stat_adc,stat_bin);
	strcat(tempbuf,tbuf);
	util_3digit(im_3dig,stat_image_number);
	fprintf(stdout,"send_bl_start: START         at %s: %s_%s.%s\n",ztime(),stat_prefix,im_3dig,suffix);

        time(&t_start);
	i_start = (int) t_start;

	bline_ret = output_blcmd(fdblcmd,"cmd",tempbuf);
        time(&t_end);
        i_end = (int) t_end;
        time_total = t_end - t_start;

	switch (bline_ret) {
	  case CCD_BL_FATAL:
		dc_stop = 1;
	  break;
	  case CCD_BL_NOTCONNECTED:
	  case CCD_BL_DISCONNECTED:
		dc_stop = 1;
		sprintf(message[0]," CCD_BL_NOTCONNECTED");
		issue_signal("CCD_SIG_BL_DROPPED");
                set_alert_msg("ERROR: Beamline control not connected.");
/* printf ("no beamline\n"); */
	  break;
          default:
	  break;
	}
	if(dc_stop == 0 && retryshort != 0)
	  {
            fprintf(stdout,"send_bl_start: TIMERS        at %s: total %d\n",ztime(),time_total);
	    fflush(stdout);
            if(time_total < (stat_time - 2.))   /* for sure too fast */
              {
                fprintf(stdout,"send_bl_start: DONE (retry)  at %s: EXPOSURE TOO SHORT\n",ztime());
	        fflush(stdout);
                bline_ret = CCD_BL_RETRY;
		exposure_short_by = (int) (stat_time - time_total);
		exposure_short_by += 3;		/* allow some slop here */
              }
          }
        return(bline_ret);
  }

/*
*      To collect a frame, one gets a lock on the beamline process, starts the detector in collection
*      mode, starts the beamline process, waits for completion indicating status, and then unlocks
*     the detector.
*
*/
void collect_frame()
{

#ifdef X8C
  send_bl_lock();
  output_blcmd(fdblcmd,"cmd","shutter 0");   /* close the shutter, just in case */
#endif /* X8C */

  send_det_start();
  gl_blret = send_bl_start();

#ifdef X8C
  send_bl_unlock();
#endif /* X8C */

}
send_copy_command()
  {
	int	len_xfcmd;
	char	xfcmd_buf[512];
        char    num[4];
        int     i,kind,raw_end;
	char	suffix[20],raw_suffix[20];
	char	body[512];
	char	dzstuff[100];
	int	hsize;

	gethdl(&hsize, made_header);

        if(raw_ccd_image == 1)
          sprintf(body,
 "copy\nreply 0\nrow_mm %f\ncol_mm %f\ndist_mm %f\ntwo_theta %f\nheader_size %d\nrow_xfer %d\ncol_xfer %d\nrow_bin %d\ncol_bin %d\n",
                beam_xcen,beam_ycen,stat_dist,stat_2theta,hsize,chip_size_y / stat_bin ,chip_size_x / stat_bin ,
                        stat_bin,stat_bin);
         else
          sprintf(body,
 "xform\nreply 0\nrow_mm %f\ncol_mm %f\ndist_mm %f\ntwo_theta %f\nheader_size %d\nrow_xfer %d\ncol_xfer %d\nrow_bin %d\ncol_bin %d\n",
                beam_xcen,beam_ycen,stat_dist,stat_2theta,hsize,chip_size_y / stat_bin,chip_size_x / stat_bin,
                        stat_bin,stat_bin);

	if(stat_compress == 1)
		strcat(body,"compress 1\n");
	    else
		strcat(body,"compress 0\n");
	if(detector_sn > 0)
	  {
		sprintf(dzstuff,"detector_sn %d\n",detector_sn);
		strcat(body,dzstuff);
	  }
	if(strip_ave)
	  {
		if(n_strip_ave == 4)
		  sprintf(dzstuff,"strip_ave %.3f_%.3f_%.3f_%.3f\n",strip_ave_vals[0],strip_ave_vals[1],
								    strip_ave_vals[2],strip_ave_vals[3]);
		 else
		  sprintf(dzstuff,"strip_ave %.3f\n",strip_ave_vals[0]);
		strcat(body,dzstuff);
	  }
	sprintf(dzstuff,"save_raw %d\n",output_raws);
	strcat(body,dzstuff);

	if(doing_dark_current)
	  {
	    if(doing_second_dk == 0)
	    	strcpy(suffix,"dkc");
	      else
		strcpy(suffix,"dkd");

	    strcpy(raw_suffix,"dkx");
	    kind = 2 * doing_second_dk + 2 - double_exp_ctr;
	    raw_end = kind;
	  }
	 else
	  {
	    strcpy(suffix,"img");
	    strcpy(raw_suffix,"imx");
	    if(double_exp_flag)
	      {
	        kind = 4 + 2 - double_exp_ctr;
		raw_end = 2 - double_exp_ctr;
		sprintf(dzstuff,"dzratio %f\n",stat_dzratio);
		strcat(body, dzstuff);
	      }
	     else
	      {
	        kind = 5;
		raw_end = 0;
	      }
	  }

	sprintf(dzstuff,"outfile_type %d\n",outfile_type);
	strcat(body,dzstuff);

        i = stat_image_number;
        num[0] = '0' + i / 100;
        i = i - 100 * (i / 100);
        num[1] = '0' + i / 10;
        i = i - 10 * (i / 10);
        num[2] = '0' + i;
        num[3] = '\0';

	if(-1 == fdxfcm)
	  {
		fprintf(stderr,"ccd_dc: xform command file is NOT connected.\n");
		fprintf(stderr,"ccd_dc: currently, THIS IS A WARNING\n");
	  }
	 else
	  {
		sprintf(xfcmd_buf,"%sinfile <socket>\noutfile %s%s_%s.%s\nrawfile %s%s_%s.%s_%d\nkind %d\n",
			body,stat_dir,stat_prefix,num,suffix,stat_dir,stat_prefix,num,raw_suffix,raw_end,kind);
		strcat(xfcmd_buf,"end_of_det\n");
		len_xfcmd = strlen(xfcmd_buf);
		if(len_xfcmd != rep_write(fdxfcm,xfcmd_buf,len_xfcmd))
		  {
			fprintf(stderr,"ccd_dc: xform process has disconnected.\n");
			fprintf(stderr,"ccd_dc: currently, THIS IS A WARNING.\n");
			notify_server_eof(fdxfcm);
		  }
	  }
  }

/*
 *	Get the next image from the runs file.
 */

get_next_image_from_runfile(mdccp)
mdc_command	*mdccp;
  {
	char	read_file_line[256],read_file_name[256];
	float	f1,f2,f3,f4,f5;
	char	tempbuf[2048];

	if(NULL != fgets(read_file_line,sizeof (read_file_line), fprun))
	  {
	    sscanf(read_file_line,"%s %f %f %f %f %f",read_file_name,&f1,&f2,&f3,&f4,&f5);
	    parse_file_name(read_file_name,stat_prefix,&stat_image_number);
	    mdccp->cmd_col_time = f1;
	    if(mdccp->cmd_col_kappas != -9999.)
	      {
		if(fabs(f5 - stat_kappa) > 0.0001)
		  {
			sprintf(tempbuf,"kappa_move %10.3f",f5);
	        	output_blcmd(fdblcmd,"cmd",tempbuf);
			stat_kappa = f5;
		  }
	      }
	    if(mdccp->cmd_col_phis != -9999.)
	      {
		if(fabs(f4 - stat_phi) > 0.0001)
		  {
			sprintf(tempbuf,"phi_move %10.3f",f4);
	        	output_blcmd(fdblcmd,"cmd",tempbuf);
			stat_phi = f4;
		        phi_value_saved = stat_phi;
		  }
	      }
	    if(mdccp->cmd_col_omegas != -9999.)
	      {
		if(fabs(f3 - stat_omega) > 0.0001)
		  {
			sprintf(tempbuf,"omega_move %10.3f",f3);
	        	output_blcmd(fdblcmd,"cmd",tempbuf);
			stat_omega = f3;
			omega_value_saved = stat_omega;
		  }
	      }
/*
 *	This needs to be changed so that it won't crash
 *	bl progs with no wavelength move:
 *	    if(fabs(f2 - stat_wavelength) > 0.001)
 */
 	    if(is_wavelength)
	      {
	        strcpy(stat_scanner_op,"setting_wavelength");
	        sprintf(tempbuf,"wavelength_move %.6f",f2);
	        output_blcmd(fdblcmd,"cmd",tempbuf);
	        stat_wavelength = f2;
	      }
	     else
	      {
 	        if(fabs(f2 - stat_wavelength) > 0.000005)
	          {
	            strcpy(stat_scanner_op,"setting_wavelength");
	            sprintf(tempbuf,"wavelength_move %.6f",f2);
	            output_blcmd(fdblcmd,"cmd",tempbuf);
	            stat_wavelength = f2;
	          }
	      }
	  }
	 else
	   totimg = 0;
  }

/*
 *	ccd_hw_start:
 *
 *	This is where all commands to the ccd detector system
 *	begin execution.
 *
 *	ccd_hw_start will begin the sequencing of possibly
 *	complex commands, splitting their functions between
 *	calls to the beamline control and detector control
 *	processes.
 */

void	ccd_hw_start(mdccp)
mdc_command	*mdccp;
  {
	int	current,wanted,nsteps_to_move;
	int	i,j,k,runno,need_new_dk;
	int	run_found;
	float	f1,f2,f3,f4,f5;
	char	read_file_line[256],read_file_name[256];
	char	tempfname[256];
	char	tempbuf[2048],tbuf[2048],prefix_without_run[80];
	int	bline_ret;
	int	ccd_hw_progress();
	int	read_bl_wavelength;
	float	wavelength_read;
	double	velocity;
	time_t	now;
	char *message[80];

	double	fabs();

	active_trans = 0;
	command_rejected = 0;

	strcpy(stat_scanner_control,"active");

        if(mdccp->cmd_no != MDC_COM_STARTUP)
          {
            if(fdblcmd == -1)
              {
		sprintf(message[0]," ccd_hw_start");
		issue_signal("CCD_SIG_BL_DROPPED",message);
                set_alert_msg("ERROR: Beamline process NOT connected.");
                return;
              }
          }

	switch(mdccp->cmd_no)
	  {
	    case MDC_COM_STARTUP:
		break;
	    case MDC_COM_INIT:

		strcpy(stat_scanner_op,"initializing");
		output_blcmd(fdblcmd,"cmd","initialize");

		break;

	    case MDC_COM_ERASE:

		break;

	    case MDC_COM_CONFIG:

		break;

	    case MDC_COM_DSET:

		strcpy(stat_scanner_op,"setting distance");
		sprintf(tempbuf,"distance_set %10.2f",mdccp->cmd_value);
		output_blcmd(fdblcmd,"cmd",tempbuf);
		stat_dist = mdccp->cmd_value;

		break;

	    case MDC_COM_PSET:

		strcpy(stat_scanner_op,"setting phi");
		sprintf(tempbuf,"phi_set %10.3f",mdccp->cmd_value);
		output_blcmd(fdblcmd,"cmd",tempbuf);
		stat_phi = mdccp->cmd_value;

		break;

	    case MDC_COM_OSET:

		strcpy(stat_scanner_op,"setting omega");
		sprintf(tempbuf,"omega_set %10.3f",mdccp->cmd_value);
		output_blcmd(fdblcmd,"cmd",tempbuf);
		stat_omega = mdccp->cmd_value;

		break;

	    case MDC_COM_KSET:

		strcpy(stat_scanner_op,"setting kappa");
		sprintf(tempbuf,"kappa_set %10.23",mdccp->cmd_value);
		output_blcmd(fdblcmd,"cmd",tempbuf);
		stat_kappa = mdccp->cmd_value;

		break;

	    case MDC_COM_LSET:

		delta = mdccp->cmd_value;
		strcpy(stat_scanner_op,"setting lift");
		sprintf(tempbuf,"lift_set %10.3f",mdccp->cmd_value);
		output_blcmd(fdblcmd,"cmd",tempbuf);
		stat_lift = delta;

		break;

            case MDC_COM_WSET:

                delta = mdccp->cmd_value;
                strcpy(stat_scanner_op,"setting wavelength");
                sprintf(tempbuf,"wavelength_set %7.5f",mdccp->cmd_value);
                output_blcmd(fdblcmd,"cmd",tempbuf);
                stat_wavelength = delta;

                break;

	    case MDC_COM_SHUT:

		strcpy(stat_scanner_op,"Shutter control");
		if(use_pc_shutter == 0)
		{
		if(mdccp->cmd_value != 0)
		  {
			strcpy(stat_scanner_shutter,"open");
			strcpy(tempbuf,"shutter 1");
		  }
		 else
		  {
			strcpy(stat_scanner_shutter,"closed");
			strcpy(tempbuf,"shutter 0");
		  }
		output_blcmd(fdblcmd,"cmd",tempbuf);
		} else {
		    if(mdccp->cmd_value != 0)
		      {
			strcpy(stat_scanner_shutter,"open");
			strcpy(tempbuf,"shutter\npcshutter 1\n");
		      }
		     else
		      {
			strcpy(stat_scanner_shutter,"closed");
			strcpy(tempbuf,"shutter\npcshutter 0\n");
		      }
		    output_detcmd(fddetcmd,tempbuf,NULL,0);
		    /*
		     *	This is prurely cosmetic:  This gets the
		     *	shutter status properly set via the beamline
		     *	process, which does not actually do anything
		     *	BUT set this status.
		     */
		    if(mdccp->cmd_value != 0)
		      {
			strcpy(stat_scanner_shutter,"open");
			strcpy(tempbuf,"shutter 1");
		      }
		     else
		      {
			strcpy(stat_scanner_shutter,"closed");
			strcpy(tempbuf,"shutter 0");
		      }
		    output_blcmd(fdblcmd,"cmd",tempbuf);
		  }



		break;

	    case MDC_COM_SCAN:

		break;

	    case MDC_COM_DMOVE:

		strcpy(stat_scanner_op,"moving distance");
		sprintf(tempbuf,"distance_move %10.2f",mdccp->cmd_value);
		output_blcmd(fdblcmd,"cmd",tempbuf);

		break;

	    case MDC_COM_LMOVE:

		strcpy(stat_scanner_op,"moving lift");
		sprintf(tempbuf,"lift_move %10.3f",mdccp->cmd_value);
		output_blcmd(fdblcmd,"cmd",tempbuf);

		break;

            case MDC_COM_WMOVE:

                strcpy(stat_scanner_op,"moving wavelength");
                sprintf(tempbuf,"wavelength_move %7.5f",mdccp->cmd_value);
                output_blcmd(fdblcmd,"cmd",tempbuf);

                break;

            case MDC_COM_AMOVE:

                strcpy(stat_scanner_op,"moving_attenuator");
                sprintf(tempbuf,"attenuator_move %8.5f",mdccp->cmd_value);
                output_blcmd(fdblcmd,"cmd",tempbuf);
                break;

            case MDC_COM_AUTOALIGN:

                strcpy(stat_scanner_op,"autoaligning");
                sprintf(tempbuf,"autoalign %.1f",mdccp->cmd_value);
                output_blcmd(fdblcmd,"cmd",tempbuf);
                break;

	    case MDC_COM_XL_HS_MOVE:

                strcpy(stat_scanner_op,"moving_horiz_slit");
                sprintf(tempbuf, "xl_hs_move %.3f", mdccp->cmd_value);
                output_blcmd(fdblcmd,"cmd",tempbuf);
		break;

	    case MDC_COM_XL_VS_MOVE:

                strcpy(stat_scanner_op,"moving_vert_slit");
                sprintf(tempbuf, "xl_vs_move %.3f", mdccp->cmd_value);
                output_blcmd(fdblcmd,"cmd",tempbuf);
		break;

	    case MDC_COM_XL_UP_HHS_MOVE:

                strcpy(stat_scanner_op,"moving_up_h_halfslit");
                sprintf(tempbuf, "xl_up_hhs_move %.1f", mdccp->cmd_value);
                output_blcmd(fdblcmd,"cmd",tempbuf);
		break;

	    case MDC_COM_XL_UP_VHS_MOVE:

                strcpy(stat_scanner_op,"moving_up_v_halfslit");
                sprintf(tempbuf, "xl_up_vhs_move %.1f", mdccp->cmd_value);
                output_blcmd(fdblcmd,"cmd",tempbuf);
		break;

	    case MDC_COM_XL_DN_HHS_MOVE:

                strcpy(stat_scanner_op,"moving_dn_h_halfslit");
                sprintf(tempbuf, "xl_dn_hhs_move %.1f", mdccp->cmd_value);
                output_blcmd(fdblcmd,"cmd",tempbuf);
		break;

	    case MDC_COM_XL_DN_VHS_MOVE:

                strcpy(stat_scanner_op,"moving_dn_v_halfslit");
                sprintf(tempbuf, "xl_dn_vhs_move %.1f", mdccp->cmd_value);
                output_blcmd(fdblcmd,"cmd",tempbuf);
		break;

	    case MDC_COM_PMOVE:

		strcpy(stat_scanner_op,"moving phi");
		sprintf(tempbuf,"phi_move %10.3f",mdccp->cmd_value);
		output_blcmd(fdblcmd,"cmd",tempbuf);

		break;

	    case MDC_COM_PMOVEREL:

		strcpy(stat_scanner_op,"moving phi");
		sprintf(tempbuf,"phi_move_rel %10.3f",mdccp->cmd_value);
		output_blcmd(fdblcmd,"cmd",tempbuf);

		break;

	    case MDC_COM_OMOVE:

		strcpy(stat_scanner_op,"moving omega");
		sprintf(tempbuf,"omega_move %10.3f",mdccp->cmd_value);
		output_blcmd(fdblcmd,"cmd",tempbuf);

		break;

	    case MDC_COM_KMOVE:

		strcpy(stat_scanner_op,"moving kappa");
		sprintf(tempbuf,"kappa_move %10.3f",mdccp->cmd_value);
		output_blcmd(fdblcmd,"cmd",tempbuf);

		break;

	    case MDC_COM_GONMAN:

		strcpy(stat_scanner_op,"Goniostat in Manual Mode");
		sprintf(tempbuf,"gon_manual %10.3f",mdccp->cmd_value);
		output_blcmd(fdblcmd,"cmd",tempbuf);

		break;

	    case MDC_COM_HOME:

		strcpy(stat_scanner_op,"Homing Goniostat Angles");
		sprintf(tempbuf,"home");
		output_blcmd(fdblcmd,"cmd",tempbuf);

		break;

	    case MDC_COM_COLL:

	    case MDC_COM_SNAP:

		read_bl_wavelength = 0;
#ifdef	X8C
		{
		  /* get the wavelength --JB 14-Jun-01 */
#include "../incl/issue_signal.h"
		     char *message[80];
		     static char *msgname = "CCD_SIG_GETWAVE";
		     float  fw;
		     int retval;
		     
		     fw = 0;
		     message[0] = NULL;
		     retval = issue_signal(msgname, message);
		     if (retval == SIG_OK)   /* Normal response */
		       {
			 if (strlen(message) != 0)
			   {
			     sscanf(message,"%f",&fw);
			     if ((fw < 0.5) || (fw > 5.0))
			       {
				 fprintf(stdout,"Crazy wavelength of %f A read but ignored.\n",fw);
				 read_bl_wavelength = 0;
			       }
			     else
			       {
				 stat_wavelength = fw;
				 fprintf(stdout,"INFO: Wavelength set to: %f A\n",stat_wavelength);
				 read_bl_wavelength = 1;
				 wavelength_read = fw;
			       }
			   }
			 else
			   {
			     fprintf(stderr,"Error-%s did not return a value.\n", msgname);
			   }
		       }
		     else if (retval == SIG_SYSERR)
		       {
			 fprintf(stderr,"Error in system call to %s \n", msgname);
		       }
		     else if (retval == SIG_CMDERR)
		       {
			 fprintf(stderr,"Error-%s gave error message  %s", msgname,  message);
		       }
		     else if (retval == SIG_NULLMSG)
		       {
			 fprintf(stderr,"Error-%s did not return OK\n", msgname);
		       }
		   }
#endif /* X8C */

                if(fddetcmd == -1 || fdxfcm == -1)
                  {
                        strcpy(tempbuf,"ERROR: ");
			sprintf(message[0]," MDC_COLL");
                        if(fddetcmd == -1)
			  {
			    strcat(tempbuf,"Detector process NOT connected.");
			    issue_signal("CCD_SIG_DET_DROPPED",message);
			  }
                        if(fdxfcm == -1)
			  {
			    strcat(tempbuf,"Transform process NOT connected.");
			    issue_signal("CCD_SIG_XFORM_DROPPED",message);
			  }
                        set_alert_msg(tempbuf);
			command_rejected = 1;
                        return;
                  }

		if(mdccp->cmd_col_osc_width == 0)
		{
			if(allow_stills == 0)
			{
				set_alert_msg("ERROR: A still (rotation width=0) is NOT allowed");
				command_rejected = 1;
				return;
			}
		}
		else
		{
			velocity = mdccp->cmd_col_osc_width / mdccp->cmd_col_time;
			if(velocity < min_velocity)
			{
				set_alert_msg("ERROR: velocity (time / width) too small for collect");
				command_rejected = 1;
				return;
			} 
			else
			if(velocity > max_velocity)
			{
				set_alert_msg("ERROR: velocity (time / width) too large for collect");
				command_rejected = 1;
				return;
			}
		}
		parse_file_name(mdccp->cmd_col_prefix,prefix_without_run,&runno);
		if(mdccp->cmd_col_restart_run == -1)
		  {
		    if(mdccp->cmd_col_mad_mode == 0)
		      {
			mdccp->cmd_col_mad_nwave = 1;
			if(read_bl_wavelength == 0 || mdccp->cmd_col_run_wave < 0)
				mdccp->cmd_col_mad_wavelengths[0] = stat_wavelength;
			else
				mdccp->cmd_col_mad_wavelengths[0] = wavelength_read;
		      }
		    mdccp->cmd_col_restart_run = runno;
		    mdccp->cmd_col_restart_image = mdccp->cmd_col_image_number;

		    generate_run_list(mdccp);
		  }
		fprintf(stdout,"ccd_dc_api_mad: restart_run: %d restart_image: %d\n", mdccp->cmd_col_restart_run,
								 mdccp->cmd_col_restart_image);
		stat_2theta = mdccp->cmd_col_lift;

		/*
		 *	Find the first image in the runs file.
		 */
		sprintf(tempfname,"%s/%s.runlist",mdccp->cmd_col_dir,mdccp->cmd_col_prefix);
		if(NULL == (fprun = fopen(tempfname,"r")))
		  {
		    fprintf(stderr,"ccd_dc_api: FATAL: Cannot open run file %s\n",tempfname);
		    fprintf(stderr,"            This file is NECESSARY for the program to run\n");
		    fprintf(stderr,"            and should have been generated previously\n");
		    fprintf(stderr,"            by this program.\n");
		    cleanexit(BAD_STATUS);
		  }

		/*
		 *	Generate the file name of the actual beginning image
		 *	(except the .img part).
		 */

		util_3digit(tbuf,mdccp->cmd_col_restart_image);
		sprintf(tempbuf,"%s_%d_%s",prefix_without_run,mdccp->cmd_col_restart_run,tbuf);
		fprintf(stderr,"ccd_dc_api_mad: looking for image %s as first image number\n",tempbuf);

		/*
		 *	Take this image name and read each line in
		 *	the runs file, one at a time, until this string is
		 *	matched.  When this occurs, we will have the necessary
		 *	angle, etc., parameters, for the image.  The logic
		 *	works weather restart or no.
		 */

		run_found = 0;
		while(NULL != fgets(read_file_line,sizeof (read_file_line), fprun))
		  if(NULL != (char *) strstr(read_file_line,tempbuf))
		    {
			run_found = 1;
			break;
		    }
		if(run_found == 0)
		  {
		    fprintf(stderr,"ccd_dc_api: Run %d, image %d NOT FOUND in current\n",
			mdccp->cmd_col_restart_run,mdccp->cmd_col_restart_image);
		    fprintf(stderr,"            Not performing this run.\n");
		    dc_abort = 1;
		    break;
		  }
		sscanf(read_file_line,"%s %f %f %f %f %f",read_file_name,&f1,&f2,&f3,&f4,&f5);
		parse_file_name(read_file_name,stat_prefix,&stat_image_number);
		mdccp->cmd_col_time = f1;
		if(mdccp->cmd_col_omegas != -9999.)
			mdccp->cmd_col_omegas = f3;
		if(mdccp->cmd_col_phis != -9999.)
			mdccp->cmd_col_phis = f4;
		if(mdccp->cmd_col_kappas != -9999.)
			mdccp->cmd_col_kappas = f5;
		mdccp->cmd_col_image_number = mdccp->cmd_col_restart_image;
		if(is_wavelength)
		  {
		    strcpy(stat_scanner_op,"setting_wavelength");
		    sprintf(tempbuf,"wavelength_move %7.5f",f2);
		    output_blcmd(fdblcmd,"cmd",tempbuf);
		    stat_wavelength = f2;
		  }
		else
		  {
		    if(fabs(f2 - stat_wavelength) > 0.001)
		      {
		        strcpy(stat_scanner_op,"setting_wavelength");
		        sprintf(tempbuf,"wavelength_move %7.5f",f2);
		        output_blcmd(fdblcmd,"cmd",tempbuf);
		        stat_wavelength = f2;
		      }
		  }
		if(mdccp->cmd_col_atten_run != -1)
		{
			if(1 || fabs(stat_attenuator - mdccp->cmd_col_atten_run) > .001)
			{
		    		strcpy(stat_scanner_op,"setting_attenuator");
		    		sprintf(tempbuf,"attenuator_move %7.5f",mdccp->cmd_col_atten_run);
		    		output_blcmd(fdblcmd,"cmd",tempbuf);
		    		stat_attenuator = mdccp->cmd_col_atten_run;
			}
		}

		if(mdccp->cmd_col_autoal_run == 1)
		{
                	strcpy(stat_scanner_op,"autoaligning");
                	sprintf(tempbuf,"autoalign 1");
                	output_blcmd(fdblcmd,"cmd",tempbuf);
		}

		if(mdccp->cmd_col_hslit_run != -1)
		{
		    		strcpy(stat_scanner_op,"setting_horiz_slit");
		    		sprintf(tempbuf,"hslit %7.5f",mdccp->cmd_col_hslit_run);
		    		output_blcmd(fdblcmd,"cmd",tempbuf);
		    		stat_hslit = mdccp->cmd_col_hslit_run;
		}

		if(mdccp->cmd_col_vslit_run != -1)
		{
		    		strcpy(stat_scanner_op,"setting_vert_slit");
		    		sprintf(tempbuf,"vslit %7.5f",mdccp->cmd_col_vslit_run);
		    		output_blcmd(fdblcmd,"cmd",tempbuf);
		    		stat_vslit = mdccp->cmd_col_vslit_run;
		}

		if (mdccp->cmd_no == MDC_COM_SNAP) {
 		   doing_snapshot = 1;
		}
	        else {
		   doing_snapshot = 0;

		   // 8BM run CONSOLE housekeeping
		   if (bm8_mod) {

		     // make sure current client-server connection to CSERVER working.
		     // if not kill old connection and reattach
		     // if reattachment fails barf!

                      bline_ret = output_blcmd(fdblcmd,"cmd", "check_cons"); 
		      if (bline_ret == 0) {
			 set_alert_msg("Cannot re-attach to CONSOLE RPC-server/8BM");
			 dc_abort = 1;
			 break;
		      }

		      // if DCM4 note current CONSOLE script chain to it
                      bline_ret = output_blcmd(fdblcmd,"cmd", "current_script"); 
		   }
                }

		need_new_dk = 0;

		phi_speed_used = phi_top_speed;
		stat_time = mdccp->cmd_col_time;

		if(mdccp->cmd_col_omegas != -9999.)
			stat_start_omega = mdccp->cmd_col_omegas;
		if(mdccp->cmd_col_phis != -9999.)
			stat_start_phi = mdccp->cmd_col_phis;
		if(mdccp->cmd_col_kappas != -9999.)
			stat_start_kappa = mdccp->cmd_col_kappas;

		stat_axis = mdccp->cmd_col_axis;
		phi_value_saved = stat_start_phi;
		omega_value_saved = stat_start_omega;
		stat_omega = stat_start_omega;
		stat_phi = stat_start_phi;
		stat_kappa = stat_start_kappa;

		stat_osc_width = mdccp->cmd_col_osc_width;
		stat_n_images = mdccp->cmd_col_n_images;
		stat_n_passes = mdccp->cmd_col_n_passes;
		stat_image_number = mdccp->cmd_col_image_number;

		stat_compress = mdccp->cmd_col_compress;
		stat_anom = mdccp->cmd_col_anom;
		stat_wedge = mdccp->cmd_col_wedge;
		if(mdccp->cmd_col_dzratio != -1)
			stat_dzratio = mdccp->cmd_col_dzratio;
		if(mdccp->cmd_col_dkinterval != -1)
			dark_current_interval = mdccp->cmd_col_dkinterval;
		if(mdccp->cmd_col_rep_dark != -1)
			repeat_dark_current = mdccp->cmd_col_rep_dark;
		if(mdccp->cmd_col_dk_before != -1)
			dk_before_run = mdccp->cmd_col_dk_before;
		if(mdccp->cmd_col_outfile_type != -1)
			outfile_type = mdccp->cmd_col_outfile_type;
		if(mdccp->cmd_col_no_transform != -1)
		  {
			no_transform = mdccp->cmd_col_no_transform;
			raw_ccd_image = no_transform;
		  }
		if(mdccp->cmd_col_output_raws != -1)
			output_raws = mdccp->cmd_col_output_raws;
		if(stat_n_images > stat_wedge)
		    wedge_size = stat_wedge;
		  else
		    wedge_size = stat_n_images;

		if(stat_n_passes == 2)
			double_exp_flag = 1;
		  else
			double_exp_flag = 0;
		strcpy(stat_dir,mdccp->cmd_col_dir);

		if(0)	/* DEBUG 4/26/99: SUPERCEEDED BY MAD CODE HANDLING OF NAMES */
		  strcpy(stat_prefix,mdccp->cmd_col_prefix);

		if(stat_adc != mdccp->cmd_col_adc || stat_bin != mdccp->cmd_col_bin)
		    need_new_dk = 1;
		if(dk_before_run)
		    need_new_dk = 1;
		if(need_new_dk)
		    time((time_t *) &dark_current_time);

		stat_adc = mdccp->cmd_col_adc;
		stat_bin = mdccp->cmd_col_bin;

		if(stat_anom)	/* for anomalous, we need to figure out the goniostat type */
		  {
		    if(is_kappa)
		      {
		        goniostat_type = 2;
			wedge_kappa = stat_start_kappa;
			wedge_omega = stat_start_omega;
			wedge_phi =   stat_start_phi;
			kappa_init(kappa_const);
		      }
		     else
		      {
		        goniostat_type = 0;
			wedge_phi =   stat_start_phi;
		      }
		    wedge_count = wedge_size;
		    wedge_side = 0;
		    j = strlen(stat_prefix);
		    for(i = j - 1; i >= 0; i--)
		      if(stat_prefix[i] == '_')
			break;
		    wedge_run = atoi(&stat_prefix[i+1]);
		    wedge_imno = stat_image_number;
		    for(j = 0; j < i; j++)
		      wedge_prefix[j] = stat_prefix[j];
		    wedge_prefix[j] = '\0';
		  }

		if(doing_snapshot == 0)
		  {
		    beam_xcen = mdccp->cmd_col_xcen;
		    beam_ycen = mdccp->cmd_col_ycen;
		  }
		totimg = stat_n_images;
		totpass = stat_n_passes;
		stat_mode = mdccp->cmd_col_mode;
		if(stat_mode == 1)	/* dose */
			stat_time = stat_dose_step;

		if(stat_n_passes == 2)
		  {
		    double_exp_flag = 1;
		    double_exp_ctr = 2;
		  }
		 else
		  {
		    double_exp_flag = 0;
		    double_exp_ctr = 1;
		  }

		if(mdccp->cmd_no == MDC_COM_COLL)
		  {
		    fprintf(stdout,"ccd_dc_hw: doing collect, stat_time: %f current_darkcurrent_time: %f\n",stat_time, current_darkcurrent_time);
		    if(mdccp->cmd_col_newdark == 1 || need_new_dk == 1 || stat_time != current_darkcurrent_time)
		      {
		        fprintf(stdout,"ccd_dc_hw: setting up to do a new darkcurrent\n");
			doing_dark_current = 1;
			doing_second_dk = 0;
			double_exp_ctr = 2;
			current_darkcurrent_time = stat_time;
		      }
		     else
			doing_dark_current = 0;
		    if(repeat_dark_current)
		      {
			fprintf(stdout,"ccd_dc_api: informational: dark currents will be repeated\n");
			fprintf(stdout,"ccd_dc_api:                every %d seconds.\n",dark_current_interval);
		      }
		  }
		 else	/* snapshot with no recalc'd dark current */
		  {
		    doing_second_dk = 0;
		    doing_dark_current = 0;
		  }

		/*
		 *	Always move/set the distance for SNAP and COLLECT.
		 */

		if(is_distance)
		  {
			strcpy(stat_scanner_op,"moving distance");
			sprintf(tempbuf,"distance_move %10.2f",mdccp->cmd_col_dist);
			output_blcmd(fdblcmd,"cmd",tempbuf);
		  }
		else
		  {
			strcpy(stat_scanner_op,"setting distance");
			sprintf(tempbuf,"distance_set %10.2f",mdccp->cmd_col_dist);
			output_blcmd(fdblcmd,"cmd",tempbuf);
		  }
/*
 *	This code was put into the ALS.  Removed at SPring8:
 *
 *		while(fabs(stat_dist - mdccp->cmd_col_dist) > 0.01)
 *			pause();
 */
		stat_dist = mdccp->cmd_col_dist;
		if(is_2theta && mdccp->cmd_col_lift != -9999.)
		  {
			if(0)
			{
			  fprintf(stdout,"ccd_dc_api: Would move lift before run start\n");
			}
			else
			{
			strcpy(stat_scanner_op,"moving 2theta");
			sprintf(tempbuf,"lift_move %10.3f",mdccp->cmd_col_lift);
			output_blcmd(fdblcmd,"cmd",tempbuf);
			}
		  }
		stat_2theta = mdccp->cmd_col_lift;

		/*
		 *	For the three goniostat angles, move them if they
		 *	exist for COLLECT.  SNAP is handled below.
		 */

		if(is_phi && mdccp->cmd_col_phis != -9999.)
		  {
			if(0)
			{
			  fprintf(stdout,"ccd_dc_api: Would move phi before run start\n");
			}
			else
			{
			strcpy(stat_scanner_op,"moving phi");
			sprintf(tempbuf,"phi_move %10.3f",mdccp->cmd_col_phis);
			output_blcmd(fdblcmd,"cmd",tempbuf);
			}
		  }

		if(is_omega && mdccp->cmd_col_omegas != -9999.)
		  {
		    if(0)
		    {
		      fprintf(stdout,"ccd_dc_api: Would move omega before run start\n");
		    }
		    else
		    {
		    strcpy(stat_scanner_op,"moving omega");
		    sprintf(tempbuf,"omega_move %10.3f",mdccp->cmd_col_omegas);
		    output_blcmd(fdblcmd,"cmd",tempbuf);
		    }
		  }
		if(is_kappa && mdccp->cmd_col_kappas != -9999.)
		  {
		    if(0)
		    {
		      fprintf(stdout,"ccd_dc_api: Would move kappa before run start\n");
		    }
		    else
		    {
		    strcpy(stat_scanner_op,"moving kappa");
		    sprintf(tempbuf,"kappa_move %10.3f",mdccp->cmd_col_kappas);
		    output_blcmd(fdblcmd,"cmd",tempbuf);
		    }
		  }
		
		/*
		 *	For a SNAP, ONLY move the one angle (omega or phi)
		 *	which is in motion (stat_axis).  If the goniostat has
		 *	an omega, ALL snapshots are in omega, else in phi.
		 */
		
		if(doing_snapshot == 1)
		  {
		    if(stat_axis == 1)
		      {
			strcpy(stat_scanner_op,"moving phi");
			sprintf(tempbuf,"phi_move %10.3f",mdccp->cmd_col_phis);
			output_blcmd(fdblcmd,"cmd",tempbuf);
		      }
		     else
		      {
		        strcpy(stat_scanner_op,"moving omega");
		        sprintf(tempbuf,"omega_move %10.3f",mdccp->cmd_col_omegas);
		        output_blcmd(fdblcmd,"cmd",tempbuf);
		      }
		  }

		dc_stop = 0;

		if(mdccp->cmd_col_blcmd[0] != '\0')
		  {
		    bline_ret = output_blcmd(fdblcmd,"before",mdccp->cmd_col_blcmd);
		    switch (bline_ret) {
		      case CCD_BL_NOTCONNECTED:
		      case CCD_BL_DISCONNECTED:
			dc_stop = 1;
			sprintf(message[0]," CCD_BL_NOTCONNECTED");
			issue_signal("CCD_BL_DROPPED",message);
	                set_alert_msg("ERROR: Beamline control not connected.");
		  	break;
		      case CCD_BL_FATAL:
			dc_stop = 1;
			if(pf_mod)
			{
				sprintf(tempbuf,"lockout_external 0");
				output_blcmd(fdblcmd,"cmd",tempbuf);
			}
		        break;
	              default:
		  	break;
		      }
		  }
		if(dc_stop == 1)
		  {
			dc_abort = 1;
			break;
		  }

		if(pf_mod)
		{
			sprintf(tempbuf,"lockout_external 1");
			output_blcmd(fdblcmd,"cmd",tempbuf);
		}

                //time(&now);
	        //fprintf(stdout,"ccd_dc_api: pitch_tune_delta: %d pitch_tune_last: %d now: %d\n",
                //        pitch_tune_delta,pitch_tune_last,now);

		if(pitch_tune_delta)
		{
			time(&now);

			if ((now - pitch_tune_last) > pitch_tune_delta) {
			   bline_ret = output_blcmd(fdblcmd,"cmd", "pitch_tune");
			   pitch_tune_last = now;
			   usleep(500000);
			}
		}
		collect_frame();
		if(doing_dark_current == 0)
		  {
		    if(stat_axis == 1)
		        stat_phi += stat_osc_width;
		     else
		        stat_omega += stat_osc_width;
		  }

		dcop = DCOP_COLLECT;

		tick = stat_time * 1000;
		tick_set();
		units = tick;
		decrement = 1000 * (1. / dt_stat);
		dc_abort = 0;
		dc_in_progress = 1;

		break;
	  }
  }

/*
 *	This routine monitors the progress of commands issued by
 *	ccd_hw_start.  In general, most functions are taken care
 *	of by other processes; the only complex commands are scan
 *	and collect.
 */

extern	char	det_reply[2048];

int	ccd_hw_progress(mdccp)
mdc_command	*mdccp;
  {
	char	tempbuf[2048],tbuf[2048],u3dig[4];
	char	prefix_used[20],xform_out_name[256];
	int	done,detret;
	int	timediff,new_time;
	int	bline_ret,i;
	float	kappa_angs[3],euler_angs[3];
	char	*ztime();
	time_t	now;
	char *message[80];

	done = 0;

        if(mdccp->cmd_no != MDC_COM_STARTUP)
          {
            if(fdblcmd == -1)
	      {
                done = 1;
                return(done);
	      }
          }

	switch(mdccp->cmd_no)
	  {
	    case MDC_COM_STARTUP:
	    case MDC_COM_INIT:
	    case MDC_COM_ERASE:
	    case MDC_COM_DSET:
	    case MDC_COM_PSET:
	    case MDC_COM_LSET:
	    case MDC_COM_WSET:
	    case MDC_COM_CONFIG:
	    case MDC_COM_SHUT:
	    case MDC_COM_DMOVE:
	    case MDC_COM_PMOVE:
	    case MDC_COM_PMOVEREL:
	    case MDC_COM_LMOVE:
	    case MDC_COM_WMOVE:
	    case MDC_COM_OMOVE:
	    case MDC_COM_OSET:
	    case MDC_COM_KMOVE:
	    case MDC_COM_KSET:
	    case MDC_COM_GONMAN:
	    case MDC_COM_HOME:
	    case MDC_COM_AMOVE:
	    case MDC_COM_AUTOALIGN:
            case MDC_COM_XL_HS_MOVE:
            case MDC_COM_XL_VS_MOVE:
            case MDC_COM_XL_UP_HHS_MOVE:
            case MDC_COM_XL_UP_VHS_MOVE:
            case MDC_COM_XL_DN_HHS_MOVE:
            case MDC_COM_XL_DN_VHS_MOVE:


		done = 1;
		break;

	    case MDC_COM_SCAN:
	    case MDC_COM_COLL:
	    case MDC_COM_SNAP:
                if(fddetcmd == -1 || fdxfcm == -1)
                  {
                    done = 1;
                    return(done);
                  }
		if(dc_abort)
		  {
		    done = 1;
		    dc_abort = 0;
		    break;
		  }

		detret = output_detcmd(fddetcmd,"stop\n",NULL,0);

		if(strip_ave)
		  {
			output_detcmd(fddetcmd,"getparam\nstrip_ave\n",NULL,0);
			if(NULL == (char *) strstr(det_reply,"OK"))
			    n_strip_ave = 0;
			  else
			    {
				n_strip_ave = sscanf(&det_reply[3],"%f %f %f %f",
					&strip_ave_vals[0],&strip_ave_vals[1],
					&strip_ave_vals[2],&strip_ave_vals[3]);
			    }
			fprintf(stdout,"output_detcmd: STRIPS        at %s: ",ztime());
			for(i = 0; i < n_strip_ave; i++)
			  fprintf(stdout,"%.3f ",strip_ave_vals[i]);
			fprintf(stdout,"\n");
			fflush(stdout);
		  }

		if(detret == CCD_DET_RETRY)
		  {
                    if (dc_stop == 1) {
		      done = 1;
		      dc_stop = 0;
		      break;
                    }
		    if(doing_dark_current == 0)
		      {
		        if(stat_axis == 1)
		          sprintf(tempbuf,"phi_move %10.3f",phi_value_saved);
		        else
		          sprintf(tempbuf,"omega_move %10.3f",omega_value_saved);
		        output_blcmd(fdblcmd,"cmd",tempbuf);
		      }
		    collect_frame();
		    if(doing_dark_current == 0)
		      {
		        if(stat_axis == 1)
		            stat_phi += stat_osc_width;
		         else
		            stat_omega += stat_osc_width;
		      }
		    break;
		  }
                else if (detret == CCD_DET_NOTCONNECTED) {
                  dc_stop = 1;
		  sprintf(message[0]," ccd_hw_progress");
		  issue_signal("CCD_SIG_DET_DROPPED",message);
                  set_alert_msg("ERROR: Detector control not connected.");
                }
		else if (detret == CCD_DET_FATAL){
		  dc_stop = 1;
		}

		send_copy_command();

	        if(gl_blret == CCD_BL_RETRY)
		  {
                    if (dc_stop == 1) 
		      {
		        done = 1;
		        dc_stop = 0;
		        break;
                      }

		    /*
		     *	This logic assumes that the goniostat device (Mar 300 base comes to mind)
		     *	is actually "continuing" the exposure through the requested time interval.
		     *	Hence we need to wait for the "rest" of the exposure to finish before actually
		     *	continuing with the steps below.
		     */

	            strcpy(stat_scanner_op,"Idling_rest_of_short_exp");

#ifdef X8C
		    short_exposure_stall(exposure_short_by,fdblcmd);
#endif /* X8C */

		    if(stat_axis == 1)
		      sprintf(tempbuf,"phi_move %10.3f",phi_value_saved);
		     else
		      sprintf(tempbuf,"omega_move %10.3f",omega_value_saved);
		    output_blcmd(fdblcmd,"cmd",tempbuf);
		    collect_frame();
		    if(stat_axis == 1)
		        stat_phi += stat_osc_width;
		     else
		        stat_omega += stat_osc_width;
		    break;
		  }
		if(dc_stop == 1)
		  {
		    output_detcmd(fddetcmd,"flush\n",NULL,0);
		    done = 1;
		    dc_stop = 0;
		    fprintf(stdout,"ccd_dc_api: User requested STOP.  Exposures terminating.\n");
		    if(doing_dark_current && double_exp_ctr == 2)
		    	current_darkcurrent_time = 0;
		    break;
		  }

		if(doing_dark_current)
		  {
		    double_exp_ctr--;
		    if(double_exp_ctr > 0)
			collect_frame();
		     else if(doing_second_dk || stat_dzratio == 1.0)
		      {
			stat_time /= stat_dzratio;
			doing_dark_current = 0;
			if(double_exp_flag)
			    double_exp_ctr = 2;
			  else
			    double_exp_ctr = 1;
			collect_frame();
		      }
		      else if(stat_dzratio != 1.0)
			{
			  stat_time *= stat_dzratio;
			  double_exp_ctr = 2;
			  doing_second_dk = 1;
			  collect_frame();
			}
		    break;
		  }

		if(mdccp->cmd_col_blcmd[0] != '\0')
		  {
		    bline_ret = output_blcmd(fdblcmd,"during",mdccp->cmd_col_blcmd);
		    switch (bline_ret) {
		      case CCD_BL_FATAL:
			dc_stop = 1;
		        break;
		      case CCD_BL_NOTCONNECTED:
		      case CCD_BL_DISCONNECTED:
			dc_stop = 1;
			sprintf(message[0]," after scan");
			issue_signal("CCD_BL_DROPPED",message);
	                set_alert_msg("ERROR: Beamline control not connected.");
		  	break;
	              default:
		  	break;
		      }
		  }
		if(dc_stop == 1)
		  {
			dc_abort = 1;
		        output_detcmd(fddetcmd,"flush\n",NULL,0);
		        done = 1;
		    	dc_stop = 0;
			break;
		  }
		double_exp_ctr--;
		if(double_exp_ctr == 0)
		  {
		    stat_time = mdccp->cmd_col_time;
		    if(double_exp_flag == 1)
			double_exp_ctr = 2;
		     else
			double_exp_ctr = 1;
		    stat_image_number++;
		    if(stat_axis == 1)
		      {
		        phi_value_saved += mdccp->cmd_col_osc_width;
			if(constrain_phi != 180) {
			if(phi_value_saved >= 360.)
				phi_value_saved -= 360.;
			} else {
			if(phi_value_saved >= 180.)
				phi_value_saved -= 180.;
			}

		      }
		    else
		      {
		        omega_value_saved += mdccp->cmd_col_osc_width;
			if(constrain_omega != 180) {
			if(omega_value_saved >= 360.)
				omega_value_saved -= 360.;
			} else {
			if(omega_value_saved >= 180.)
				omega_value_saved -= 180.;
			}
		      }
		    if(repeat_dark_current)
		      {
			time((time_t *) &new_time);
			timediff = new_time - dark_current_time;
			if(timediff > dark_current_interval)
			  {
				doing_dark_current = 1;
				doing_second_dk = 0;
				double_exp_ctr = 2;
				dark_current_time = new_time;
			  }
		      }
		    get_next_image_from_runfile(mdccp);
		  }
		 else
		  {
		    stat_time = mdccp->cmd_col_time * stat_dzratio;
		    if(stat_axis == 1)
		      sprintf(tempbuf,"phi_move %10.3f",phi_value_saved);
		    else
		      sprintf(tempbuf,"omega_move %10.3f",omega_value_saved);
		    output_blcmd(fdblcmd,"cmd",tempbuf);
		  }

		if(totimg == 0 || dc_stop == 1)
		  {
			output_detcmd(fddetcmd,"flush\n",NULL,0);
			done = 1;
			dc_stop = 0;
			if(mdccp->cmd_col_blcmd[0] != '\0')
			  {
			    bline_ret = output_blcmd(fdblcmd,"after",mdccp->cmd_col_blcmd);
			    switch (bline_ret) {
			      case CCD_BL_FATAL:
				dc_stop = 1;
			        break;
			      case CCD_BL_NOTCONNECTED:
			      case CCD_BL_DISCONNECTED:
				dc_stop = 1;
				sprintf(message[0]," ccd_dc_hw 3");
				issue_signal("CCD_SIG_BL_DROPPED",message);
		                set_alert_msg("ERROR: Beamline control not connected.");
			  	break;
		              default:
			  	break;
			      }
			  }
			if(dc_stop == 1)
			  {
			        done = 1;
			    	dc_stop = 0;
				break;
			  }
			break;
		  }

		if(pitch_tune_delta)
		{
			time(&now);

			if ((now - pitch_tune_last) > pitch_tune_delta) {
			   bline_ret = output_blcmd(fdblcmd,"cmd", "pitch_tune");
			   pitch_tune_last = now;
			   usleep(500000);
			}
		}
		collect_frame();
		if(doing_dark_current == 0)
		  {
		    if(stat_axis == 1)
		        stat_phi += stat_osc_width;
		     else
		        stat_omega += stat_osc_width;
		  }

		tick_set();
		tick = stat_time * 1000;
		units = tick;
		decrement = 1000 * (1. / dt_stat);
		totpass = stat_n_passes;

		break;
	  }

	if(done == 1)
	  {
		strcpy(stat_scanner_msg,"");
		strcpy(stat_scanner_op,"");
		strcpy(stat_scanner_control,"idle");
		dc_in_progress = 0;
		if(pf_mod && (mdccp->cmd_no == MDC_COM_COLL || (mdccp->cmd_no == MDC_COM_SNAP)))
		{
			sprintf(tempbuf,"lockout_external 0");
			output_blcmd(fdblcmd,"cmd",tempbuf);
		}
	  }
	return (done);
  }

ccd_hw_initial_status()
  {
	stat_start_phi = 0.;
	stat_start_omega = 0.;
	stat_start_kappa = 0.;
	stat_axis = 1;
	stat_osc_width = 1.0;
	stat_n_images = 1;
	stat_n_passes = 1;
	stat_n_ccd_updates = 0;
	stat_time = 30;
	stat_dir[0] = '\0';
	stat_fname[0] = '\0';
	strcpy(stat_scanner_op,"none");
	stat_scanner_msg[0] = '\0';
	strcpy(stat_scanner_control,"idle");
	strcpy(stat_scanner_shutter,"closed");
  }

