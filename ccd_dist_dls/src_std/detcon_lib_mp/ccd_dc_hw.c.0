#include	"detcon_ext.h"

/*
 *----------------------------------------------
 *
 *	Module to sequence the control of the CCD
 *	hardware modules.
 *
 *	Two processes are used to run hardware:
 *		ccd_det		controls the detector.
 *		ccd_bl		controls the beamline.
 *
 *	In this implimentation, it is assumed that
 *	ccd_bl controls all hardware EXCEPT the detector.
 *
 *----------------------------------------------
 */

/*
 *	Routines to accurately calculate the
 *	time commands take to execute.  This
 *	is for the completeness statistics, for
 *	the most part, and does not actually
 *	alter functionality.
 */

static	time_t	tick_clock_val;

/*
 *	Turn an integer into xxx.  Used in image numbers.
 */

static void util_3digit(s1,val)
char	*s1;
int	val;
  {
	int	i,j;

	i = val;
	j = i / 100;
	*s1++ = (char ) ('0' + j);
	i = i - 100 * j;
	j = i / 10;
	*s1++ = (char ) ('0' + j);
	i = i - 10 * j;
	*s1++ = (char ) ('0' + i);
	*s1++ = '\0';
  }
tick_set()
  {
	time(&tick_clock_val);
  }

int	tick_diff()
  {
	time_t	current_clock_val;
	int	diff_in_secs;

	time(&current_clock_val);
	diff_in_secs = ((int) current_clock_val) - ((int) tick_clock_val);
	tick_clock_val = current_clock_val;
	return(diff_in_secs);
  }

/*
 *	Operation codes for the initialize command.
 *
 *	These are software state variables to keep
 *	track of which initialize phase the program
 *	is doing.
 */

#define	INITOP_ABORT	0
#define	INITOP_RESET	1
#define	INITOP_SHUTTER	2
#define	INITOP_LOADTAB	3
#define	INITOP_DISTANCE	4

int	init_op;

/*
 *	Operation codes for the data collection command.
 *
 *	These are purely software states so the program
 *	can keep track of what part of data collection it
 *	is doing.
 */

#define	DCOP_COLLECT	0
#define	DCOP_SCAN	1
#define	DCOP_ERASE	2
#define	DCOP_RECRESET	3
#define	DCOP_RECERASE	4
#define	DCOP_RECSHUTTER	5

int	active_trans = 0;
int	scan_readout_in_progress = 0;	/* used to make sure we don't step on scan readout in progress */
int	scan_abort_readout = 0;		/* 1 to cause scan_readout to abort and close its files */

/*
 *	These are used to check to see if distance
 *	or phi actually move, and are used in conjunction
 *	with active_trans above.
 */

double	phi_value_saved;	/* value before a move */
double	omega_value_saved;	/* value before a move */
int	dist_value_saved;	/* value before a move */
int     lift_value_saved;
int	phi_no_motion;		/* 1 if no motion was initiated */
int     dist_no_motion;         /* 1 if no motion was initiated */
int     lift_no_motion;         /* 1 if no motion was initiated */

int	shutter_retry;		/* used to keep track for shutter errors */
int	collect_counter;	/* used to make sure we check c_error for collect */
int	reset_counter;		/* used to make sure we wait long enough */
int	init_dist_ctr;		/* used to make sure we wait long enough */
int	double_exp_flag;	/* 1 to do two exposures per actual image */
int	double_exp_ctr;		/* used to toggle double exposures */
int	doing_dark_current;	/* 1 if doing dark current exposures */
int	doing_second_dk;	/* 1 if doing second dark current */
int	doing_snapshot;		/* 1 if doing a shapshot */

int	goniostat_type = 0;	/* 0 for phi only, 1 for Eulerian, 2 for Kappa */
int	wedge_count;		/* used for counting down in a wedge */
int	wedge_side;		/* 0 if doing the primary run, 1 if doing the bijvoet */
int	wedge_run;		/* which_run is being collected */
int	wedge_imno;
int	wedge_size;
float	wedge_omega;
float	wedge_phi;
float	wedge_kappa;
char	wedge_prefix[256];	/* temp holding tank for prefix */

float	current_darkcurrent_time = 0;	/* keeps track of the length of the current dark current image */

/*
 *	make_header_smv  -  make a suitable SMV header.
 */

#define	SHDSIZE		20480

char	made_header[SHDSIZE];

make_header_smv()
  {
	char	buf[32];
	int	i;
	char	*cptr;
	char	*ztime();

	clrhd(made_header);

	/*
	 *	standard items.
	 */
	
	puthd("DIM","2",made_header);

#if defined(alpha) || defined(linux)
	puthd("BYTE_ORDER","little_endian",made_header);
#else
	puthd("BYTE_ORDER","big_endian",made_header);
#endif /* alpha */

	puthd("TYPE","unsigned_short",made_header);

	if(stat_bin == 1)
	  {
	    puthd("SIZE1","1152",made_header);
	    puthd("SIZE2","1152",made_header);
	    sprintf(buf,"%6.4f",pixel_size);
	    puthd("PIXEL_SIZE",buf,made_header);
	    puthd("BIN","none",made_header);
	  }
	 else
	  {
	    puthd("SIZE1","576",made_header);
	    puthd("SIZE2","576",made_header);
	    sprintf(buf,"%6.4f",pixel_size * 2);
	    puthd("PIXEL_SIZE",buf,made_header);
	    puthd("BIN","2x2",made_header);
	  }
	if(stat_adc == 0)
	    puthd("ADC","slow",made_header);
	  else
	    puthd("ADC","fast",made_header);
	if(0)
	{
	for(i = 0; i < n_ctrl; i++)
	  {
		sprintf(buf,"CCD_OFFSET%d",i);
		puthd(buf,"xx",made_header);
	  }
	}
	/*
	 *	adsc items.
	 */
	if(detector_sn > 0)
	  {
		sprintf(buf,"%d",detector_sn);
		puthd("DETECTOR_SN",buf,made_header);
	  }
	cptr = ztime();
	puthd("DATE",cptr,made_header);
	sprintf(buf,"%.2f",stat_time);
	puthd("TIME",buf,made_header);
	sprintf(buf,"%.3f",stat_dist);
	puthd("DISTANCE",buf,made_header);
	sprintf(buf,"%.3f",stat_osc_width);
	puthd("OSC_RANGE",buf,made_header);
	if(stat_axis == 1)
	  {
	    if(is_kappa)
	      {
		sprintf(buf,"%.3f",phi_value_saved);
		puthd("PHI",buf,made_header);
		puthd("OSC_START",buf,made_header);
		sprintf(buf,"%.3f",stat_omega);
		puthd("OMEGA",buf,made_header);
	        sprintf(buf,"%.3f",stat_kappa);
	        puthd("KAPPA",buf,made_header);
	      }
	     else
	      {
		sprintf(buf,"%.3f",phi_value_saved);
		puthd("PHI",buf,made_header);
		puthd("OSC_START",buf,made_header);
	      }
	  }
	 else
	  {
	    if(is_kappa)
	      {
		sprintf(buf,"%.3f",omega_value_saved);
		puthd("OMEGA",buf,made_header);
		puthd("OSC_START",buf,made_header);
		sprintf(buf,"%.3f",stat_phi);
		puthd("PHI",buf,made_header);
	        sprintf(buf,"%.3f",stat_kappa);
	        puthd("KAPPA",buf,made_header);
	      }
	     else
	      {
		sprintf(buf,"%.3f",phi_value_saved);
		puthd("PHI",buf,made_header);
		puthd("OSC_START",buf,made_header);
	      }
	  }
	if(is_2theta)
	  {
	    sprintf(buf,"%.3f",stat_2theta);
	    puthd("TWOTHETA",buf,made_header);
	  }
	if(stat_axis == 1)
	    puthd("AXIS","phi",made_header);
	  else
	    puthd("AXIS","omega",made_header);
	sprintf(buf,"%.4f",stat_wavelength);
	puthd("WAVELENGTH",buf,made_header);
	sprintf(buf,"%.3f",beam_xcen);
	puthd("BEAM_CENTER_X",buf,made_header);
	sprintf(buf,"%.3f",beam_ycen);
	puthd("BEAM_CENTER_Y",buf,made_header);
        if(doing_dark_current)
                sprintf(buf,"%d",doing_second_dk * 2 + 2 - double_exp_ctr);
          else
            {
                if(double_exp_flag)
                        sprintf(buf,"%d",4 + 2 - double_exp_ctr);
                    else
                        strcpy(buf,"5");
            }
	padhd(made_header,512);
  }

/*
 *	Routine to send the start detector exposing command.  Main purpose
 *	here is to build up filenames.
 */

send_det_start()
  {
	char	tempbuf[1024],tbuf[1024],infobuf[512];
	char	im_3dig[4];
	char	suffix[20];
	int	hsize;
        int  detret;
	double	tmp;

	
	make_header_smv();
	gethdl(&hsize, made_header);

	sprintf(tempbuf,"start\nheader_size %d\n",hsize);

	if(doing_dark_current)
		sprintf(suffix,"dkx_%d",doing_second_dk * 2 + 2 - double_exp_ctr);
	  else
	    {
		if(double_exp_flag)
			sprintf(suffix,"imx_%d",2 - double_exp_ctr);
		    else
			sprintf(suffix,"imx_0");
	    }
	util_3digit(im_3dig,stat_image_number);
	sprintf(infobuf,"info %s_%s.%s\n",stat_prefix,im_3dig,suffix);

	if(stat_bin == 1)
	    strcat(tempbuf,"row_xfer 1152\ncol_xfer 1152\n");
	  else
	    strcat(tempbuf,"row_xfer 576\ncol_xfer 576\n");

	if(use_pc_shutter)
	  {
	    if(doing_dark_current == 0)
	      strcat(tempbuf,"pcshutter 1\n");
	     else
	      strcat(tempbuf,"pcshutter 0\n");
	  }
	if(use_j5_trigger)
	      strcat(tempbuf,"j5_trigger 1\n");
	if(use_timecheck)
	      strcat(tempbuf,"timecheck 1\n");

	strcat(tempbuf,infobuf);
	sprintf(tbuf,"adc %d\nrow_bin %d\ncol_bin %d\ntime %f\n",stat_adc,stat_bin,stat_bin,stat_time);
	strcat(tempbuf,tbuf);

	detret = output_detcmd(dtc_fddetcmd,tempbuf,made_header,hsize);
        if (detret == CCD_DET_NOTCONNECTED) {
          dc_stop = 1;
          set_alert_msg("ERROR: Detector control not connected.");
        }
  }

/*
 *	Routine to send the start beam line exposing command.  Main purpose
 *	here is to build up filenames.
 */

send_bl_start()
  {
	char	tempbuf[1024],tbuf[1024];
	char	im_3dig[4];
	char	suffix[20];
	double	tmp;
	int 	bline_ret;
	char	*ztime();

	if(doing_dark_current)
		sprintf(suffix,"dkc(%d)",doing_second_dk * 2 + 2 - double_exp_ctr);
	  else
	    {
		if(double_exp_flag)
			sprintf(suffix,"img(%d)",2 - double_exp_ctr);
		    else
			sprintf(suffix,"img");
	    }

	if(stat_axis == 1)
		tmp = phi_value_saved;
	    else
		tmp = omega_value_saved;
	sprintf(tempbuf,"collect\ntime %10.2f\ndistance %10.2f\nosc_width %10.2f\nphi_start %10.2f\n",
		stat_time,stat_dist,stat_osc_width,tmp);
	sprintf(tbuf,"wavelength %6.4f\ndirectory %s\nimage_prefix %s\nimage_suffix %s\nimage_number %d\n",
		stat_wavelength,stat_dir,stat_prefix,suffix,stat_image_number);
	strcat(tempbuf,tbuf);

	/*
	 *	To simplify for (older) software which does not support multiple axes, if
	 *	the data collection is not omega, omit the axis specification.
	 */

	if(stat_axis == 0)
		strcat(tempbuf,"axis 0\n");

	if(doing_dark_current)
	  strcat(tempbuf,"mode darkcurrent_dc\n");
         else {
             if (stat_mode == 1) {
               sprintf (tbuf,"mode dose\nstep_size %f\ndose_per_step %f\n",
                stat_step_size, stat_dose_step);
               strcat(tempbuf,tbuf);
             }
             else {
             strcat(tempbuf,"mode beamline_dc\n");
             }
           }

	sprintf(tbuf,"adc %d\nbin %d\n",stat_adc,stat_bin);
	strcat(tempbuf,tbuf);
	util_3digit(im_3dig,stat_image_number);
	fprintf(stderr,"send_bl_start: START         at %s: %s_%s.%s\n",ztime(),stat_prefix,im_3dig,suffix);

	bline_ret = output_blcmd(dtc_fdblcmd,"cmd",tempbuf);
	switch (bline_ret) {
	  case CCD_BL_FATAL:
		dc_stop = 1;
	  break;
	  case CCD_BL_NOTCONNECTED:
	  case CCD_BL_DISCONNECTED:
		dc_stop = 1;
                set_alert_msg("ERROR: Beamline control not connected.");
/* printf ("no beamline\n"); */
	  break;
          default:
	  break;
	}
  }

send_copy_command()
  {
	int	len_xfcmd;
	char	xfcmd_buf[512];
        char    num[4];
        int     i,kind,raw_end;
	char	suffix[20],raw_suffix[20];
	char	body[512];
	char	dzstuff[100];
	int	hsize;
	int	xysize;

	gethdl(&hsize, made_header);

	if(stat_bin == 1)
		xysize = 1152;
	    else
		xysize = 576;

	if(raw_ccd_image == 1)
	  sprintf(body,
 "copy\nreply 0\nrow_mm %f\ncol_mm %f\ndist_mm %f\ntwo_theta %f\nheader_size %d\nrow_xfer %d\ncol_xfer %d\nrow_bin %d\ncol_bin %d\n",
		beam_xcen,beam_ycen,stat_dist,stat_2theta,hsize,xysize,xysize,stat_bin,stat_bin);
	 else
	  sprintf(body,
 "xform\nreply 0\nrow_mm %f\ncol_mm %f\ndist_mm %f\ntwo_theta %f\nheader_size %d\nrow_xfer %d\ncol_xfer %d\nrow_bin %d\ncol_bin %d\n",
		beam_xcen,beam_ycen,stat_dist,stat_2theta,hsize,xysize,xysize,stat_bin,stat_bin);

	if(stat_compress == 1)
		strcat(body,"compress 1\n");
	    else
		strcat(body,"compress 0\n");
	if(detector_sn > 0)
	  {
		sprintf(dzstuff,"detector_sn %d\n",detector_sn);
		strcat(body,dzstuff);
	  }
	if(strip_ave)
	  {
		if(n_strip_ave == 4)
		  sprintf(dzstuff,"strip_ave %.3f_%.3f_%.3f_%.3f\n",strip_ave_vals[0],strip_ave_vals[1],
								    strip_ave_vals[2],strip_ave_vals[3]);
		 else
		  sprintf(dzstuff,"strip_ave %.3f\n",strip_ave_vals[0]);
		strcat(body,dzstuff);
	  }
	sprintf(dzstuff,"save_raw %d\n",output_raws);
	strcat(body,dzstuff);

	if(doing_dark_current)
	  {
	    if(doing_second_dk == 0)
	    	strcpy(suffix,"dkc");
	      else
		strcpy(suffix,"dkd");

	    strcpy(raw_suffix,"dkx");
	    kind = 2 * doing_second_dk + 2 - double_exp_ctr;
	    raw_end = kind;
	  }
	 else
	  {
	    strcpy(suffix,"img");
	    strcpy(raw_suffix,"imx");
	    if(double_exp_flag)
	      {
	        kind = 4 + 2 - double_exp_ctr;
		raw_end = 2 - double_exp_ctr;
		sprintf(dzstuff,"dzratio %f\n",stat_dzratio);
		strcat(body, dzstuff);
	      }
	     else
	      {
	        kind = 5;
		raw_end = 0;
	      }
	  }

	sprintf(dzstuff,"outfile_type %d\n",outfile_type);
	strcat(body,dzstuff);

        i = stat_image_number;
        num[0] = '0' + i / 100;
        i = i - 100 * (i / 100);
        num[1] = '0' + i / 10;
        i = i - 10 * (i / 10);
        num[2] = '0' + i;
        num[3] = '\0';

	if(-1 == dtc_fdxfcm)
	  {
		fprintf(stderr,"detcon_server: xform command file is NOT connected.\n");
		fprintf(stderr,"detcon_server: currently, THIS IS A WARNING\n");
	  }
	 else
	  {
		sprintf(xfcmd_buf,"%sinfile <socket>\noutfile %s%s_%s.%s\nrawfile %s%s_%s.%s_%d\nkind %d\n",
			body,stat_dir,stat_prefix,num,suffix,stat_dir,stat_prefix,num,raw_suffix,raw_end,kind);
		strcat(xfcmd_buf,"end_of_det\n");
		len_xfcmd = strlen(xfcmd_buf);
		if(len_xfcmd != detcon_rep_write(dtc_fdxfcm,xfcmd_buf,len_xfcmd))
		  {
			fprintf(stderr,"detcon_server: xform process has disconnected.\n");
			fprintf(stderr,"detcon_server: currently, THIS IS A WARNING.\n");
			detcon_notify_server_eof(dtc_fdxfcm);
		  }
	  }
  }

/*
 *	ccd_hw_start:
 *
 *	This is where all commands to the ccd detector system
 *	begin execution.
 *
 *	ccd_hw_start will begin the sequencing of possibly
 *	complex commands, splitting their functions between
 *	calls to the beamline control and detector control
 *	processes.
 */

void	ccd_hw_start(mdccp)
mdc_command	*mdccp;
  {
	int	current,wanted,nsteps_to_move;
	int	i,j,need_new_dk;
	char	tempfname[256];
	char	tempbuf[2048],tbuf[2048];
	int	bline_ret;
	int	ccd_hw_progress();

	double	fabs();

	active_trans = 0;

	strcpy(stat_scanner_control,"active");

	switch(mdccp->cmd_no)
	  {
	    case MDC_COM_STARTUP:
		break;
	    case MDC_COM_INIT:

		strcpy(stat_scanner_op,"initializing");
		output_blcmd(dtc_fdblcmd,"cmd","initialize");

		break;

	    case MDC_COM_ERASE:

		break;

	    case MDC_COM_CONFIG:

		break;

	    case MDC_COM_DSET:

		strcpy(stat_scanner_op,"setting distance");
		sprintf(tempbuf,"distance_set %10.2f",mdccp->cmd_value);
		output_blcmd(dtc_fdblcmd,"cmd",tempbuf);
		stat_dist = mdccp->cmd_value;

		break;

	    case MDC_COM_PSET:

		strcpy(stat_scanner_op,"setting phi");
		sprintf(tempbuf,"phi_set %10.2f",mdccp->cmd_value);
		output_blcmd(dtc_fdblcmd,"cmd",tempbuf);
		stat_phi = mdccp->cmd_value;

		break;

	    case MDC_COM_OSET:

		strcpy(stat_scanner_op,"setting omega");
		sprintf(tempbuf,"omega_set %10.2f",mdccp->cmd_value);
		output_blcmd(dtc_fdblcmd,"cmd",tempbuf);
		stat_omega = mdccp->cmd_value;

		break;

	    case MDC_COM_KSET:

		strcpy(stat_scanner_op,"setting kappa");
		sprintf(tempbuf,"kappa_set %10.2f",mdccp->cmd_value);
		output_blcmd(dtc_fdblcmd,"cmd",tempbuf);
		stat_kappa = mdccp->cmd_value;

		break;

	    case MDC_COM_LSET:

		delta = mdccp->cmd_value;
		strcpy(stat_scanner_op,"setting lift");
		sprintf(tempbuf,"lift_set %10.2f",mdccp->cmd_value);
		output_blcmd(dtc_fdblcmd,"cmd",tempbuf);
		stat_lift = delta;

		break;

	    case MDC_COM_SHUT:

		strcpy(stat_scanner_op,"Shutter control");
		if(use_pc_shutter == 0)
		{
		if(mdccp->cmd_value != 0)
		  {
			strcpy(stat_scanner_shutter,"open");
			strcpy(tempbuf,"shutter 1");
		  }
		 else
		  {
			strcpy(stat_scanner_shutter,"closed");
			strcpy(tempbuf,"shutter 0");
		  }
		output_blcmd(dtc_fdblcmd,"cmd",tempbuf);
		} else {
		    if(mdccp->cmd_value != 0)
		      {
			strcpy(stat_scanner_shutter,"open");
			strcpy(tempbuf,"shutter\npcshutter 1\n");
		      }
		     else
		      {
			strcpy(stat_scanner_shutter,"closed");
			strcpy(tempbuf,"shutter\npcshutter 0\n");
		      }
		    output_detcmd(dtc_fddetcmd,tempbuf,NULL,0);
		    /*
		     *	This is prurely cosmetic:  This gets the
		     *	shutter status properly set via the beamline
		     *	process, which does not actually do anything
		     *	BUT set this status.
		     */
		    if(mdccp->cmd_value != 0)
		      {
			strcpy(stat_scanner_shutter,"open");
			strcpy(tempbuf,"shutter 1");
		      }
		     else
		      {
			strcpy(stat_scanner_shutter,"closed");
			strcpy(tempbuf,"shutter 0");
		      }
		    output_blcmd(dtc_fdblcmd,"cmd",tempbuf);
		  }



		break;

	    case MDC_COM_SCAN:

		break;

	    case MDC_COM_DMOVE:

		strcpy(stat_scanner_op,"moving distance");
		sprintf(tempbuf,"distance_move %10.2f",mdccp->cmd_value);
		output_blcmd(dtc_fdblcmd,"cmd",tempbuf);

		break;

	    case MDC_COM_LMOVE:

		strcpy(stat_scanner_op,"moving lift");
		sprintf(tempbuf,"lift_move %10.2f",mdccp->cmd_value);
		output_blcmd(dtc_fdblcmd,"cmd",tempbuf);

		break;

	    case MDC_COM_PMOVE:

		strcpy(stat_scanner_op,"moving phi");
		sprintf(tempbuf,"phi_move %10.2f",mdccp->cmd_value);
		output_blcmd(dtc_fdblcmd,"cmd",tempbuf);

		break;

	    case MDC_COM_PMOVEREL:

		strcpy(stat_scanner_op,"moving phi");
		sprintf(tempbuf,"phi_move_rel %10.2f",mdccp->cmd_value);
		output_blcmd(dtc_fdblcmd,"cmd",tempbuf);

		break;

	    case MDC_COM_OMOVE:

		strcpy(stat_scanner_op,"moving omega");
		sprintf(tempbuf,"omega_move %10.2f",mdccp->cmd_value);
		output_blcmd(dtc_fdblcmd,"cmd",tempbuf);

		break;

	    case MDC_COM_KMOVE:

		strcpy(stat_scanner_op,"moving kappa");
		sprintf(tempbuf,"kappa_move %10.2f",mdccp->cmd_value);
		output_blcmd(dtc_fdblcmd,"cmd",tempbuf);

		break;

	    case MDC_COM_GONMAN:

		strcpy(stat_scanner_op,"Goniostat in Manual Mode");
		sprintf(tempbuf,"gon_manual %10.2f",mdccp->cmd_value);
		output_blcmd(dtc_fdblcmd,"cmd",tempbuf);

		break;

	    case MDC_COM_HOME:

		strcpy(stat_scanner_op,"Homing Goniostat Angles");
		sprintf(tempbuf,"home");
		output_blcmd(dtc_fdblcmd,"cmd",tempbuf);

		break;

	    case MDC_COM_COLL:
	    case MDC_COM_SNAP:

		stat_2theta = 0;	/* DEBUG  -  MUST FIX */

		if(mdccp->cmd_no == MDC_COM_SNAP)
			doing_snapshot = 1;
	         else
			doing_snapshot = 0;
		need_new_dk = 0;
		phi_speed_used = phi_top_speed;

		stat_time = mdccp->cmd_col_time;

		stat_start_phi = mdccp->cmd_col_phis;
		stat_start_omega = mdccp->cmd_col_omegas;
		stat_start_kappa = mdccp->cmd_col_kappas;
		stat_axis = mdccp->cmd_col_axis;
		phi_value_saved = stat_start_phi;
		omega_value_saved = stat_start_omega;
		stat_omega = stat_start_omega;
		stat_phi = stat_start_phi;
		stat_kappa = stat_start_kappa;

		stat_osc_width = mdccp->cmd_col_osc_width;
		stat_n_images = mdccp->cmd_col_n_images;
		stat_n_passes = mdccp->cmd_col_n_passes;
		stat_image_number = mdccp->cmd_col_image_number;

		stat_compress = mdccp->cmd_col_compress;
		stat_anom = mdccp->cmd_col_anom;
		stat_wedge = mdccp->cmd_col_wedge;
		if(mdccp->cmd_col_dzratio != -1)
			stat_dzratio = mdccp->cmd_col_dzratio;
		if(mdccp->cmd_col_dkinterval != -1)
			dark_current_interval = mdccp->cmd_col_dkinterval;
		if(mdccp->cmd_col_rep_dark != -1)
			repeat_dark_current = mdccp->cmd_col_rep_dark;
		if(mdccp->cmd_col_dk_before != -1)
			dk_before_run = mdccp->cmd_col_dk_before;
		if(mdccp->cmd_col_outfile_type != -1)
			outfile_type = mdccp->cmd_col_outfile_type;
		if(mdccp->cmd_col_no_transform != -1)
		  {
			no_transform = mdccp->cmd_col_no_transform;
			raw_ccd_image = no_transform;
		  }
		if(mdccp->cmd_col_output_raws != -1)
			output_raws = mdccp->cmd_col_output_raws;
		if(stat_n_images > stat_wedge)
		    wedge_size = stat_wedge;
		  else
		    wedge_size = stat_n_images;

		if(stat_n_passes == 2)
			double_exp_flag = 1;
		  else
			double_exp_flag = 0;
		strcpy(stat_dir,mdccp->cmd_col_dir);
		strcpy(stat_prefix,mdccp->cmd_col_prefix);
		if(stat_adc != mdccp->cmd_col_adc || stat_bin != mdccp->cmd_col_bin)
		    need_new_dk = 1;
		if(dk_before_run)
		    need_new_dk = 1;
		if(need_new_dk)
		    time((time_t *) &dark_current_time);

		stat_adc = mdccp->cmd_col_adc;
		stat_bin = mdccp->cmd_col_bin;

		if(stat_anom)	/* for anomalous, we need to figure out the goniostat type */
		  {
		    if(is_kappa)
		      {
		        goniostat_type = 2;
			wedge_kappa = stat_start_kappa;
			wedge_omega = stat_start_omega;
			wedge_phi =   stat_start_phi;
			kappa_init(50.0);
		      }
		     else
		      {
		        goniostat_type = 0;
			wedge_phi =   stat_start_phi;
		      }
		    wedge_count = wedge_size;
		    wedge_side = 0;
		    j = strlen(stat_prefix);
		    for(i = j - 1; i >= 0; i--)
		      if(stat_prefix[i] == '_')
			break;
		    wedge_run = atoi(&stat_prefix[i+1]);
		    wedge_imno = stat_image_number;
		    for(j = 0; j < i; j++)
		      wedge_prefix[j] = stat_prefix[j];
		    wedge_prefix[j] = '\0';
		  }

		if(doing_snapshot == 0)
		  {
		    beam_xcen = mdccp->cmd_col_xcen;
		    beam_ycen = mdccp->cmd_col_ycen;
		  }
		totimg = stat_n_images;
		totpass = stat_n_passes;
		stat_mode = mdccp->cmd_col_mode;

		if(stat_n_passes == 2)
		  {
		    double_exp_flag = 1;
		    double_exp_ctr = 2;
		  }
		 else
		  {
		    double_exp_flag = 0;
		    double_exp_ctr = 1;
		  }

		if(mdccp->cmd_no == MDC_COM_COLL)
		  {
		    if(mdccp->cmd_col_newdark == 1 || need_new_dk == 1 || stat_time != current_darkcurrent_time)
		      {
			doing_dark_current = 1;
			doing_second_dk = 0;
			double_exp_ctr = 2;
			current_darkcurrent_time = stat_time;
		      }
		     else
			doing_dark_current = 0;
		    if(repeat_dark_current)
		      {
			fprintf(stderr,"detcon_server: informational: dark currents will be repeated\n");
			fprintf(stderr,"detcon_server:                every %d seconds.\n",dark_current_interval);
		      }
		  }
		 else	/* snapshot with no recalc'd dark current */
		  {
		    if(need_new_dk == 1)
		      {
			doing_dark_current = 1;
			doing_second_dk = 0;
			current_darkcurrent_time = stat_time;
		      }
		    doing_dark_current = 0;
		  }

		/*
		 *	On mad runs, issue the wavelength move commands.
		 */
		
		if(mdccp->cmd_col_mad_mode == 1)
		  {
		    strcpy(stat_scanner_op,"setting_wavelength");
		    sprintf(tempbuf,"wavelength_move %8.5f",mdccp->cmd_col_do_wavelength);
		    output_blcmd(dtc_fdblcmd,"cmd",tempbuf);
		  }
		/*
		 *	Always move/set the distance for SNAP and COLLECT.
		 */

		if(is_distance)
		  {
			strcpy(stat_scanner_op,"moving distance");
			sprintf(tempbuf,"distance_move %10.2f",mdccp->cmd_col_dist);
			output_blcmd(dtc_fdblcmd,"cmd",tempbuf);
		  }
		stat_dist = mdccp->cmd_col_dist;
		if(is_2theta && mdccp->cmd_col_lift != -9999.)
		  {
			if(0)
			{
			  fprintf(stdout,"detcon_server: Would move lift before run start\n");
			}
			else
			{
			strcpy(stat_scanner_op,"moving 2theta");
			sprintf(tempbuf,"lift_move %10.2f",mdccp->cmd_col_lift);
			output_blcmd(dtc_fdblcmd,"cmd",tempbuf);
			}
		  }
		stat_2theta = mdccp->cmd_col_lift;

		/*
		 *	For the three goniostat angles, move them if they
		 *	exist for COLLECT.  SNAP is handled below.
		 */

		if(is_phi && mdccp->cmd_col_phis != -9999.)
		  {
			if(0)
			{
			  fprintf(stdout,"detcon_server: Would move phi before run start\n");
			}
			else
			{
			strcpy(stat_scanner_op,"moving phi");
			sprintf(tempbuf,"phi_move %10.2f",mdccp->cmd_col_phis);
			output_blcmd(dtc_fdblcmd,"cmd",tempbuf);
			}
		  }

		if(is_omega && mdccp->cmd_col_omegas != -9999.)
		  {
		    if(0)
		    {
		      fprintf(stdout,"detcon_server: Would move omega before run start\n");
		    }
		    else
		    {
		    strcpy(stat_scanner_op,"moving omega");
		    sprintf(tempbuf,"omega_move %10.2f",mdccp->cmd_col_omegas);
		    output_blcmd(dtc_fdblcmd,"cmd",tempbuf);
		    }
		  }
		if(is_kappa && mdccp->cmd_col_kappas != -9999.)
		  {
		    if(0)
		    {
		      fprintf(stdout,"detcon_server: Would move kappa before run start\n");
		    }
		    else
		    {
		    strcpy(stat_scanner_op,"moving kappa");
		    sprintf(tempbuf,"kappa_move %10.2f",mdccp->cmd_col_kappas);
		    output_blcmd(dtc_fdblcmd,"cmd",tempbuf);
		    }
		  }
		
		/*
		 *	For a SNAP, ONLY move the one angle (omega or phi)
		 *	which is in motion (stat_axis).  If the goniostat has
		 *	an omega, ALL snapshots are in omega, else in phi.
		 */
		
		if(doing_snapshot == 1)
		  {
		    if(stat_axis == 1)
		      {
			strcpy(stat_scanner_op,"moving phi");
			sprintf(tempbuf,"phi_move %10.2f",mdccp->cmd_col_phis);
			output_blcmd(dtc_fdblcmd,"cmd",tempbuf);
		      }
		     else
		      {
		        strcpy(stat_scanner_op,"moving omega");
		        sprintf(tempbuf,"omega_move %10.2f",mdccp->cmd_col_omegas);
		        output_blcmd(dtc_fdblcmd,"cmd",tempbuf);
		      }
		  }

		dc_stop = 0;

		if(mdccp->cmd_col_blcmd[0] != '\0')
		  {
		    bline_ret = output_blcmd(dtc_fdblcmd,"before",mdccp->cmd_col_blcmd);
		    switch (bline_ret) {
		      case CCD_BL_FATAL:
			dc_stop = 1;
		        break;
		      case CCD_BL_NOTCONNECTED:
		      case CCD_BL_DISCONNECTED:
			dc_stop = 1;
	                set_alert_msg("ERROR: Beamline control not connected.");
		  	break;
	              default:
		  	break;
		      }
		  }
		if(dc_stop == 1)
		  {
			dc_abort = 1;
			break;
		  }

		send_det_start();

		send_bl_start();

		dcop = DCOP_COLLECT;

		tick = stat_time * 1000;
		tick_set();
		units = tick;
		decrement = 1000 * (1. / dt_stat);
		dc_abort = 0;
		dc_in_progress = 1;

		break;
	  }
  }

/*
 *	This routine monitors the progress of commands issued by
 *	ccd_hw_start.  In general, most functions are taken care
 *	of by other processes; the only complex commands are scan
 *	and collect.
 */

extern	char	det_reply[2048];

int	ccd_hw_progress(mdccp)
mdc_command	*mdccp;
  {
	char	tempbuf[2048],tbuf[2048],u3dig[4];
	char	prefix_used[20],xform_out_name[256];
	int	done,detret;
	int	timediff,new_time;
	int	bline_ret,i;
	float	kappa_angs[3],euler_angs[3];
	char	*ztime();

	done = 0;

	switch(mdccp->cmd_no)
	  {
	    case MDC_COM_STARTUP:
	    case MDC_COM_INIT:
	    case MDC_COM_ERASE:
	    case MDC_COM_DSET:
	    case MDC_COM_PSET:
	    case MDC_COM_LSET:
	    case MDC_COM_CONFIG:
	    case MDC_COM_SHUT:
	    case MDC_COM_DMOVE:
	    case MDC_COM_PMOVE:
	    case MDC_COM_PMOVEREL:
	    case MDC_COM_LMOVE:
	    case MDC_COM_OMOVE:
	    case MDC_COM_OSET:
	    case MDC_COM_KMOVE:
	    case MDC_COM_KSET:
	    case MDC_COM_GONMAN:
	    case MDC_COM_HOME:

		done = 1;
		break;

	    case MDC_COM_SCAN:
	    case MDC_COM_COLL:
	    case MDC_COM_SNAP:
		if(dc_abort)
		  {
		    done = 1;
		    dc_abort = 0;
		    break;
		  }

		detret = output_detcmd(dtc_fddetcmd,"stop\n",NULL,0);

		if(strip_ave)
		  {
			output_detcmd(dtc_fddetcmd,"getparam\nstrip_ave\n",NULL,0);
			if(NULL == (char *) strstr(det_reply,"OK"))
			    n_strip_ave = 0;
			  else
			    {
				n_strip_ave = sscanf(&det_reply[3],"%f %f %f %f",
					&strip_ave_vals[0],&strip_ave_vals[1],
					&strip_ave_vals[2],&strip_ave_vals[3]);
			    }
			fprintf(stdout,"output_detcmd: STRIPS        at %s: ",ztime());
			for(i = 0; i < n_strip_ave; i++)
			  fprintf(stdout,"%.3f ",strip_ave_vals[i]);
			fprintf(stdout,"\n");
			fflush(stdout);
		  }

		if(detret == CCD_DET_RETRY)
		  {
                    if (dc_stop == 1) {
		      done = 1;
		      dc_stop = 0;
		      break;
                    }
		    if(doing_dark_current == 0)
		      {
		        if(stat_axis == 1)
		          sprintf(tempbuf,"phi_move_rel %10.2f",-mdccp->cmd_col_osc_width);
		        else
		          sprintf(tempbuf,"omega_move_rel %10.2f",-mdccp->cmd_col_osc_width);
		        output_blcmd(dtc_fdblcmd,"cmd",tempbuf);
		      }
		    send_det_start();
		    send_bl_start();
		    break;
		  }
                else if (detret == CCD_DET_NOTCONNECTED) {
                  dc_stop = 1;
                  set_alert_msg("ERROR: Detector control not connected.");
                }
		else if (detret == CCD_DET_FATAL){
		  dc_stop = 1;
		}

		send_copy_command();

		if(dc_stop == 1)
		  {
		    output_detcmd(dtc_fddetcmd,"flush\n",NULL,0);
		    done = 1;
		    dc_stop = 0;
		    fprintf(stderr,"detcon_server: User requested STOP.  Exposures terminating.\n");
		    if(doing_dark_current && double_exp_ctr == 2)
		    	current_darkcurrent_time = 0;
		    break;
		  }

		if(doing_dark_current)
		  {
		    double_exp_ctr--;
		    if(double_exp_ctr > 0)
		      {
		        send_det_start();
		        send_bl_start();
		      }
		     else if(doing_second_dk || stat_dzratio == 1.0)
		      {
			stat_time /= stat_dzratio;
			doing_dark_current = 0;
			if(double_exp_flag)
			    double_exp_ctr = 2;
			  else
			    double_exp_ctr = 1;
		        send_det_start();
		        send_bl_start();
		      }
		      else if(stat_dzratio != 1.0)
			{
			  stat_time *= stat_dzratio;
			  double_exp_ctr = 2;
			  doing_second_dk = 1;
		          send_det_start();
		          send_bl_start();
			}
		    break;
		  }

		if(mdccp->cmd_col_blcmd[0] != '\0')
		  {
		    bline_ret = output_blcmd(dtc_fdblcmd,"during",mdccp->cmd_col_blcmd);
		    switch (bline_ret) {
		      case CCD_BL_FATAL:
			dc_stop = 1;
		        break;
		      case CCD_BL_NOTCONNECTED:
		      case CCD_BL_DISCONNECTED:
			dc_stop = 1;
	                set_alert_msg("ERROR: Beamline control not connected.");
		  	break;
	              default:
		  	break;
		      }
		  }
		if(dc_stop == 1)
		  {
			dc_abort = 1;
		        output_detcmd(dtc_fddetcmd,"flush\n",NULL,0);
		        done = 1;
		    	dc_stop = 0;
			break;
		  }
		double_exp_ctr--;
		if(double_exp_ctr == 0)
		  {
		    stat_time = mdccp->cmd_col_time;
		    totimg--;
		    if(double_exp_flag == 1)
			double_exp_ctr = 2;
		     else
			double_exp_ctr = 1;
		    stat_image_number++;
		    if(stat_axis == 1)
		      {
		        phi_value_saved += mdccp->cmd_col_osc_width;
			if(constrain_phi != 180) {
			if(phi_value_saved >= 360.)
				phi_value_saved -= 360.;
			} else {
			if(phi_value_saved >= 180.)
				phi_value_saved -= 180.;
			}

		      }
		    else
		      {
		        omega_value_saved += mdccp->cmd_col_osc_width;
			if(constrain_omega != 180) {
			if(omega_value_saved >= 360.)
				omega_value_saved -= 360.;
			} else {
			if(omega_value_saved >= 180.)
				omega_value_saved -= 180.;
			}
		      }
		    if(stat_anom)
		      {
			wedge_count--;
			if(wedge_count == 0)
			  {
			    if(wedge_side == 0)
			      {
				wedge_run += 100;
				totimg += wedge_size;
				stat_image_number -= wedge_size;
			      }
			     else
			      {
				wedge_run -= 100;
				wedge_imno += wedge_size;
			      }
			    wedge_count = wedge_size;
			    sprintf(stat_prefix,"%s_%d",wedge_prefix,wedge_run);
			    if(goniostat_type == 0)
			      {
				    if(wedge_side == 0)
				      {
				        sprintf(tempbuf,"phi_move_rel %f",180.-(stat_osc_width * wedge_size));
					fprintf(stderr,"ccd_hw: move rel %f from %f\n",
						180.-(stat_osc_width * wedge_size),stat_phi);
		        	        output_blcmd(dtc_fdblcmd,"cmd",tempbuf);
					phi_value_saved += 180.-(stat_osc_width * wedge_size);
				      }
				     else
				      {
				        sprintf(tempbuf,"phi_move_rel %f",-180.);
					fprintf(stderr,"ccd_hw: move rel %f from %f\n",
						-180.,stat_phi);
		        	        output_blcmd(dtc_fdblcmd,"cmd",tempbuf);
					phi_value_saved -= 180.;
				      }
			      }
			     else
			      {
		        	if(stat_axis == 1)
				  {
				    if(wedge_side == 0)
				      {
				        sprintf(tempbuf,"phi_move_rel %f",180.-(stat_osc_width * wedge_size));
					fprintf(stderr,"ccd_hw: move rel %f from %f\n",
						180.-(stat_osc_width * wedge_size),stat_phi);
		        	        output_blcmd(dtc_fdblcmd,"cmd",tempbuf);
					phi_value_saved += 180.-(stat_osc_width * wedge_size);
				      }
				     else
				      {
				        sprintf(tempbuf,"phi_move_rel %f",-180.);
					fprintf(stderr,"ccd_hw: move rel %f from %f\n",
						180.,stat_phi);
		        	        output_blcmd(dtc_fdblcmd,"cmd",tempbuf);
					phi_value_saved -= 180.;
				      }
				  }
		        	else
				 {
				    if(wedge_side == 1)
				      {
					wedge_omega += stat_osc_width * wedge_size;
					fprintf(stderr,"\ndetcon_server:  Anomalous Run: Primary Segment End.\n");
					fprintf(stderr,"    moving to: (omega, phi, kappa): (%7.2f, %7.2f %7.2f)\n\n",
								wedge_omega,wedge_phi,wedge_kappa);
		          	        sprintf(tempbuf,"omega_move %10.2f", wedge_omega);
		        	        output_blcmd(dtc_fdblcmd,"cmd",tempbuf);
					omega_value_saved = wedge_omega;
		          	        sprintf(tempbuf,"phi_move %10.2f", wedge_phi);
		        	        output_blcmd(dtc_fdblcmd,"cmd",tempbuf);
		          	        sprintf(tempbuf,"kappa_move %10.2f", wedge_kappa);
		        	        output_blcmd(dtc_fdblcmd,"cmd",tempbuf);
					stat_omega = omega_value_saved;
					stat_phi = wedge_phi;
					stat_kappa = wedge_kappa;
				      }
				     else
				      {
				    	kappa_angs[0] = wedge_omega;
				    	kappa_angs[1] = wedge_phi;
				    	kappa_angs[2] = wedge_kappa;
				    	ktoe(kappa_angs, euler_angs);
					euler_angs[1] += 180.;
					euler_angs[2] = - euler_angs[2];
				    	etok(euler_angs, kappa_angs);
					fprintf(stderr,"\ndetcon_server:  Anomalous Run: Bijvoet Segment End.\n");
					fprintf(stderr,"    moving to: (omega, phi, kappa): (%7.2f, %7.2f %7.2f)\n\n",
								kappa_angs[0],kappa_angs[1],kappa_angs[2]);
		          	        sprintf(tempbuf,"omega_move %10.2f", kappa_angs[0]);
		        	        output_blcmd(dtc_fdblcmd,"cmd",tempbuf);
					omega_value_saved = kappa_angs[0];
		          	        sprintf(tempbuf,"phi_move %10.2f", kappa_angs[1]);
		        	        output_blcmd(dtc_fdblcmd,"cmd",tempbuf);
		          	        sprintf(tempbuf,"kappa_move %10.2f", kappa_angs[2]);
		        	        output_blcmd(dtc_fdblcmd,"cmd",tempbuf);
					stat_omega = kappa_angs[0];
					stat_phi = kappa_angs[1];
					stat_kappa = kappa_angs[2];
				      }
				 }
			      }
			    wedge_side ^= 1;
			    if(totimg > stat_wedge)
				wedge_size = stat_wedge;
			     else
				wedge_size = totimg;
			    wedge_count = wedge_size;
			  }
		      }
		    if(repeat_dark_current)
		      {
			time((time_t *) &new_time);
			timediff = new_time - dark_current_time;
			if(timediff > dark_current_interval)
			  {
				doing_dark_current = 1;
				doing_second_dk = 0;
				double_exp_ctr = 2;
				dark_current_time = new_time;
			  }
		      }
		  }
		 else
		  {
		    stat_time = mdccp->cmd_col_time * stat_dzratio;
		    if(stat_axis == 1)
		      sprintf(tempbuf,"phi_move_rel %10.2f",-mdccp->cmd_col_osc_width);
		    else
		      sprintf(tempbuf,"omega_move_rel %10.2f",-mdccp->cmd_col_osc_width);
		    output_blcmd(dtc_fdblcmd,"cmd",tempbuf);
		  }
		if(totimg == 0 || dc_stop == 1)
		  {
			output_detcmd(dtc_fddetcmd,"flush\n",NULL,0);
			done = 1;
			dc_stop = 0;
			if(mdccp->cmd_col_blcmd[0] != '\0')
			  {
			    bline_ret = output_blcmd(dtc_fdblcmd,"after",mdccp->cmd_col_blcmd);
			    switch (bline_ret) {
			      case CCD_BL_FATAL:
				dc_stop = 1;
			        break;
			      case CCD_BL_NOTCONNECTED:
			      case CCD_BL_DISCONNECTED:
				dc_stop = 1;
		                set_alert_msg("ERROR: Beamline control not connected.");
			  	break;
		              default:
			  	break;
			      }
			  }
			if(dc_stop == 1)
			  {
			        done = 1;
			    	dc_stop = 0;
				break;
			  }
			break;
		  }

		send_det_start();

		send_bl_start();

		tick_set();
		tick = stat_time * 1000;
		units = tick;
		decrement = 1000 * (1. / dt_stat);
		totpass = stat_n_passes;

		break;
	  }

	if(done == 1)
	  {
		strcpy(stat_scanner_msg,"");
		strcpy(stat_scanner_op,"");
		strcpy(stat_scanner_control,"idle");
		dc_in_progress = 0;
	  }
	return (done);
  }

ccd_hw_initial_status()
  {
	stat_start_phi = 0.;
	stat_start_omega = 0.;
	stat_start_kappa = 0.;
	stat_axis = 1;
	stat_osc_width = 1.0;
	stat_n_images = 1;
	stat_n_passes = 1;
	stat_n_ccd_updates = 0;
	stat_time = 30;
	stat_dir[0] = '\0';
	stat_fname[0] = '\0';
	strcpy(stat_scanner_op,"none");
	stat_scanner_msg[0] = '\0';
	strcpy(stat_scanner_control,"idle");
	strcpy(stat_scanner_shutter,"closed");
  }

