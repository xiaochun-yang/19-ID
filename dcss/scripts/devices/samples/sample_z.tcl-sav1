# sample_z.tcl
# This is for x4a crystal logic goniometer z combo motion.

proc sample_z_initialize {} {

	# specify children devices
	set_children tripot_1 tripot_2 tripot_3
	# set_siblings sample_y sample_z
}


proc sample_z_move { new_sample_x } {
	#global 
	#global gDevice

	# global variables
    variable sample_z
    variable tripot_1
    variable tripot_2
    variable tripot_3


	# calculate new positions of the two motors
	set new_tripot_1 [tripot_calculate $new_sample_z $sample_z tripot_1]
	set new_tripot_2 [tripot_calculate $new_sample_z $sample_z tripot_2]
    set new_tripot_3 [tripot_calculate $new_sample_z $sample_z tripot_3]

	#check to see if the move can be completed by the real motors
	assertMotorLimit tripot_1 $new_tripot_1
	assertMotorLimit tripot_2 $new_tripot_2
    assertMotorLimit tripot_3 $new_tripot_3

	# move motors in order that avoids collisions
	move tripot_1 to $new_tripot_1
	move tripot_2 to $new_tripot_2
	move tripot_3 to $new_tripot_3

	# wait for the moves to complete
	wait_for_devices tripot_1 tripot_2 tripot_3
}

proc sample_z_set { new_sample_z } {

	# global variables
	variable tripot_1
	variable tripot_2
    variable tripot_3

	# set three motors
	set tripot_1 [tripot_calculate $new_sample_z $sample_z tripot_1]
	set tripot_2 [tripot_calculate $new_sample_z $sample_z tripot_2]
	set tripot_3 [tripot_calculate $new_sample_z $sample_z tripot_3]
}


proc sample_z_update {} {

	# global variables
    variable tripot_1
    variable tripot_2
    variable tripot_3

	# calculate from real motor positions and motor parameters
	return [sample_z_calculate $tripot_1 tripot_2 tripot_3 ]
}


proc sample_z_calculate { t1 t2 t3 } {
	
	return [expr ($t1+$t+2*$t3)/4 ]
}


proc tripot_calculate { zn zo to } {

	return [expr (zn-zo + to)  ]
}

