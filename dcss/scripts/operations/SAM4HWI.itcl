package require Itcl

################################################################
# DIFF from normal SampleMountingDevice:
#    TABLE MOVEMENT IS NOT TRACKED FOR GONIOMETER POSITION
#    DX DY DZ DU always return "0 0 0 0"
################################################################

#DCS::String "table_property" stores data not changeable for table
#You should be able to get these data from drawings of table.

#field 0: level distance between V-pivot to top table downstream edge.
#         normally the distance from V-pivot to upstream edge of
#         the top table is measurable or can be calculated from drauwings.

#field 1: distance from H-pivot to top table downstream edge.
#         normally, you have to get it from drawings.

#field 2: level distance from goniometer head to downstream edge of
#         goniometer table (normally 4.5inch)

#fidle 3: height from sub-frame top plane to the V-pivot.
#         if they are linked by "SPB 32 ADJ", it is 2.125inch.

#field 4: neight from sub-frame top plane to goniometer height.

#field 5: distance from H2 displacement sensor to downstream edge of top table

#DCS::string "table_setup"
#These values need to be updated if table setup changed them.

#field 0: level distance from downstream edge of goniometer table
#         to downstreams edge of top table.

#field 1: safe sample Z value for mount/dismount:
#         The distance from cryojet should be enough for tong to move in +5mm

#field 2: the distance from goniometer head to center line of top table
#         (the center line is beamline) when the goniometer is at the
#         safe_Z position.

#field 3: detector_z value for mount/dismount. Make sure this
#         is big enough that the detector clears the robot
#         interlock IR beam.

#field 4: sample_z value after mount
#         This is for extra short or extra long pins.

#DCS::String "table_position"
#            Save the table position when you run the goniometer-calibration
#            You can move back to this position to mount/dismount
# fields:  H1, H2, V1, V2

#DCS::String "table_adjust"
#which table motors will be moved to access position
#if "table_vert1" is found, both table_vett1 and table_vert2 will be moved
#                           to "table_position"
#else if "table_vert2" is found, it will be moved to tanle_vert1, so no pitch
#else no movement in vertical aspect. 

#SAME goes to horizontal

#DCS::String "table_gonio_scale"
#from the above strings, we can calculate:
# length_V1_to_gonio
# height_V1_to_gonio
# length_H1_to_gonio
# offset_H1_to_gonio
#This string is to store the scales for these values from calibration

#######======================== laser displacement sensor ==================
#DCS::String "dsensor_to_motor_offset"
#           displacement sensor readings when motors are at 0
# same order as operation readAnalog 
# sample_exist, sample_z, V1, V2, H1, H2
#unlike motor table_horz_2, the displacement sensor H2 is monitoring the
# the result of both table_horz_1 and table_horz_2 at that position

############## Displacement sensor to robot goniometer position ##########
#DCS::String "dsensor_to_robot_config"
# same order as Operation "readAnalog", for each reading, 1 pair of (a, b)
# y=aX+b
#The 0 position for V1,V2,H1,H2 sensor is an arbitory position when table was leveled.
# after the pairs for earch reading, 3 more special parameters are appended:
# dx = c*V1
# dy = d*V1
# dx = c*H1
# these parameters descripe how much X and Y moved when V1 and H1 motors moved.
# This is because mechanical nonperfection.
# at the end is the most important one:
# 1: use displacement sensor to do calculation
# 0: do not use displacement sensor to do calculation

#DCS::String "dsensor_z_scale"
# calibration results for pitch and yaw using displacement sensor
# there are Z positions for the sensor from table drawings more measure.
# These scales adjust these positions to get better pitch and yaw
#FIELD 0: vertical scale
#FIELD 1: horizontal scale

####################### table motor to robot goniometer position ###########333
###### MAY BE DISCARDED WHEN DISPLACEMENT SENSORS ARE TESTED RELIABLE #######
# Currenly, are used to calculate the goniometer position and compare with
# results from displacement sensors.
# if off too much(1mm), will stop robot.

#DCS::String "motor_to_robot_config"
#ORDER: V1, V2, H1, H2:
#(y=ax+b)
#FILED 0:   a for V1
#FIELD 1:   b for V1
#FIELD 2:   c for V1  dx=c*V1
#FIELD 3:   d for V1  dy=d*V1
#FILED 4:   a for V2
#FIELD 5:   b for V2
#FIELD 6:   a for H1
#FIELD 7:   c for H1 dx=c*H1
#field 8:   a for H2

# b is not needed for H1, we cannot check whether the table is in the center when H1=0
# b is not needed for H2, we cannot check whether the table is straight when H2=0

#DCS::String "motor_z_scale"
#currently, only 1 field: the scale for pitch (or the Z position for Vertical motors)
#the scalel for yaw is built into the FIELD 8 of "motor_to_robot_config"


######################################
#DCS::String: sensor_to_motor_config
# most of the fields here can be calculated from
# motor_to_robot_config and dsensor_to_robot_config
# but not all of them.
#FIELD 0:   delta_V1/delta_SV1
#FIELD 1:   delta_V2/delta_SV2
#FIELD 2:   delta_H1/delta_SH1
#FIELD 3:   delta_H1/delta_SH2
#FIELD 4:   delta_H2/delta_SH2


itcl::class SampleMountingDevice {

    # private data members -- beamline component interactions
    private {
        variable safedistanceArray
        variable moveToAccessArray
        variable moveBackArray
        variable validcassetteList
        variable validcolumnList
        variable validrowList

        #static values
        variable camera_zoom_safe 0
        variable beamstop_z_safe 40.00
        variable gonio_phi_safe 90.00 
        variable gonio_kappa_safe 0.00 
        variable sample_x_safe 0.00 
        variable sample_y_safe 0.00 

        #will be overrided from table_setup
        variable detector_safe 300.00
        variable sample_z_safe 0.0
        variable sample_z_after 0.0

        #3 seconds
        variable AVERAGE_TIME 3000

        #will be overrided from table_property
        variable length_vert1_gonio 890
        variable height_vert1_gonio 630
        variable length_horz1_gonio 100
        variable offset_horz1_gonio 30
        variable raw_length_vert1_gonio 890
        variable raw_height_vert1_gonio 630
        variable raw_length_horz1_gonio 100
        variable raw_offset_horz1_gonio 30
    }

    private variable need_goHome 0

    public method constructor

    #call after table_property or table_setup changes
    public method calculateTableSetup

    #should be private, put here to debug
    public method fillSafeDistanceArray { move_table_option }
    public method fillMoveList { move_table_option }
    public method getDeltaGonioPosFromMotor { }
    public method getDeltaGonioPosFromFutureMotor { }
    public method getDeltaGonioPosFromMotorArgument { V1 V2 H1 H2 }

    # for reset
    public method resetProcedure
    public method goToNextResetStep
    public method getRobotState { }
    public method resetAllowed { }
    public method openGripper { }
    public method heatGripper { heatsecs }
    public method returnDumbbell { }
    public method moveToCheckPoint { }
    public method check { tool }
    public method performNextRobotResetStep
    public method stepUp { args }

    # for crystal
    public method mountCrystal { cassette row column wash_cycle }
    public method dismountCrystal { cassette row column }
    public method mountNextCrystal { cassette row column cassette_nxt row_nxt column_nxt wash_cycle }
    public method moveCrystal { args }
    public method washCrystal { args }

    # for calibration
    public method calibrateMagnet { { find_magnet 0 } {quick 0} } 
    public method calibrateCassette { cassettes { init 0 } } 
    public method calibrateGoniometer { { init 0 } }
    public method checkGoniometerReachable { }
    public method getGonioCALDATA { }
    public method calibrateBeamLineTool { { init 0 } }
    public method mountBeamLineTool {  }
    public method dismountBeamLineTool {  }
    public method newGonioCAL { }
    ###### one buttont start all calibration #######
    public method oneCalibrate { }

    # for user action
    public method portJamUserAction { args }

    #special gonio cal for table CAL
    #it does not calculate dx, dy, dz and du
    #in short: no call to getDeltaGonioPos
    #to avoid operation readAnalog
    public method specialGonioCAL { dx dy dz du }
    public method newSpecialGonioCAL { dx dy dz du }
    
    #for manula goniometer cal
    public method moveToGoniometer { }
    public method teachGoniometer { }
    public method moveHome { }

    #for Robot_Test
    public method prepareRobotTest { }

    ###### to do more parallel
    public method getMovingBackMotorList { } {
        return [array names moveBackArray]
    }

    # private methods
    private method validPort { cassette row column }
    private method getDeltaGonioPos { }
    private method moveToAccessPosition { }
    private method moveBackToOriginalPosition { }
    private method clearTableCALDATA { }
    private method checkIfRecoverableError { result_message }
    private method autoSampleCheck { {retr_cmd ""} }
    private method autoSampleCalibrate { }
    private method warnDetectorZ { }

    public method sampleOnGoniometer { }
    public method sampleOffGoniometer { }
    public method sampleOnOffCalibrate { }
}

itcl::body SampleMountingDevice::constructor { } {
    global gLaserControl

    calculateTableSetup 

    set validcassetteList [ list l m r ]
    set validcolumnList [ list A B C D E F G H I J K L ]
    set validrowList [ list 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ]
}
itcl::body SampleMountingDevice::moveToAccessPosition { } {
    foreach device [array names moveToAccessArray] {
        move $device to $moveToAccessArray($device)
    }
    eval wait_for_devices [array names moveToAccessArray]
}
itcl::body SampleMountingDevice::moveBackToOriginalPosition { } {
    foreach device [array names moveBackArray] {
        move $device to $moveBackArray($device)
    }
    
    ####comment out following line if you want to allow
    #### loop centering while detector_z is moving
    eval wait_for_devices [array names moveBackArray]
}
itcl::body SampleMountingDevice::fillSafeDistanceArray { move_table_option } {
    variable ::nScripts::table_setup
    variable ::nScripts::table_position
    variable ::nScripts::table_adjust
    variable ::nScripts::gonio_kappa

    # get safe values that are not hardcoded
    set z_safe_from_string [lindex $table_setup 1]
    if {[string is double -strict $z_safe_from_string]} {
        set sample_z_safe $z_safe_from_string
    } else {
        puts "no sample_z specificed for mount from table_setup default to $sample_z_safe"
    }
    set z_after_from_string [lindex $table_setup 4]
    if {[string is double -strict $z_after_from_string]} {
        set sample_z_after $z_after_from_string
    } else {
        puts "no sample_z specificed after mount from table_setup default to $sample_z_after"
    }

    set detector_z_from_string [lindex $table_setup 3]
    if {[string is double -strict $detector_z_from_string]} {
        set detector_safe $detector_z_from_string
    } else {
        puts "no detector_z specificed for mount from table_setup default to $detector_safe"
    }

    ##### these motors are always moved
    array unset safedistanceArray
    array set safedistanceArray [list detector_z $detector_safe \
                    camera_zoom $camera_zoom_safe \
                    beamstop_z $beamstop_z_safe \
                    gonio_phi $gonio_phi_safe \
                    sample_x $sample_x_safe  \
                    sample_y $sample_y_safe \
                    sample_z $sample_z_safe ]

    if {!$::gDevice(gonio_kappa,lockOn)} {
        set safedistanceArray(gonio_kappa) $gonio_kappa_safe
    } else {
        if {abs($gonio_kappa) >= 0.001} {
            ::dcss2 sendMessage "htos_log severe hardware trying to use robot when kappa is at $gonio_kappa"
            return -code error "Robot will work only when kappa at 0.000"
        }
    }
    return "[array names safedistanceArray]"
}
############fill move and delta list
itcl::body SampleMountingDevice::fillMoveList { move_table_option } {
    variable ::nScripts::detector_z

    #fill safe distance array first
    fillSafeDistanceArray $move_table_option

    ######### reset array to empty
    array unset moveToAccessArray
    array unset moveBackArray

    foreach device [array names safedistanceArray] {
        set add_to_move 0
        set add_to_back 0

        #must define back_position if add_to_back = 1
        switch -exact -- $device { 
            detector_z {
                set current_position $detector_z
                set deltaDistance \
                [expr $safedistanceArray($device) - $current_position]
                if {$deltaDistance > 0.001} {
                    set add_to_move 1
                    set add_to_back 1
                    set back_position $current_position
                }
            }
            beamstop_z {
                #add cases that only move if less than the safe position
                set current_position $::gDevice($device,scaled)
                set deltaDistance \
                [expr $safedistanceArray($device) - $current_position]
                #there is no abs in the following line
                if { $deltaDistance > 0.001 } {
                    set add_to_move 1
                    set add_to_back 1
                    set back_position $current_position
                }
            }
            sample_z {
                #### move to a specified position after mount
                set current_position $::gDevice($device,scaled)
                set deltaDistance \
                [expr $safedistanceArray($device) - $current_position]
                if { abs($deltaDistance) > 0.001 } {
                    set add_to_move 1
                }
                set afterDelta \
                [expr $safedistanceArray($device) - $sample_z_after]
                if { abs($deltaDistance) > 0.001 } {
                    set add_to_back 1
                    set back_position $sample_z_after
                }
            }
            camera_zoom -
            sample_x -
            sample_y -
            gonio_kappa -
            gonio_phi {
                #add cases that do not need move back
                set current_position $::gDevice($device,scaled)
                set deltaDistance \
                [expr $safedistanceArray($device) - $current_position]
                if { abs($deltaDistance) > 0.001 } {
                    set add_to_move 1
                    set add_to_back 0
                }
            }
            default {
                #move and back if not at the safe position
                set current_position $::gDevice($device,scaled)
                set deltaDistance \
                [expr $safedistanceArray($device) - $current_position]
                if { abs($deltaDistance) > 0.001 } {
                    set add_to_move 1
                    set add_to_back 1
                    set back_position $current_position
                }
            }
        }
        if {$add_to_move} {
            set moveToAccessArray($device) $safedistanceArray($device)
            if {$add_to_back} {
                set moveBackArray($device) $back_position
            }
        }
    }
    puts "fill move list: move: [array names moveToAccessArray]"
    puts "fill move list: back: [array names moveBackArray]"
    return "move: [array get moveToAccessArray] back: [array get moveBackArray]"
}

itcl::body SampleMountingDevice::calculateTableSetup { } {
    variable ::nScripts::table_property
    variable ::nScripts::table_setup
    variable ::nScripts::table_gonio_scale

    ##################length_vert1_gonio
    set l_vert1_to_top_edge [lindex $table_property 0]
    set l_gonio_edge_to_top_edge [lindex $table_setup 0]
    set l_gonio_to_edge [lindex $table_property 2]

    if {$l_vert1_to_top_edge == "" || $l_vert1_to_top_edge == 0} {
        return -code error "bad table_property field 0"
    }
    if {$l_gonio_edge_to_top_edge  == "" || $l_gonio_edge_to_top_edge  == 0} {
        return -code error "bad table_setup field 0"
    }
    if {$l_gonio_to_edge  == "" || $l_gonio_to_edge  == 0} {
        return -code error "bad table_property field 2"
    }

    set raw_length_vert1_gonio [expr "$l_vert1_to_top_edge - $l_gonio_edge_to_top_edge - $l_gonio_to_edge"]

    if {$raw_length_vert1_gonio <= 0} {
        return -code error "bad length_vert1_gonio=$length_vert1_gonio"
    }

    #################height_vert1_gonio
    set h_vert1_to_plane [lindex $table_property 3]
    set h_gonio_to_plane [lindex $table_property 4]
    
    if {$h_vert1_to_plane  == "" || $h_vert1_to_plane  == 0} {
        return -code error "bad table_property field 3"
    }
    if {$h_gonio_to_plane  == "" || $h_gonio_to_plane  == 0} {
        return -code error "bad table_property field 4"
    }

    set raw_height_vert1_gonio [expr "$h_gonio_to_plane - $h_vert1_to_plane"]
    if {$raw_height_vert1_gonio  <= 0} {
        return -code error "bad height_vert1_gonio=$height_vert1_gonio"
    }


    #################3 length_horz1_gonio
    set l_horz1_to_top_edge [lindex $table_property 1]
    if {$l_horz1_to_top_edge == "" || $l_horz1_to_top_edge  == 0} {
        return -code error "bad table_property field 1"
    }

    #this one maybe negative
    set raw_length_horz1_gonio [expr "$l_horz1_to_top_edge - $l_gonio_edge_to_top_edge - $l_gonio_to_edge"]

    #########offset_horz1_gonio
    set raw_offset_horz1_gonio [lindex $table_setup 2]
    if {$raw_offset_horz1_gonio == "" || $raw_offset_horz1_gonio == 0} {
        return -code error "bad table_setup field 2"
    }

    ############### SCALE THEM ####################
    set length_vert1_gonio [expr $raw_length_vert1_gonio * [lindex $table_gonio_scale 0]]
    set height_vert1_gonio [expr $raw_height_vert1_gonio * [lindex $table_gonio_scale 1]]
    set length_horz1_gonio [expr $raw_length_horz1_gonio * [lindex $table_gonio_scale 2]]
    set offset_horz1_gonio [expr $raw_offset_horz1_gonio * [lindex $table_gonio_scale 3]]

    set result [format "%2.4f %2.4f %2.4f %2.4f" \
            $length_vert1_gonio \
            $height_vert1_gonio \
            $length_horz1_gonio \
            $offset_horz1_gonio]
    puts "calculateTableSetup: $result"

    return $result
}

itcl::body SampleMountingDevice::getRobotState { } {

    if { [catch {
        set operationHandle [eval start_waitable_recovery_operation get_robotstate ]
        
        set result [wait_for_operation_to_finish $operationHandle]
        set status [lindex $result 0]
        set value [lindex $result 1]
    } e ] } {
        log_error $e
        if { [lindex $e 0] == "no_hw_host" } {
            return 1
        } else {
            return -code error $e
        }
    } else {
        return $value
    }
}

itcl::body SampleMountingDevice::resetAllowed { } {
        puts "resetAllowed called"

        if { [catch {
    
        fillMoveList depend_on_table_adjust
        moveToAccessPosition 

        set operationHandle [ start_waitable_operation robot_config reset_allowed ]
        set result [wait_for_operation_to_finish $operationHandle]

        set status [lindex $result 0]
        set value [lindex $result 1]

        if { $status == "normal" && $value == "1" } {
            set result "RobotDHSOK"
        }
        if { $status == "normal" && $value == "0" } {
            set result "RobotDHSError"
        }

    } e ] } {
        log_error $e
        return -code error $e
    } else {
        return $result 
    }
}


itcl::body SampleMountingDevice::moveToCheckPoint { } {

    if { [catch {
        
        set operationHandle [eval start_waitable_operation robot_config move_to_checkpoint [ getDeltaGonioPos ] ]
        wait_for_operation_to_finish $operationHandle

    } e ] } {
        log_error $e
        return -code error $e
    } else {
        return "RobotDHSOK"
    }
}

itcl::body SampleMountingDevice::check { tool } {

        if { [catch {

        fillMoveList depend_on_table_adjust
        moveToAccessPosition 
        
        set operationHandle [eval start_waitable_operation robot_config check_$tool ]
        wait_for_operation_to_finish $operationHandle
        
    } e ] } {
        log_error $e
        return -code error $e
    } else {
        return "RobotDHSOK"
    }
}

itcl::body SampleMountingDevice::openGripper { } {

        if { [catch {
    
        set operationHandle [ start_waitable_operation robot_config open_gripper ]
        wait_for_operation_to_finish $operationHandle
    
    } e ] } {
        log_error $e
        return -code error $e
    } else {
        return "RobotDHSOK"
    }
}

itcl::body SampleMountingDevice::heatGripper { heatsecs } {
        
    if { [catch {
    
        set operationHandle [ start_waitable_operation robot_config heat_gripper $heatsecs ]
        wait_for_operation_to_finish $operationHandle
    
    } e ] } {
        log_error $e
        return -code error $e
    } else {
        return "RobotDHSOK"
    }
}

itcl::body SampleMountingDevice::returnDumbbell { } {
        
    if { [catch {
    
        set operationHandle [start_waitable_operation robot_config return_dumbbell ]
        wait_for_operation_to_finish $operationHandle
        
        set operationHandle [ start_waitable_operation robot_config heat_gripper 20 done]
        wait_for_operation_to_finish $operationHandle
    
    } e ] } {
        log_error $e
        return -code error $e
    } else {
        return "RobotDHSOK"
    }
}

itcl::body SampleMountingDevice::portJamUserAction { args } {
    if {[catch {
        set operationHandle [eval start_waitable_operation robot_config port_jam_action $args]
        set result [wait_for_operation_to_finish $operationHandle]
    } e]} {
        log_error $e
        return -code error $e
    } else {
        return $result
    }
}

itcl::body SampleMountingDevice::calibrateMagnet { { find_magnet 0 } { quick 0 } } {
    if { [catch {
    
        set operationHandle [eval start_waitable_operation robot_calibrate magnet_post $find_magnet $quick]
        set result [wait_for_operation_to_finish $operationHandle]
        
    } e ] } {
        log_error $e
        return -code error $e
    } else { 
        return $result
    }
}
itcl::body SampleMountingDevice::calibrateCassette { cassettes { init 0 } } {
    set ll [string length $cassettes]
    if { $ll <= 0 || $ll > 3 } {
        return -code error "Cassettes should be any one or more of lmr."
    }
    for {set index 0} {$index < $ll} {incr index} {
        set one_cassette [string range $cassettes $index $index]
        if {[lsearch -exact $validcassetteList $one_cassette] < 0} {
            return -code error \
            "Cassettes should be any one or more of $validcassetteList."
        }
    }

    #set heatsecs 10
  
    if { [catch {
        set operationHandle [eval start_waitable_operation robot_calibrate cassette $cassettes $init  ]
        set result [wait_for_operation_to_finish $operationHandle]
    } e ] } {
        log_error $e
        return -code error $e
    } else { 
        return $result
    }
 }

itcl::body SampleMountingDevice::calibrateGoniometer { { init 0 } } {
    block_all_motors
    #set argument "0 0 5"
    if { [catch {
        # not include_move_table
        fillMoveList not_move_table
        moveToAccessPosition
    } e ] } {
        log_error $e
        return -code error $e
    }

    #check if need to do sample_xyz calibration
    autoSampleCalibrate
    sampleOnOffCalibrate
    
    #this function must NOT be called before moveToAccessPosition
    set argument "$init [getDeltaGonioPos]"
    if { [catch {
        set operationHandle [eval start_waitable_operation robot_calibrate goniometer $argument]
        set result [wait_for_operation_to_finish $operationHandle]
    } e ] } {
        log_error $e
        return -code error $e
    }

    if { [catch {
        moveBackToOriginalPosition
    } e ] } {
        log_error $e
    }
    unblock_all_motors
    return $result
}


itcl::body SampleMountingDevice::checkGoniometerReachable { } {
    block_all_motors
    if { [catch {
        fillMoveList not_move_table
        moveToAccessPosition
    } e ] } {
        log_error $e
        return -code error $e
    }

    #this function must NOT be called before moveToAccessPosition
    set argument "0 [getDeltaGonioPos]"
    if { [catch {
        set operationHandle [eval start_waitable_operation robot_calibrate check_goniometer_reachable $argument]
        set result [wait_for_operation_to_finish $operationHandle]

    } e ] } {
        log_error $e
        return -code error $e
    }

    if { [catch {
        moveBackToOriginalPosition
    } e ] } {
        log_error $e
    }
    unblock_all_motors
    return $result
}


itcl::body SampleMountingDevice::newGonioCAL { } {
    block_all_motors
    if { [catch {
        # not include_move_table
        fillMoveList not_move_table
        moveToAccessPosition
    } e ] } {
        log_error $e
        return -code error $e
    }
    #this function must NOT be called before moveToAccessPosition
    set argument "[getDeltaGonioPos]"
    set need_goHome 0
    if { [catch {
        #cool the tong and move to goniometer
        set operationHandle [eval start_waitable_operation robot_calibrate prepare_goniometer $argument]
        set result [wait_for_operation_to_finish $operationHandle]
        set need_goHome 1

        #start goniometer cal with option "init"
        set operationHandle [eval start_waitable_operation robot_calibrate goniometer 1 $argument]
        set result [wait_for_operation_to_finish $operationHandle]

        set need_goHome 0
        start_recovery_operation robot_standby low_power
    } e ] } {
        log_error $e
        if {$need_goHome} {
            set need_goHome 0
            start_recovery_operation robot_standby low_power
        }
        return -code error $e
    }

    ### we ignore errors here
    if { [catch {
        moveBackToOriginalPosition
    } e ] } {
        log_error $e
    }
    unblock_all_motors
    return $result
}
itcl::body SampleMountingDevice::specialGonioCAL { dx dy dz du } {
    block_all_motors
    if { [catch {
        # not include_move_table
        fillMoveList not_move_table
        moveToAccessPosition
    } e ] } {
        log_error $e
        return -code error $e
    }
    if { [catch {
        set operationHandle [eval start_waitable_operation robot_calibrate goniometer 0 $dx $dy $dz $du]
        set result [wait_for_operation_to_finish $operationHandle]
    } e ] } {
        log_error $e
        return -code error $e
    }

    unblock_all_motors
    return $result
}
itcl::body SampleMountingDevice::newSpecialGonioCAL { dx dy dz du } {
    block_all_motors
    if { [catch {
        # not include_move_table
        fillMoveList not_move_table
        moveToAccessPosition
    } e ] } {
        log_error $e
        return -code error $e
    }
    set argument "$dx $dy $dz $du"
    set need_goHome 0
    if { [catch {
        #cool the tong and move to goniometer
        set operationHandle [eval start_waitable_operation robot_calibrate prepare_goniometer $argument]
        set result [wait_for_operation_to_finish $operationHandle]
        set need_goHome 1

        #start goniometer cal with option "init"
        set operationHandle [eval start_waitable_operation robot_calibrate goniometer 1 $argument]
        set result [wait_for_operation_to_finish $operationHandle]

        start_recovery_operation robot_standby low_power
        set need_goHome 0
    } e ] } {
        log_error $e
        if {$need_goHome} {
            set need_goHome 0
            start_recovery_operation robot_standby low_power
        }
        return -code error $e
    }
    unblock_all_motors
    return $result
}
itcl::body SampleMountingDevice::getGonioCALDATA { } {
    fillMoveList not_move_table
    return "$sample_z_safe [getDeltaGonioPos]"
}
itcl::body SampleMountingDevice::calibrateBeamLineTool { { init 0 } } {
    if { [catch {
        set operationHandle [eval start_waitable_operation robot_calibrate beamline_tool $init ]
        set result [wait_for_operation_to_finish $operationHandle]
    } e ] } {
        log_error $e
        return -code error $e
    } else { 
        return $result
    }
}
itcl::body SampleMountingDevice::oneCalibrate { } {
    variable ::nScripts::robot_cal_config

    foreach {mask_auto mask_tool mask_cas mask_gonio mask_find mask_quick mask_left mask_middle mask_right } $robot_cal_config break

    if {$mask_tool == "1"} {
        calibrateMagnet 1 0
    }
    ###call to allow change during run
    foreach {mask_auto mask_tool mask_cas mask_gonio mask_find mask_quick mask_left mask_middle mask_right } $robot_cal_config break
    if {$mask_cas} {
        set cas ""
        if {$mask_left == "1"} {
            append cas l
        }
        if {$mask_middle == "1"} {
            append cas m
        }
        if {$mask_right == "1"} {
            append cas r
        }
        if {$cas != ""} {
            calibrateCassette $cas 0
        }
    }
    ###call to allow change during run
    foreach {mask_auto mask_tool mask_cas mask_gonio mask_find mask_quick mask_left mask_middle mask_right } $robot_cal_config break
    if {$mask_gonio} {
        calibrateGoniometer 0
    }
}

itcl::body SampleMountingDevice::mountBeamLineTool { } {
    if { [catch {
        fillMoveList depend_on_table_adjust
        moveToAccessPosition
    } e ] } {
        log_error $e
        return -code error $e
    }
    #check if need to do sample_xyz calibration
    autoSampleCheck
    
    #this function must NOT be called before moveToAccessPosition
    set argument [getDeltaGonioPos]
    if { [catch {
        set operationHandle [eval start_waitable_operation robot_calibrate mount_beamline_tool $argument ]
        set result [wait_for_operation_to_finish $operationHandle]
    } e ] } {
        log_error $e
        return -code error $e
    }
    if { [catch {
        moveBackToOriginalPosition
    } e ] } {
        log_error $e
    }
    return $result
}
itcl::body SampleMountingDevice::dismountBeamLineTool { } {
    if { [catch {
        fillMoveList depend_on_table_adjust
        moveToAccessPosition
    } e ] } {
        log_error $e
        return -code error $e
    }
    #check if need to do sample_xyz calibration
    autoSampleCheck
    
    #this function must NOT be called before moveToAccessPosition
    set argument [getDeltaGonioPos]
    if { [catch {
    
        set operationHandle [eval start_waitable_operation robot_calibrate dismount_beamline_tool $argument]
        set result [wait_for_operation_to_finish $operationHandle]
    } e ] } {
        log_error $e
        return -code error $e
    }
    if { [catch {
        moveBackToOriginalPosition
    } e ] } {
        log_error $e
    }
    return $result
}
itcl::body SampleMountingDevice::moveToGoniometer { } {
    if { [catch {
        fillMoveList not_move_table
        moveToAccessPosition
    } e ] } {
        log_error $e
        return -code error $e
    }

    #this function must NOT be called before moveToAccessPosition
    set argument [getDeltaGonioPos]

    #move robot to goniometer standby position
    if { [catch { 
        set operationHandle [eval start_waitable_operation robot_calibrate move_to_goniometer $argument]
        set result [wait_for_operation_to_finish $operationHandle]
    } e ] } {
        log_error $e
        return -code error $e
    } else { 
        return $result
    }
}
itcl::body SampleMountingDevice::teachGoniometer { } {
    set argument [getDeltaGonioPos]

    #save current position to goniometer position
    if { [catch { 
        set operationHandle [eval start_waitable_operation robot_calibrate save_goniometer_position $argument]
        set result [wait_for_operation_to_finish $operationHandle]
    } e ] } {
        log_error $e
        return -code error $e
    } else { 
        return $result
    }
}
itcl::body SampleMountingDevice::moveHome { } {
    set argument [getDeltaGonioPos]

    if { [catch { 
        set operationHandle [eval start_waitable_operation robot_calibrate move_home $argument]
        set result [wait_for_operation_to_finish $operationHandle]
    } e ] } {
        log_error $e
        return -code error $e
    } else { 
        return $result
    }
}
itcl::body SampleMountingDevice::moveCrystal { args } {
    set Nargs [ llength $args ]

    if { $Nargs == 0 } {
        return -code error "ERROR: Invalid number of ports specified"
    }

    for { set i 0 } {$i < $Nargs } { incr i } {
        set OnePair [lindex $args $i]
        if { [string length $OnePair] < 8 } {
            return -code error "Invalid pair length specified: $OnePair, should be something like lA8->rB1."
        }
        set indexArrow [string first "->" $OnePair]
        if { $indexArrow < 3 } {
            return -code error "Invalid pair format specified: $OnePair, should be something like lA8->rB1."
        }
        set S_Cassette [string index $OnePair 0]
        set S_Column [string index $OnePair 1]
        set end_row [expr $indexArrow - 1]
        set S_Row [string range $OnePair 2 $end_row]

        set targetIndex [expr $indexArrow + 2]

        set T_Cassette [string index $OnePair $targetIndex]
        incr targetIndex
        set T_Column [string index $OnePair $targetIndex]
        incr targetIndex
        set T_Row [string range $OnePair $targetIndex end]

        puts "one pair: $S_Cassette $S_Column $S_Row ---> $T_Cassette $T_Column $T_Row"


        if { ![ validPort $S_Cassette $S_Row $S_Column ] || ![ validPort $T_Cassette $T_Row $T_Column ] } {
            return -code error "Invalid port specified."
        }
    }

    set heatsecs 10

    set need_goHome 0

    if { [catch {

        set operationHandle [eval start_waitable_operation prepare_move_crystal $args]
        wait_for_operation_to_finish $operationHandle

        set need_goHome 1

        set operationHandle [eval start_waitable_operation move_crystal $args]
        set result [wait_for_operation_to_finish $operationHandle]

        set need_goHome 0

        start_recovery_operation robot_standby
        
    } e ] } {
        if {$need_goHome} {
            set need_goHome 0
            start_recovery_operation robot_standby
        }
        log_error $e
        return -code error $e
    } else { 
        return $result
    }

}
itcl::body SampleMountingDevice::mountCrystal { cassette row column wash_cycle } {

    block_all_motors
    
    if { ![ validPort $cassette $row $column ] } {
        return -code error "Invalid port specified."
    }

    set need_goHome 0

    if { [catch {
        fillMoveList depend_on_table_adjust

        set argument "$cassette $row $column [getDeltaGonioPosFromFutureMotor]"
        set operationHandle [eval start_waitable_operation prepare_mount_crystal $argument]
        set result [wait_for_operation $operationHandle]

        if {[checkIfRecoverableError $result]} {
            #the above call will also change fillMoveList
            #restart the operation
            set argument "$cassette $row $column [getDeltaGonioPosFromFutureMotor]"
            set operationHandle [eval start_waitable_operation prepare_mount_crystal $argument]
            set result [wait_for_operation $operationHandle]
        }

        set status [lindex $result 0]
    
        #first reply must be update or normal to continue
        if { $status != "update" && $status != "normal" } {
            return -code error "$result"
        }

        if { $status == "normal" && [llength $result] >=4 } {
            if {[lindex $result 1] == "n" && \
                [lindex $result 2] == "0" && \
                [lindex $result 3] == "N" } {
                #empty port
                return $result
            }
        }

        set need_goHome 1

        moveToAccessPosition
        #check if need to do sample_xyz calibration
        ### create command
        set prepare_cmd [list start_waitable_operation prepare_mount_crystal]
        lappend prepare_cmd $cassette $row $column
        set deltaGonioPos [getDeltaGonioPos]
        eval lappend prepare_cmd $deltaGonioPos
        autoSampleCheck $prepare_cmd
        sampleOffGoniometer

        #this function must NOT be called before moveToAccessPosition
        set argument "$cassette $row $column $deltaGonioPos $wash_cycle"

        if { $status == "update" } {
            wait_for_operation_to_finish $operationHandle
        }

        set operationHandle [eval start_waitable_operation mount_crystal $argument]
        set result [wait_for_operation_to_finish $operationHandle]

        set need_goHome 0

        if {([lindex $result 1] != "n" || \
        [lindex $result 2] != "0" || \
        [lindex $result 3] != "N") && 
        [catch sampleOnGoniometer errMsg]} {
            start_recovery_operation robot_standby rescue_sample
            set result "sample not on goniometer after mount"
            log_severe $result
            log_severe "Robot maybe failed to pull out the sample from cassette"
        } else {
            start_recovery_operation robot_standby
        }
    } e ] } {
        if {[lindex $e 0] == "normal"} {
            return $e
        }

        if {$need_goHome} {
            set need_goHome 0
            start_recovery_operation robot_standby
        }

        if {$e == "sample_still_on_goniometer"} {
            if { [catch {
                moveBackToOriginalPosition
            } e ] } {
                log_error $e
            }
        }
        log_error $e
        warnDetectorZ
        return -code error $e
    }

    ### we ignore errors here
    if { [catch {
        moveBackToOriginalPosition
    } e ] } {
        log_error $e
    }
    unblock_all_motors
    
    return $result
}

itcl::body SampleMountingDevice::dismountCrystal { cassette row column } {
    block_all_motors

    if { ![ validPort $cassette $row $column ] } {
        return -code error "Invalid port specified."
    }
    
    set need_goHome 0

    if { [catch {

        fillMoveList depend_on_table_adjust
        set operationHandle [eval start_waitable_operation prepare_dismount_crystal $cassette $row $column [ getDeltaGonioPosFromFutureMotor ] ]
        set result [wait_for_operation $operationHandle]

        if {[checkIfRecoverableError $result]} {
            set operationHandle [eval start_waitable_operation prepare_dismount_crystal $cassette $row $column [ getDeltaGonioPosFromFutureMotor ] ]
            set result [wait_for_operation $operationHandle]
        }
        set status [lindex $result 0]
    
        #first reply must be update to continue
        if { $status != "update" && $status != "normal" } {
            return -code error $result
        }
        if { $status == "normal" && [llength $result] >=4 } {
            if {[lindex $result 1] == "n" && \
                [lindex $result 2] == "0" && \
                [lindex $result 3] == "N" } {
                #nothing on goniometer
                return $result
            }
        }

        set need_goHome 1

        moveToAccessPosition
        #check if need to do sample_xyz calibration
        ### create command
        set prepare_cmd [list start_waitable_operation prepare_dismount_crystal]
        lappend prepare_cmd $cassette $row $column
        set deltaGonioPos [getDeltaGonioPos]
        eval lappend prepare_cmd $deltaGonioPos
        autoSampleCheck $prepare_cmd
        sampleOnGoniometer
        
        if { $status == "update"  } {
            wait_for_operation_to_finish $operationHandle
        }
        
        set operationHandle [eval start_waitable_operation dismount_crystal $cassette $row $column $deltaGonioPos]
        set result [wait_for_operation_to_finish $operationHandle]

        set need_goHome 0

        start_recovery_operation robot_standby
    } e ] } {
        if {[lindex $e 0] == "normal"} {
            return $e
        }
        log_error $e
        warnDetectorZ
        if {$need_goHome} {
            set need_goHome 0
            start_recovery_operation robot_standby
        }
        if {$e == "no_sample_on_goniometer"} {
            log_severe "no sample on goniometer before dismount."
            log_severe " Please call staff to clear mounted if really there is no sample"
        }
        return -code error $e
    }

    if {[catch sampleOffGoniometer errMsg]} {
        set result "maybe sample still on goniometer after dismount"
        log_warning $result
    }

    ### we ignore errors here
    if { [catch {
        moveBackToOriginalPosition
    } e ] } {
        log_error $e
    }

    unblock_all_motors
    return $result
}
itcl::body SampleMountingDevice::washCrystal { times } {
    block_all_motors

    #puts "wash crystal $times"

    set need_goHome 0

    if { [catch {
        fillMoveList depend_on_table_adjust
        #puts "start prepare operation"
        set operationHandle [eval start_waitable_operation prepare_wash_crystal $times [ getDeltaGonioPosFromFutureMotor ] ]
        set result [wait_for_operation $operationHandle]

        if {[checkIfRecoverableError $result]} {
            set operationHandle [eval start_waitable_operation prepare_wash_crystal $times [ getDeltaGonioPosFromFutureMotor ]]
            set result [wait_for_operation $operationHandle]
        }
        set status [lindex $result 0]
    
        #first reply must be update to continue
        if { $status != "update" && $status != "normal" } {
            return -code error $result
        }
        if { $status == "normal" && [lindex $result 1] == "nothing" } {
            return $result
        }
        #puts "move to access positoin"

        set need_goHome 1

        moveToAccessPosition
        #check if need to do sample_xyz calibration
        ### create command
        set prepare_cmd [list start_waitable_operation prepare_wash_crystal]
        lappend prepare_cmd $times
        set deltaGonioPos [getDeltaGonioPos]
        eval lappend prepare_cmd $deltaGonioPos
        autoSampleCheck $prepare_cmd
        sampleOnGoniometer
        
        if { $status == "update"  } {
            wait_for_operation_to_finish $operationHandle
        }
        
        #puts "start wash operation"
        set operationHandle [eval start_waitable_operation wash_crystal $times $deltaGonioPos]
        set result [wait_for_operation_to_finish $operationHandle]

        set need_goHome 0

        if {[catch sampleOnGoniometer errMsg]} {
            start_recovery_operation robot_standby rescue_sample
            set result "sample not on goniometer after wash"
            log_severe $result
        } else {
            start_recovery_operation robot_standby
        }
    } e ] } {
        if {[lindex $e 0] == "normal"} {
            return $e
        }

        log_error $e
        warnDetectorZ

        if {$need_goHome} {
            set need_goHome 0
            start_recovery_operation robot_standby
        }
        if {$e == "no_sample_on_goniometer"} {
            log_severe "no sample on goniometer before washing"
            log_severe " Please call staff to clear mounted if really there is no sample"
        }
        return -code error $e
    }

    ### we ignore errors here
    if { [catch {
        moveBackToOriginalPosition
    } e ] } {
        log_error $e
    }

    unblock_all_motors
    return $result
}

itcl::body SampleMountingDevice::mountNextCrystal { cassette row column cassette_nxt row_nxt column_nxt wash_cycle } {
    block_all_motors
    
    if { ![ validPort $cassette $row $column ] || ![ validPort $cassette_nxt $row_nxt $column_nxt ] } {
        return -code error "Invalid port specified."
    }
    
    set need_goHome 0

    if { [catch {

        fillMoveList depend_on_table_adjust
        set operationHandle [eval start_waitable_operation prepare_mount_next_crystal $cassette $row $column $cassette_nxt $row_nxt $column_nxt [ getDeltaGonioPosFromFutureMotor ] ]
        set result [wait_for_operation $operationHandle]

        if {[checkIfRecoverableError $result]} {
            set operationHandle [eval start_waitable_operation prepare_mount_next_crystal $cassette $row $column $cassette_nxt $row_nxt $column_nxt [ getDeltaGonioPosFromFutureMotor ] ]
            set result [wait_for_operation $operationHandle]
        }

        set status [lindex $result 0]
    
        if { $status != "update" && $status != "normal" } {
            return -code error $result
        }
        if { $status == "normal" && [llength $result] >=8 } {
            if {[lindex $result 1] == "n" && \
                [lindex $result 2] == "0" && \
                [lindex $result 3] == "N" && \
                [lindex $result 4] == "normal" && \
                [lindex $result 5] == "n" && \
                [lindex $result 6] == "0" && \
                [lindex $result 7] == "N" } {
                #nothing on goniometer with empty source port
                return $result
            }
        }

        set need_goHome 1

        moveToAccessPosition
        #check if need to do sample_xyz calibration
        ### create command
        set prepare_cmd [list start_waitable_operation prepare_mount_next_crystal]
        lappend prepare_cmd $cassette $row $column $cassette_nxt $row_nxt $column_nxt
        set deltaGonioPos [getDeltaGonioPos]
        eval lappend prepare_cmd $deltaGonioPos
        autoSampleCheck $prepare_cmd

        if { $status == "update" } {
            wait_for_operation_to_finish $operationHandle
        }
        
        set operationHandle [eval start_waitable_recovery_operation mount_next_crystal $cassette $row $column $cassette_nxt $row_nxt $column_nxt $deltaGonioPos $wash_cycle]
        set result [wait_for_operation_to_finish $operationHandle]

        set need_goHome 0

        if {[llength $result] >=8 && \
        [lindex $result 4] == "normal" && \
        [lindex $result 5] != "n" && \
        [lindex $result 6] != "0" && \
        [lindex $result 7] != "N" && \
        [catch sampleOnGoniometer errMsg]} {
            start_recovery_operation robot_standby rescue_sample
            set result "sample not on goniometer after mount next"
            log_severe $result
        } else {
            start_recovery_operation robot_standby
        }
    } e ] } {
        if {[lindex $e 0] == "normal"} {
            return $e
        }
        if {$need_goHome} {
            set need_goHome 0
            start_recovery_operation robot_standby
        }
        log_error $e
        warnDetectorZ
        return -code error $e
    }

    ### we ignore errors here
    if { [catch {
        moveBackToOriginalPosition
    } e ] } {
        log_error $e
    }
    unblock_all_motors
    return $result
}

itcl::body SampleMountingDevice::validPort { cassette row column } {

    set portOK 0

    set cassOK [ lsearch -exact $validcassetteList $cassette ]
    set colOK [ lsearch -exact $validcolumnList $column ]
    set rowOK [ lsearch -exact $validrowList $row ]

    if { $cassOK != -1 && $colOK != -1 && $rowOK != -1 } {
        set portOK 1
    }

    return $portOK
}

itcl::body SampleMountingDevice::getDeltaGonioPos { } {
    return "0 0 0 0"
}
itcl::body SampleMountingDevice::getDeltaGonioPosFromFutureMotor { } {
    return "0 0 0 0"
}

itcl::body SampleMountingDevice::resetProcedure { } {
    variable ::nScripts::robotResetStep
   #gContinueResetProcedure set by the continueResetProcedure operation 
    global gContinueResetProcedure

    block_all_motors
    
    set gContinueResetProcedure 0
    
    if { [catch {
        
        for { set step 1 } {$step < 22} {incr step} {
            
            performNextRobotResetStep $step
            
            set robotResetStep $step

            #loop until we get an abort or the continueResetProcedure is called
            while { $gContinueResetProcedure == 0 } {
                wait_for_time 200
            }
            
            set gContinueResetProcedure 0
            
        }
    } errorResult ] } {
        set gContinueResetProcedure 0 
        set robotResetStep 0
        
        log_error $errorResult
        return -code error $errorResult
   }

    set gContinueResetProcedure 0 
    set robotResetStep 0
}

itcl::body SampleMountingDevice::performNextRobotResetStep { step_ } {
    
    switch $step_ {
      1 {
            # do not use robot for Screening
            set handle [start_waitable_operation sequenceSetConfig setConfig useRobot "0"]
            wait_for_operation $handle
            
            # send dismount message to dcss to reset the crystal
            #state to "no crystal mounted"
            #set handle [start_waitable_operation sequenceSetConfig setConfig dismount 1]
            #wait_for_operation $handle
       }
       2 {
            #Press the green hutch reset button.
      }
      3 {
        #The robot server now performs a check to see if a Reset is allowed.
      }
      4 {
            resetAllowed
            
            #The robot will now move the gripper arm to an accessible location
      }
      5 {
            moveToCheckPoint
            #Manually remove any crystal from the goniometer.
      }
      6 {
            #If the gripper is closed use a heat gun to melt any excess ice
            #on the gripper.
      }
      7 {
            #The robot will now open the grippers
      }
      8 {
            openGripper
            #Please remove the dumbbell magnet and any crystal on it.
        }
        9 {
        #Please remove any crystal from inside the gripper cavity.
        }
        10 {
            #The robot will now move the gripper to the heating chamber and
            #dry the gripper arms.
        }
        11 {
            heatGripper 10
         #The robot gripper will now try to retrieve a dumbbell magnet.
        }
        12 {
            check dumbbell
            #The robot will now move the gripper arm to an accessible location
        }
        13 {
            moveToCheckPoint
            
          openGripper

            #Remove the dumbbell magnet and any crystal on it.
        }
        14 {
            #The robot will now move the gripper to the heating chamber and
            #dry the gripper arms
    }
        15 {
            heatGripper 0
            #The robot will now move the gripper arm to an accessible location
            #above the dispensing Dewar, with the lid closed.
        }
        16 {
            moveToCheckPoint
            #Use a heat gun to make sure the dumbbell magnet is free
            #from ice and dry
        }
        17 {
            #Please replace the dumbbell magnet
        }
        18 {
            #The robot will now return the dumbbell magnet to the dispensing
        }
        19 {
            returnDumbbell
            #Please verify that the cassettes inside the Dewar correspond to
            #the ones loaded into the Screening Web Interface.
        }
        20 {
            # enable robot mode
            set handle [start_waitable_operation sequenceSetConfig setConfig useRobot "1"]
            wait_for_operation $handle
            # sync with robot if it can
            set handle [start_waitable_operation sequenceSetConfig syncWithRobot 1]
            wait_for_operation $handle
            
            #Please use the Search / Reset key to interlock the hutch and close the hutch door.
        }
        21 {
            #Enable Safeguard and press the Safeguard release button.
        }
        default {
            return -code error "Unknown robot reset step."
        }
    }
}

itcl::body SampleMountingDevice::clearTableCALDATA { } {
    variable ::nScripts::table_calibration0
    variable ::nScripts::table_calibration1
    variable ::nScripts::table_calibration2
    variable ::nScripts::table_calibration3
    variable ::nScripts::table_calibration4

    set timeStamp [clock format [clock seconds] -format "%D-%T"]
    set table_calibration0 [lreplace table_calibration0 0 1 0 $timeStamp]
    set table_calibration1 [lreplace table_calibration1 0 1 0 $timeStamp]
    set table_calibration2 [lreplace table_calibration2 0 1 0 $timeStamp]
    set table_calibration3 [lreplace table_calibration3 0 1 0 $timeStamp]
    set table_calibration4 [lreplace table_calibration4 0 1 0 $timeStamp]
    return "all data cleared"
}
itcl::body SampleMountingDevice::checkIfRecoverableError { result_message } {
    variable ::nScripts::robot_attribute
    #currently only deal with goniometer unreachable error

    if {[lindex $result_message 0] != "out"} {
        return 0
    }
    if {[llength $result_message] < 4} {
        return 0
    }
    if {[lindex $result_message 1] != "of" || \
        [lindex $result_message 2] != "robot" || \
        [lindex $result_message 3] != "range"} {
        return 0
    }

    #check to see if robot_attribute for "move table in case of goniometer unreachable is turned on"
    set move_table_if_need [lindex $robot_attribute 10]
    if {$move_table_if_need != "1"} {
        return 0
    }

    #re-fill the list with forced_move_table
    fillMoveList forced_move_table
    return 1
}

itcl::body SampleMountingDevice::prepareRobotTest { } {
    #set argument "0 0 5"
    if { [catch {
        # not include_move_table
        fillMoveList not_move_table
        moveToAccessPosition
    } e ] } {
        log_error $e
        return -code error $e
    }
    #this function must NOT be called before moveToAccessPosition
    return [getDeltaGonioPos]
}
itcl::body SampleMountingDevice::autoSampleCheck { {retry_cmd ""}} {
    variable ::nScripts::auto_sample_const
    #check if need to do sample_xyz calibration
    set system_on [lindex $auto_sample_const 29]

    if {$system_on != "1"} return

    #if {$retry_cmd != ""} {
    #    log_warning "retry command: $retry_cmd"
    #}
    
    set auto_center 0
    log_note "perform automatic sample_xyz checking...."
    if {[catch {
        set result [::nScripts::auto_sample_cal_start check_xyz]
    } e ] } {
        log_error $e
        set e1 [lindex $e 0]
        if {$e1 != "check_xyz_failed"} {
            return -code error $e
        }
        ###### auto calibration if check failed
        set auto_center 1
    }
    if {$auto_center} {
        log_warning "auto calibrate the goniomemter position....."
        if {$retry_cmd != ""} {
            set need_goHome 0
            start_recovery_operation robot_standby
        }
        if {[catch autoSampleCalibrate e]} {
            if {$e != "aborted"} {
                log_severe $e
            }
            return -code error $e
        }
        log_note "auto center goniometer succeeded: $e"
        if {$retry_cmd != ""} {
            set handle [eval $retry_cmd]
            wait_for_operation_to_finish $handle
            set need_goHome 1
        }
    }
}
itcl::body SampleMountingDevice::autoSampleCalibrate { } {
    variable ::nScripts::auto_sample_const
    #check if need to do sample_xyz calibration
    set system_on [lindex $auto_sample_const 29]

    if {$system_on != "1"} return
    
    log_note "perform automatic sample_xyz calibration...."
    if {[catch {
        set result [::nScripts::auto_sample_cal_start full_calibrate]
    } e ] } {
        log_error $e
        return -code error $e
    }
    return $result
}
itcl::body SampleMountingDevice::sampleOnGoniometer { } {
    variable ::nScripts::robot_attribute

    ### if auto sample position is not on, skip this also
    variable ::nScripts::auto_sample_const
    #check if need to do sample_xyz calibration
    set system_on [lindex $auto_sample_const 29]
    if {$system_on != "1"} return

    if {![::nScripts::CSO_get_constant system_on]} {
        return
    }

    #if probe port is turned off, we will skip sample gonio check
    if {![lindex $robot_attribute 2]} {
        log_warning sampleOnGoniometer skipped because port probing is turned off
        return
    }

    log_note "auto check sample on goniometer"
    if {[catch {::nScripts::check_sample_on_start sample_on} e] && \
    $e == "no_sample_on_goniometer"} {
        return -code error $e
    }
}
itcl::body SampleMountingDevice::sampleOffGoniometer { } {
    variable ::nScripts::robot_attribute

    ### if auto sample position is not on, skip this also
    variable ::nScripts::auto_sample_const
    #check if need to do sample_xyz calibration
    set system_on [lindex $auto_sample_const 29]
    if {$system_on != "1"} return

    if {![::nScripts::CSO_get_constant system_on]} {
        return
    }
    log_note sample check is on

    #if probe port is turned off, we will skip sample gonio check
    if {![lindex $robot_attribute 2]} {
        log_warning sampleOffGoniometer skipped because port probing is turned off
        return
    }

    log_note "auto check sample off goniometer"
    if {[catch {::nScripts::check_sample_on_start sample_off} e] && \
    $e == "sample_still_on_goniometer"} {
        return -code error $e
    }
}
itcl::body SampleMountingDevice::sampleOnOffCalibrate { } {

    ### if auto sample position is not on, skip this also
    variable ::nScripts::auto_sample_const
    #check if need to do sample_xyz calibration
    set system_on [lindex $auto_sample_const 29]
    if {$system_on != "1"} return

    if {![::nScripts::CSO_get_constant system_on]} {
        return
    }

    log_note "calibrate sample on off goniometer"
    if {[catch {
        set result [::nScripts::check_sample_on_start self_calibration]
    } e ] } {
        log_error $e
        return -code error $e
    }
}
itcl::body SampleMountingDevice::stepUp { args } {
    if { [catch {
        set operationHandle [eval start_waitable_operation robot_config raise_robot $args]
        wait_for_operation_to_finish $operationHandle

    } e ] } {
        log_error $e
        return -code error $e
    } else {
        return "RobotDHSOK"
    }
}
itcl::body SampleMountingDevice::warnDetectorZ { } {
    variable ::nScripts::screening_msg

    if {[info exists moveBackArray(detector_z)]} {
        log_warning please notice that old detector_z was $moveBackArray(detector_z)
        set screening_msg "WARNING: old detecot_z=$moveBackArray(detector_z)"
    }

}
