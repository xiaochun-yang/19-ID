#include <float.h>
#include <math.h>

#include "log_quick.h"
#include "DcsMessage.h"
#include "DcsMessageTwoWay.h"
#include "DcsMessageManager.h"
#include "XOSSingleLock.h"

#include "dbDefs.h"

#include "GwLynceanMotor.h"

GwBaseMotor::MotorField GwLynceanMotor::m_fields[CHID_END] = {
    //name                   monitor   type      
    {"StopBO.PROC",          false,      DBR_ENUM},
    {"StsDI.B0",             true,       DBR_ENUM},
    {"PstnAO",               false,      DBR_DOUBLE},
    {"PstnAI",               true,       DBR_DOUBLE},
    {"StsDI.B1",             true,       DBR_ENUM},
    {"StsSI",                true,       DBR_STRING},
    {"PstnAO.DRVH",          true,       DBR_DOUBLE},
    {"PstnAO.DRVL",          true,       DBR_DOUBLE}
};
GwLynceanMotor::GwLynceanMotor( const char* name, const char* localName, bool real )
: GwBaseMotor( name, localName, real )
, m_stopToSend(1)
, m_busyCurrent(0)
, m_errorCurrent(0)
, m_sendConfigPending(false)
{
    m_PVArray = m_pvMap;
    m_numPV = CHID_END;
    initPVMap( );

    m_numBasicPV = CHID_END_OF_MIN;

    //////////////////////////////////////////////////////////////
    // these names (m_device, m_mrn) are not used yet.
    // they may be needed in the future if the PV names cannot be
    // generated by just appending some text to the localName.
    //////////////////////////////////////////////////////////////
    const char* pSep = strrchr( localName, ':' );
    if (pSep == NULL) {
        LOG_SEVERE2( "LynceanMotor %s cannot find device prefix in localname {%s}",
            name, localName
        );
        return;
    } else {
        strncpy( m_device, localName, (pSep - localName) );
        strcpy( m_mrn, pSep + 1 );
        LOG_FINEST3( "LynceanMotor %s got DEVICE: {%s} MRN: {%s}",
            name, m_device, m_mrn
        );
    }
    connectEPICS( );
}
void GwLynceanMotor::fillPVMap( ) {
    unsigned long minDelay = m_pDcsConfig->getInt( "epicsgw.Motor.UpdateRate",
    getPollIndex( ) );
    char tagName[DCS_DEVICE_NAME_SIZE+32] = {0};
    strcpy( tagName, "epicsgw." );
    strcat( tagName, m_name );
    strcat( tagName, ".UpdateRate" );

    minDelay = m_pDcsConfig->getInt( tagName, minDelay );
    setPollIndex( minDelay );

    for (int i = 0; i < m_numPV; ++i) {
        //if a PV not fits in the pattern, you can define it in the
        //config file
        std::string key = m_localName;
        key += ":";
        key += m_fields[i].name;
        std::string val = m_pDcsConfig->getStr( key );
        if (val.size( ) > 0) {
            strcpy( m_PVArray[i].name, val.c_str( ) );
        } else {
            strcpy( m_PVArray[i].name, key.c_str( ) );
        }
        m_PVArray[i].needMonitor = m_fields[i].needMonitor;
        m_PVArray[i].type        = m_fields[i].type;
        m_PVArray[i].count       = 1;
        fillPVValPointers( i );
    }
}
void GwLynceanMotor::sendLynceanMoveCompleted( ) {
    const char* pStatus;

    if (getConnectState( ) != ALL_CONNECTED) {
        pStatus = "disconnected";
    } else if (m_errorCurrent) {
        LOG_INFO( "sendLynceanMoveCompleted got m_errorCurrent == 1" );
        sendErrorMsg( );
        pStatus = "ERROR";
    } else {
        pStatus = DCS_MOTOR_NORMAL;
    }
    sendMoveCompleted( pStatus );

    if (m_sendConfigPending) {
        sendLynceanConfig( );
    }
}
//fill baseMotor's variable from m_valCurrent
//then call baseMotor sendConfig
void GwLynceanMotor::sendLynceanConfig( ) {
    GwBaseMotor::sendConfig( );
}
void GwLynceanMotor::updateDCSSByState( int triggerIndex ) {
    LOG_FINEST2( "LynceanMotor %s updateDCSSByState index %d",
        m_name, triggerIndex
    );
    switch (m_dcsStatus) {
    case DCS_DEVICE_WAITING_ACK:
    case DCS_DEVICE_ACTIVE:
    case DCS_DEVICE_ABORTING:
        sendLynceanMoveCompleted( );
        break;

    default:
        if (getConnectState( ) == ALL_CONNECTED && allDataReady( ) ) {
            sendLynceanConfig( );
        } else {
            sendLynceanMoveCompleted( );
        }
    }
    m_dcsStatus = DCS_DEVICE_INACTIVE;
}
void GwLynceanMotor::updateDCSSByData( int triggerIndex ) {
    switch (triggerIndex) {
    case CHID_MON:
        updateDCSSByMON( );
        break;

    case CHID_BUSY:
        updateDCSSByBUSY( );
        break;

    default:
        LOG_FINEST3( "updateDCSSByConfig for %s PV[%d]: %s", m_name,
            triggerIndex, m_PVArray[triggerIndex].name
        );
        updateDCSSByConfig( );
    }
}
void GwLynceanMotor::updateDCSSByBUSY( ) {
    LOG_FINEST2( "updateDCSSByBUSY for %s BUSY=%hd", m_name, m_busyCurrent );
    if (m_busyCurrent == 0) {
        sendLynceanMoveCompleted( );
        m_dcsStatus = DCS_DEVICE_INACTIVE;
    } else {
        if (m_dcsStatus != DCS_DEVICE_ACTIVE) {
            sendMoveStarted( );
            m_dcsStatus = DCS_DEVICE_ACTIVE;
        } else {
            //may be MON arrived first
            LOG_FINEST1( "Lyncean motor %s got BUSY=true while active",
                m_name
            );
        }
    }
}
void GwLynceanMotor::updateDCSSByMON( ) {
    LOG_FINEST2( "updateDCSSByMON for %s: pos=%lf",
        m_name, m_positionCurrent
    );
    LOG_FINEST1( "dcsStatus = %s", getDcsStatusText( ) );
    if (getPollIndex( )) {
        m_needUpdate = true;
        //let poll handle it
        return;
    }

    switch (m_dcsStatus) {
    case DCS_DEVICE_INACTIVE:
        if (getConnectState( ) == ALL_CONNECTED && allDataReady( )) {
            sendLynceanConfig( );
        } else {
            sendLynceanMoveCompleted( );
        }
        break;

    case DCS_DEVICE_WAITING_ACK:
        //both DMOV and RBV can transfer from WAITING_ACK to ACTIVE
        sendMoveStarted( );
        m_dcsStatus = DCS_DEVICE_ACTIVE;
        break;

    default:
        sendMoveUpdate( DCS_MOTOR_NORMAL );
    }
}
void GwLynceanMotor::updateDCSSByConfig( ) {
    switch (getDcsStatus( )) {
    case DCS_DEVICE_WAITING_ACK:
    case DCS_DEVICE_ACTIVE:
    case DCS_DEVICE_ABORTING:
        m_sendConfigPending = true;
        return;

    case DCS_DEVICE_INACTIVE:
    default:
        ;
    }
    m_sendConfigPending = false;
    sendLynceanConfig( );
}
//2 cases:
// 1: FBK call back with minDelay
// 2: in WAITING_ACK state
void GwLynceanMotor::updateDCSSByPoll( ) {
    switch (m_dcsStatus) {
    case DCS_DEVICE_WAITING_ACK:
        if (time( NULL ) > m_PVArray[CHID_SP].tsPut + 2) {
            sendMoveCompleted( "timeout" );
            m_dcsStatus = DCS_DEVICE_INACTIVE;
        }
        break;

    case DCS_DEVICE_ACTIVE:
    case DCS_DEVICE_ABORTING:
        sendMoveUpdate( DCS_MOTOR_NORMAL );
        break;

    default:
        LOG_WARNING2( "LynceanMotor %s polled when dcsStatus=%s",
            m_name, getDcsStatusText( ) );

        sendLynceanMoveCompleted( );
    }
}
//called when all monitoreddata are re-fetched from EPICS
void GwLynceanMotor::updateDCSSByRefresh( ) {
    if (m_busyCurrent) {
        m_dcsStatus = DCS_DEVICE_ACTIVE;
        sendMoveStarted( );
    } else {
        m_dcsStatus = DCS_DEVICE_INACTIVE;
        sendLynceanMoveCompleted( );
    }
}
void GwLynceanMotor::move( double newPosition ) {
    XOSSingleLock hold_lock( &m_lock );

    if (getConnectState( ) < BASIC_CONNECTED) {
        char contents[DCS_DEVICE_NAME_SIZE + 128];
        strcpy( contents, "LynceanMotor " );
        strcat( contents, m_name );
        strcat( contents, " disconnected" );
        DcsMessage* pMsg =
        m_pDcsMsgManager->NewLog( "error", "epicsgw", contents );
        sendDcsMsg( pMsg );
        
        sendLynceanMoveCompleted( );
        return;
    }

    if (m_busyCurrent) {
        char contents[DCS_DEVICE_NAME_SIZE + 128];
        strcpy( contents, "LynceanMotor " );
        strcat( contents, m_name );
        strcat( contents, " busy" );
        DcsMessage* pMsg =
        m_pDcsMsgManager->NewLog( "error", "epicsgw", contents );
        sendDcsMsg( pMsg );
        
        sendMoveCompleted( "busy" );
        return;
    }

    double stepSize = 0.001;
    if (fabs( newPosition - m_positionCurrent ) < stepSize) {
        sendMoveCompleted( "normal" );
        return;
    }

    m_moveStartedByDCSS = true;

    //need push out to epics
    m_dcsStatus = DCS_DEVICE_WAITING_ACK;
    m_positionToSend = newPosition;
    m_PVArray[CHID_SP].needPut = true;
    flushEPICS( );
    setupPollForTimeout( );
}
void GwLynceanMotor::stop( ) {
    switch (getDcsStatus( )) {
    case DCS_DEVICE_WAITING_ACK:
    case DCS_DEVICE_ACTIVE:
        m_PVArray[CHID_STOP].needPut = true;
        m_dcsStatus = DCS_DEVICE_ABORTING;
        if (!flushEPICSOnePV( CHID_STOP )) {
            LOG_WARNING1( "aborting LynceanMotor %s failed", m_name );
        } else {
            LOG_FINEST1( "aborting LynceanMotor %s", m_name );
            ca_flush_io( );
        }
        break;

    case DCS_DEVICE_INACTIVE:
    case DCS_DEVICE_ABORTING:
    default:
        break;
    }
}

//internal, no safety check
void GwLynceanMotor::fillPVValPointers( int index ) {
    switch (index) {
    case CHID_STOP:
        m_PVArray[index].pValToPut = &m_stopToSend;
        break;

    case CHID_BUSY:
        m_PVArray[index].pValFromMonitor = &m_busyCurrent;
        break;

    case CHID_SP:
        m_PVArray[index].pValToPut = &m_positionToSend;
        break;

    case CHID_MON:
        m_PVArray[index].pValFromMonitor = &m_positionCurrent;
        break;

    case CHID_ERROR:
        m_PVArray[index].pValFromMonitor = &m_errorCurrent;
        break;

    case CHID_MSG:
        m_PVArray[index].pValFromMonitor = &m_msgCurrent;
        break;

    case CHID_DRVH:
        m_PVArray[index].pValFromMonitor = &m_limitUpper;
        break;

    case CHID_DRVL:
        m_PVArray[index].pValFromMonitor = &m_limitLower;
        break;

    default:
        break;
    }
}
void GwLynceanMotor::sendErrorMsg( ) {
    char contents[DCS_DEVICE_NAME_SIZE + MAX_STRING_SIZE + 1024] = {0};
    DcsMessage* pMsg = NULL;

    strcpy( contents, m_name );
    strcat( contents, " " );
    strncat( contents, m_msgCurrent, MAX_STRING_SIZE );
    LOG_INFO1( "sendErrorMsg %s", contents );
    pMsg = m_pDcsMsgManager->NewLog( "error", "epicsgw", contents );
    sendDcsMsg( pMsg );
}
