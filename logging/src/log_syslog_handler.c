#include <sys/types.h>
#include <sys/stat.h>
#include <stdarg.h>
#include <stdio.h>
#include "logging.h"
#include "log_handler.h"
#include "log_syslog_handler.h"

#define DEF_MAX_SIZE 500

#ifdef WIN32
#define TMP_DIR "c:\\temp"
#else
#define TMP_DIR "/var/tmp"
#endif

#define LOG_SYSLOG_PREFIX_LEN 250

/*************************************************88
 * 07/02/04:
 * if stream is null, try to reopen it
 * at init, try to find a good rotating_id,
 * not always start from 0.
 * it will try to find the not exist file or oldest file
 */


/*********************************************************
 *
 * new log_handler_t data structure
 *
 *********************************************************/
typedef struct __log_syslog_data
{
    /* stdout or stderr */
    char prefix[LOG_SYSLOG_PREFIX_LEN];
    int logopt;
    int facility;

} log_syslog_data_t;



/*********************************************************
 *
 * Deallocate memory for log_handler_t
 *
 *********************************************************/
 static log_syslog_data_t* get_data(void* d)
 {
    if (!d)
        return NULL;

    return (log_syslog_data_t*)d;



 }


/*********************************************************
 *
 * Check if the file has reached the maximum size
 *
 *********************************************************/
static void flush_(log_handler_t* self)
{
	/** Nothing to do **/
}

/*********************************************************
 *
 * Closes the descriptor being used to write to the system logger.
 * The use of closelog() is optional.
 *
 *********************************************************/
static void close_(log_handler_t* self)
{
    void call_closelog();
    
    call_closelog();


}

/*********************************************************
 *
 * The openlog() function provides for more specialized processing of the
 * messages sent by syslog() and vsyslog().  The parameter ident is a string
 * that will be prepended to every message.  The logopt argument is a bit
 * field specifying logging options, which is formed by OR'ing one or more
 * of the following values:
 * LOG_CONS - console
 * LOG_NDELAY - Open the connection to syslogd immediately
 * LOG_ODELAY - Delay opening the connection to syslogd until first syslog is called.
 * LOG_PERROR - standard error output as well to the system log
 * LOG_PID - Log the process id with each message
 * 
 * The facility parameter encodes a default facility to be assigned to all
 * messages that do not have an explicit facility encoded:
 *
 * LOG_AUTH      The authorization system: login(1), su(1), getty(8), etc.
 * LOG_AUTHPRIV  The same as LOG_AUTH, but logged to a file readable only by
 *               selected individuals.
 * LOG_CONSOLE   Messages written to /dev/console by the kernel console out-output
 *               put driver.
 * LOG_CRON      The cron daemon: cron(8).
 * LOG_DAEMON    System daemons, such as routed(8), that are not provided
                 for explicitly by other facilities.
 * LOG_FTP       The file transfer protocol daemons: ftpd(8), tftpd(8).
 * LOG_KERN      Messages generated by the kernel.  These cannot be gener-generated
 *               ated by any user processes.
 * LOG_LPR       The line printer spooling system: lpr(1), lpc(8), lpd(8),
 *               etc.
 * LOG_MAIL      The mail system.
 * LOG_NEWS      The network news system.
 * LOG_SECURITY  Security subsystems, such as ipfw(4).
 * LOG_SYSLOG    Messages generated internally by syslogd(8).
 * LOG_USER      Messages generated by random user processes.  This is the
 *               default facility identifier if none is specified.
 * LOG_UUCP      The uucp system.
 * LOG_LOCAL0    Reserved for local use.  Similarly for LOG_LOCAL1 through
 *               LOG_LOCAL7.
 *********************************************************/
static void open_(log_handler_t* self)
{
	void call_openlog(const char*, int, int);

    	log_syslog_data_t* data = get_data(self->data_);
	call_openlog(data->prefix, data->logopt, data->facility);
}

/*********************************************************
 *
 * Publish a LogRecord.
 * The logging request was made initially to a Logger object,
 * which initialized the LogRecord and forwarded it here.
 *
 * The Handler is responsible for formatting the message,
 * when and if necessary. The formatting should include localization.
 *
 *********************************************************/
static void publish(log_handler_t* self, log_record_t* record)
{
	int get_syslog_level(const char*);
	void call_syslog(int, const char*, ...);
	
    	log_syslog_data_t* data = get_data(self->data_);
	if (data) {
		/* Converts log level to syslog priority */
		log_level_t* level = log_record_get_level(record);
		if ((level != NULL) && (level != LOG_OFF)) {
			int priority = get_syslog_level(log_level_get_name(level));
/*			printf("log level name = %s, priority = %d\n", 
				log_level_get_name(level), priority);*/
			call_syslog(priority, log_formatter_format(log_handler_get_formatter(self), record));
		}
	}
}

/*********************************************************
 *
 * Called when the base class's destroy() is called.
 *
 *********************************************************/
static void destroy(log_handler_t* self)
{
	close_(self);
	    
	free((log_syslog_data_t*)self->data_);
}


/*********************************************************
 *
 * Initialize a FileHandler to write to the given filename.
 *
 *********************************************************/
void log_syslog_handler_init(log_handler_t* self, const char* prefix_, int opt_, int facility_)
{
    void __log_handler_init(log_handler_t* self);
    log_syslog_data_t* data = NULL;

    if (!self)
    {
        save_logger_error( "self NULL in log_syslog_handler_init" );
        return;
    }

    __log_handler_init(self);
	
    data = malloc(sizeof(log_syslog_data_t));
    if (data) {
        strcpy(data->prefix, prefix_);
	data->logopt = opt_;
	data->facility = facility_;
   } else {
        save_logger_error( "failed to allocate memory for syslog hanler data" );
    }

    self->data_ = data;
    self->formatter = NULL;
    self->filter = NULL;
    self->level = LOG_ALL;
    self->close = &close_;
    self->flush = &flush_;
    self->publish = &publish;
    self->destroy = &destroy;

    open_(self);

}


/*********************************************************
 *
 * Initialize a FileHandler to write to the given filename.
 *
 *********************************************************/
log_handler_t* log_syslog_handler_new(const char*  prefix_, int facility_)
{
    log_handler_t* __log_handler_new();

    log_handler_t* self = __log_handler_new();
    
    log_syslog_handler_init(self, prefix_, 0, facility_);

    return self;
}

